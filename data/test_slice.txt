<1> int cpu_ppc_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n<47> } else if (ret < 0) {\n<383> switch (access_type) {\n<439> printf("DSI: invalid exception (%d)\n", ret);
<1> NewConverter * CnvExtOpen ( UCMFile * ucm ) {\n<4> if ( extData == NULL ) {\n<5> printf ( "out of memory\n" ) ;
<1> static int tunnel_dns ( int tun_fd , int dns_fd , int bind_fd ) {\n<6> if ( ( read = read_dns ( dns_fd , tun_fd , & q ) ) <= 0 ) return 0 ;\n<7> if ( debug >= 2 ) {\n<8> fprintf ( stderr , "RX: client %s, type %d, name %s\n" , format_addr ( & q . from , q . fromlen ) , q . type , q . name ) ;\n<10> domain_len = strlen ( q . name ) - strlen ( topdomain ) ;\n<11> if ( domain_len >= 0 && ! strcasecmp ( q . name + domain_len , topdomain ) ) inside_topdomain = 1 ;\n<14> if ( domain_len == 3 && q . type == T_A && ( q . name [ 0 ] == 'n' || q . name [ 0 ] == 'N' ) && ( q . name [ 1 ] == 's' || q . name [ 1 ] == 'S' ) && q . name [ 2 ] == '.' ) {\n<15> handle_a_request ( dns_fd , & q , 0 ) ;\n<18> if ( domain_len == 4 && q . type == T_A && ( q . name [ 0 ] == 'w' || q . name [ 0 ] == 'W' ) && ( q . name [ 1 ] == 'w' || q . name [ 1 ] == 'W' ) && ( q . name [ 2 ] == 'w' || q . name [ 2 ] == 'W' ) && q . name [ 3 ] == '.' ) {\n<19> handle_a_request ( dns_fd , & q , 1 ) ;\n<23> case T_NULL : case T_PRIVATE : case T_CNAME : case T_A : case T_MX : case T_SRV : case T_TXT : handle_null_request ( tun_fd , dns_fd , & q , domain_len ) ;\n<25> case T_NS : handle_ns_request ( dns_fd , & q ) ;\n<32> forward_query ( bind_fd , & q ) ;
<1> static int decode_frame_apng(AVCodecContext *avctx,\n<9> PNGDecContext *const s = avctx->priv_data;\n<29> uint8_t *side_data = NULL;\n<33> side_data = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA, &side_data_size);\n<39> av_freep(&s->extra_data);\n<43> if (!s->extra_data)\n<47> s->extra_data_size = side_data_size;\n<49> memcpy(s->extra_data, side_data, s->extra_data_size);\n<55> if (!s->extra_data_size)\n<69> bytestream2_init(&s->gb, s->extra_data, s->extra_data_size);
<1> char * kadmin_startup ( int argc , char * argv [ ] ) {\n<3> char * princstr = NULL , * keytab_name = NULL , * query = NULL ;\n<12> char * * db_args = NULL ;\n<14> char * db_name = NULL ;\n<16> memset ( & params , 0 , sizeof ( params ) ) ;\n<17> if ( strcmp ( whoami , "kadmin.local" ) == 0 ) set_com_err_hook ( extended_com_err_fn ) ;\n<20> com_err ( whoami , retval , _ ( "while initializing krb5 library" ) ) ;\n<23> while ( ( optchar = getopt ( argc , argv , "x:r:p:knq:w:d:s:mc:t:e:ON" ) ) != EOF ) {\n<24> switch ( optchar ) {\n<26> db_args = realloc ( db_args , sizeof ( char * ) * ( db_args_size + 1 ) ) ;\n<27> if ( db_args == NULL ) {\n<28> fprintf ( stderr , _ ( "%s: Cannot initialize. Not enough memory\n" ) , argv [ 0 ] ) ;\n<31> db_args [ db_args_size - 1 ] = optarg ;\n<32> db_args [ db_args_size ] = NULL ;\n<34> case 'r' : def_realm = optarg ;\n<36> case 'p' : princstr = optarg ;\n<38> case 'c' : ccache_name = optarg ;\n<44> case 't' : keytab_name = optarg ;\n<46> case 'w' : password = optarg ;\n<48> case 'q' : query = optarg ;\n<50> case 'd' : free ( db_name ) ;\n<51> asprintf ( & db_name , "dbname=%s" , optarg ) ;\n<53> db_args = realloc ( db_args , sizeof ( char * ) * ( db_args_size + 1 ) ) ;\n<54> if ( db_args == NULL ) {\n<55> fprintf ( stderr , _ ( "%s: Cannot initialize. Not enough memory\n" ) , argv [ 0 ] ) ;\n<58> db_args [ db_args_size - 1 ] = db_name ;\n<59> db_args [ db_args_size ] = NULL ;\n<61> case 's' : params . admin_server = optarg ;\n<67> case 'e' : retval = krb5_string_to_keysalts ( optarg , ", \t" , ":.-" , 0 , & params . keysalts , & params . num_keysalts ) ;\n<69> com_err ( whoami , retval , _ ( "while parsing keysalts %s" ) , optarg ) ;\n<81> if ( ( ccache_name && use_keytab ) || ( keytab_name && ! use_keytab ) || ( ccache_name && use_anonymous ) || ( use_anonymous && use_keytab ) ) usage ( ) ;\n<82> if ( def_realm == NULL && krb5_get_default_realm ( context , & def_realm ) ) {\n<83> fprintf ( stderr , _ ( "%s: unable to get default realm\n" ) , whoami ) ;\n<93> com_err ( whoami , retval , _ ( "while opening default credentials cache" ) ) ;\n<100> com_err ( whoami , retval , _ ( "while opening credentials cache %s" ) , ccache_name ) ;\n<104> if ( princstr == NULL ) {\n<106> retval = krb5_unparse_name ( context , princ , & princstr ) ;\n<108> com_err ( whoami , retval , _ ( "while canonicalizing principal name" ) ) ;\n<117> com_err ( whoami , retval , _ ( "creating host service principal" ) ) ;\n<120> retval = krb5_unparse_name ( context , princ , & princstr ) ;\n<122> com_err ( whoami , retval , _ ( "while canonicalizing principal name" ) ) ;\n<128> else if ( ! krb5_cc_get_principal ( context , cc , & princ ) ) {\n<129> if ( krb5_unparse_name ( context , princ , & canon ) ) {\n<130> fprintf ( stderr , _ ( "%s: unable to canonicalize principal\n" ) , whoami ) ;\n<133> realm = strchr ( canon , '@' ) ;\n<135> if ( realm > canon && * ( realm - 1 ) != '\\' ) break ;\n<136> realm = strchr ( realm + 1 , '@' ) ;\n<138> if ( realm ) * realm ++ = '\0' ;\n<139> cp = strchr ( canon , '/' ) ;\n<141> if ( cp > canon && * ( cp - 1 ) != '\\' ) break ;\n<142> cp = strchr ( cp + 1 , '/' ) ;\n<144> if ( cp != NULL ) * cp = '\0' ;\n<145> if ( asprintf ( & princstr , "%s/admin%s%s" , canon , ( realm ) ? "@" : "" , ( realm ) ? realm : "" ) < 0 ) {\n<146> fprintf ( stderr , _ ( "%s: out of memory\n" ) , whoami ) ;\n<147> exit ( 1 ) ;\n<149> free ( canon ) ;\n<153> else if ( ( luser = getenv ( "USER" ) ) ) {\n<154> if ( asprintf ( & princstr , "%s/admin@%s" , luser , def_realm ) < 0 ) {\n<155> fprintf ( stderr , _ ( "%s: out of memory\n" ) , whoami ) ;\n<156> exit ( 1 ) ;\n<158> freeprinc ++ ;\n<160> else if ( ( pw = getpwuid ( getuid ( ) ) ) ) {\n<161> if ( asprintf ( & princstr , "%s/admin@%s" , pw -> pw_name , def_realm ) < 0 ) {\n<162> fprintf ( stderr , _ ( "%s: out of memory\n" ) , whoami ) ;\n<163> exit ( 1 ) ;\n<168> fprintf ( stderr , _ ( "%s: unable to figure out a principal name\n" ) , whoami ) ;\n<172> retval = krb5_klog_init ( context , "admin_server" , whoami , 0 ) ;\n<177> if ( ccache_name ) {\n<178> printf ( _ ( "Authenticating as principal %s with existing " "credentials.\n" ) , princstr ) ;\n<179> retval = kadm5_init_with_creds ( context , princstr , cc , svcname , & params , KADM5_STRUCT_VERSION , KADM5_API_VERSION_4 , db_args , & handle ) ;\n<186> else if ( use_keytab ) {\n<187> if ( keytab_name ) printf ( _ ( "Authenticating as principal %s with keytab %s.\n" ) , princstr , keytab_name ) ;\n<188> else printf ( _ ( "Authenticating as principal %s with default keytab.\n" ) , princstr ) ;\n<189> retval = kadm5_init_with_skey ( context , princstr , keytab_name , svcname , & params , KADM5_STRUCT_VERSION , KADM5_API_VERSION_4 , db_args , & handle ) ;\n<192> printf ( _ ( "Authenticating as principal %s with password.\n" ) , princstr ) ;\n<193> retval = kadm5_init_with_password ( context , princstr , password , svcname , & params , KADM5_STRUCT_VERSION , KADM5_API_VERSION_4 , db_args , & handle ) ;\n<200> if ( freeprinc ) free ( princstr ) ;\n<201> free ( db_name ) ;\n<202> free ( db_args ) ;
<1> static int user_key_command_allowed2 ( struct ssh * ssh , struct passwd * user_pw , struct sshkey * key , struct sshauthopt * * authoptsp ) {\n<7> char * username = NULL , * key_fp = NULL , * keytext = NULL ;\n<8> char uidstr [ 32 ] , * tmp , * command = NULL , * * av = NULL ;\n<12> if ( options . authorized_keys_command_user == NULL ) {\n<18> runas_pw = getpwnam ( username ) ;\n<19> if ( runas_pw == NULL ) {\n<20> error ( "AuthorizedKeysCommandUser \"%s\" not found: %s" , username , strerror ( errno ) ) ;\n<23> if ( ( key_fp = sshkey_fingerprint ( key , options . fingerprint_hash , SSH_FP_DEFAULT ) ) == NULL ) {\n<27> if ( ( r = sshkey_to_base64 ( key , & keytext ) ) != 0 ) {\n<31> if ( argv_split ( options . authorized_keys_command , & ac , & av ) != 0 ) {\n<32> error ( "AuthorizedKeysCommand \"%s\" contains invalid quotes" , command ) ;\n<36> error ( "AuthorizedKeysCommand \"%s\" yielded no arguments" , command ) ;\n<41> i < ac ;\n<43> tmp = percent_expand ( av [ i ] , "U" , uidstr , "u" , user_pw -> pw_name , "h" , user_pw -> pw_dir , "t" , sshkey_ssh_name ( key ) , "f" , key_fp , "k" , keytext , ( char * ) NULL ) ;\n<45> free ( av [ i ] ) ;\n<46> av [ i ] = tmp ;\n<48> command = argv_assemble ( ac , av ) ;\n<49> if ( ac == 1 ) {\n<52> av [ 2 ] = NULL ;\n<53> free ( command ) ;\n<54> xasprintf ( & command , "%s %s" , av [ 0 ] , av [ 1 ] ) ;\n<56> if ( ( pid = subprocess ( "AuthorizedKeysCommand" , runas_pw , command , ac , av , & f , SSH_SUBPROCESS_STDOUT_CAPTURE | SSH_SUBPROCESS_STDERR_DISCARD ) ) == 0 ) goto out ;\n<62> if ( exited_cleanly ( pid , "AuthorizedKeysCommand" , command , 0 ) != 0 ) goto out ;\n<67> i < ac ;\n<68> i ++ ) free ( av [ i ] ) ;\n<69> free ( av ) ;\n<71> free ( command ) ;\n<72> free ( username ) ;\n<73> free ( key_fp ) ;\n<74> free ( keytext ) ;
<1> static char * w_addchar ( char * buffer , size_t * actlen , size_t * maxlen , char ch ) {\n<2> if ( * actlen == * maxlen ) {\n<3> char * old_buffer = buffer ;\n<4> assert ( buffer == NULL || * maxlen != 0 ) ;\n<5> * maxlen += W_CHUNK ;\n<6> buffer = ( char * ) realloc ( buffer , 1 + * maxlen ) ;\n<7> if ( buffer == NULL ) free ( old_buffer ) ;
<1> static int dumpcidglyphs ( SplineFont * sf , struct alltabs * at ) {\n<11> at -> fds = calloc ( sf -> subfontcnt , sizeof ( struct fd2data ) ) ;\n<16> ATFigureDefWidth ( sf -> subfonts [ i ] , at , i ) ;\n<18> if ( ( chrs = CID2ChrsSubrs2 ( sf , at -> fds , at -> gi . flags , & glbls , at -> gi . layer ) ) == NULL ) return ( false ) ;
<1> static int myisamchk ( MI_CHECK * param , char * filename ) {\n<13> if ( ! ( info = mi_open ( filename , ( param -> testflag & ( T_DESCRIPT | T_READONLY ) ) ? O_RDONLY : O_RDWR , HA_OPEN_FOR_REPAIR | ( ( param -> testflag & T_WAIT_FOREVER ) ? HA_OPEN_WAIT_IF_LOCKED : ( param -> testflag & T_DESCRIPT ) ? HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED ) ) ) ) {\n<16> case HA_ERR_CRASHED : mi_check_print_error ( param , "'%s' doesn't have a correct index definition. You need to recreate it before you can do a repair" , filename ) ;\n<18> case HA_ERR_NOT_A_TABLE : mi_check_print_error ( param , "'%s' is not a MyISAM-table" , filename ) ;\n<20> case HA_ERR_CRASHED_ON_USAGE : mi_check_print_error ( param , "'%s' is marked as crashed" , filename ) ;\n<22> case HA_ERR_CRASHED_ON_REPAIR : mi_check_print_error ( param , "'%s' is marked as crashed after last repair" , filename ) ;\n<24> case HA_ERR_OLD_FILE : mi_check_print_error ( param , "'%s' is an old type of MyISAM-table" , filename ) ;\n<26> case HA_ERR_END_OF_FILE : mi_check_print_error ( param , "Couldn't read complete header from '%s'" , filename ) ;\n<28> case EAGAIN : mi_check_print_error ( param , "'%s' is locked. Use -w to wait until unlocked" , filename ) ;\n<30> case ENOENT : mi_check_print_error ( param , "File '%s' doesn't exist" , filename ) ;\n<32> case EACCES : mi_check_print_error ( param , "You don't have permission to use '%s'" , filename ) ;\n<34> default : mi_check_print_error ( param , "%d when opening MyISAM-table '%s'" , my_errno , filename ) ;\n<53> if ( ! ( param -> testflag & T_SILENT ) || param -> testflag & T_INFO ) printf ( "MyISAM file: %s is already checked\n" , filename ) ;\n<55> mi_check_print_error ( param , "%d when closing MyISAM-table '%s'" , my_errno , filename ) ;\n<63> if ( recreate_table ( param , & info , filename ) ) {\n<64> ( void ) fprintf ( stderr , "MyISAM-table '%s' is not fixed because of errors\n" , filename ) ;\n<70> if ( ! ( param -> testflag & T_SILENT ) ) printf ( "- '%s' has old table-format. Recreating index\n" , filename ) ;\n<81> descript ( param , info , filename ) ;\n<89> mi_check_print_error ( param , "Can't lock indexfile of '%s', error: %d" , filename , my_errno ) ;\n<114> if ( param -> testflag & T_REP_BY_SORT ) error = mi_repair_by_sort ( param , info , filename , rep_quick , FALSE ) ;\n<115> else error = mi_repair_parallel ( param , info , filename , rep_quick , FALSE ) ;\n<118> else if ( param -> testflag & T_REP_ANY ) error = mi_repair ( param , info , filename , rep_quick , FALSE ) ;\n<123> error |= change_to_newfile ( filename , MI_NAME_DEXT , DATA_TMP_EXT , MYF ( 0 ) ) ;\n<134> error = mi_sort_records ( param , info , filename , param -> opt_sort_key , ( my_bool ) ! ( param -> testflag & T_REP ) , update_index ) ;\n<143> if ( ! error && param -> testflag & T_SORT_INDEX ) error = mi_sort_index ( param , info , filename , FALSE ) ;
<1> static void copy_superblock ( uint16_t * dest , unsigned dest_stride , uint16_t * src , unsigned src_stride ) {\n<4> y < 8 ;\n<5> y ++ ) memcpy ( dest + y * dest_stride , src + y * src_stride , sizeof ( uint16_t ) * 8 ) ;\n<7> y < 8 ;\n<8> y ++ ) memset ( dest + y * dest_stride , 0 , sizeof ( uint16_t ) * 8 ) ;
<1> const char * xd3_mainerror ( int err_num ) {\n<3> if ( x != NULL ) {\n<6> return strerror ( err_num ) ;
<1> static void ctl_putuint ( const char * tag , u_long uval ) {\n<10> snprintf ( cp , sizeof ( buffer ) - ( cp - buffer ) , "%lu" , uval ) ;\n<11> cp += strlen ( cp ) ;\n<12> ctl_putdata ( buffer , ( unsigned ) ( cp - buffer ) , 0 ) ;
<1> int main ( int argc , char * * argv ) {\n<100> memset ( & sa_sigterm , 0 , sizeof ( sa_sigterm ) ) ;\n<102> sigaction ( SIGTERM , & sa_sigterm , NULL ) ;\n<110> while ( ( ch = getopt_long ( argc , argv , sopt , lopt , & opt_ind ) ) != - 1 ) {\n<111> switch ( ch ) {\n<120> if ( bdrv_parse_cache_mode ( optarg , & flags , & writethrough ) == - 1 ) {\n<121> error_report ( "Invalid cache mode `%s'" , optarg ) ;\n<130> if ( ! strcmp ( optarg , "native" ) ) {\n<131> flags |= BDRV_O_NATIVE_AIO ;\n<133> else if ( ! strcmp ( optarg , "threads" ) ) {\n<136> error_report ( "invalid aio mode `%s'" , optarg ) ;\n<137> exit ( EXIT_FAILURE ) ;\n<145> if ( bdrv_parse_discard_flags ( optarg , & flags ) == - 1 ) {\n<146> error_report ( "Invalid discard mode `%s'" , optarg ) ;\n<150> case QEMU_NBD_OPT_DETECT_ZEROES : detect_zeroes = qapi_enum_parse ( BlockdevDetectZeroesOptions_lookup , optarg , BLOCKDEV_DETECT_ZEROES_OPTIONS__MAX , BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF , & local_err ) ;\n<160> case 'b' : bindto = optarg ;\n<162> case 'p' : port = optarg ;\n<164> case 'o' : dev_offset = strtoll ( optarg , & end , 0 ) ;\n<166> error_report ( "Invalid offset `%s'" , optarg ) ;\n<170> error_report ( "Offset must be positive `%s'" , optarg ) ;\n<174> case 'l' : if ( strstart ( optarg , SNAPSHOT_OPT_BASE , NULL ) ) {\n<175> sn_opts = qemu_opts_parse_noisily ( & internal_snapshot_opts , optarg , false ) ;\n<177> error_report ( "Failed in parsing snapshot param `%s'" , optarg ) ;\n<187> case 'P' : partition = strtol ( optarg , & end , 0 ) ;\n<189> error_report ( "Invalid partition `%s'" , optarg ) ;\n<197> case 'k' : sockpath = optarg ;\n<205> case 'c' : device = optarg ;\n<207> case 'e' : shared = strtol ( optarg , & end , 0 ) ;\n<209> error_report ( "Invalid shared device number '%s'" , optarg ) ;\n<217> case 'f' : fmt = optarg ;\n<221> case 'x' : export_name = optarg ;\n<223> case 'D' : export_description = optarg ;\n<237> opts = qemu_opts_parse_noisily ( & qemu_object_opts , optarg , true ) ;\n<243> case QEMU_NBD_OPT_TLSCREDS : tlscredsid = optarg ;\n<248> trace_file = trace_opt_parse ( optarg ) ;\n<300> if ( disconnect ) {\n<301> int nbdfd = open ( argv [ optind ] , O_RDWR ) ;\n<302> if ( nbdfd < 0 ) {\n<303> error_report ( "Cannot open %s: %s" , argv [ optind ] , strerror ( errno ) ) ;\n<308> printf ( "%s disconnected\n" , argv [ optind ] ) ;\n<315> if ( qemu_pipe ( stderr_fd ) < 0 ) {\n<316> error_report ( "Error setting up communication pipe: %s" , strerror ( errno ) ) ;\n<320> if ( pid < 0 ) {\n<321> error_report ( "Failed to fork: %s" , strerror ( errno ) ) ;\n<329> if ( ret < 0 ) {\n<330> error_report ( "Failed to daemonize: %s" , strerror ( errno ) ) ;\n<347> if ( ret < 0 ) {\n<348> error_report ( "Cannot read from daemon: %s" , strerror ( errno ) ) ;\n<422> if ( fd_size < 0 ) {\n<423> error_report ( "Failed to determine the image length: %s" , strerror ( - fd_size ) ) ;\n<433> if ( ret < 0 ) {\n<434> error_report ( "Could not find partition %d: %s" , partition , strerror ( - ret ) ) ;\n<452> if ( device ) {\n<455> if ( ret != 0 ) {\n<456> error_report ( "Failed to create client thread: %s" , strerror ( ret ) ) ;\n<461> memset ( & client_thread , 0 , sizeof ( client_thread ) ) ;\n<464> if ( chdir ( "/" ) < 0 ) {\n<465> error_report ( "Could not chdir to root directory: %s" , strerror ( errno ) ) ;\n<490> pthread_join ( client_thread , & ret ) ;\n<491> exit ( ret != NULL ) ;
<1> static int nsv_parse_NSVf_header(AVFormatContext *s)\n<99> while (*p == ' ')\n<103> if (p >= endp-2)\n<109> p = strchr(p, '=');\n<111> if (!p || p >= endp-2)\n<117> quote = *p++;\n<121> p = strchr(p, quote);\n<123> if (!p || p >= endp)
<1> static void test_signal_switchbase ( void ) {\n<6> printf ( "Signal switchbase: " ) ;\n<9> is_kqueue = ! strcmp ( event_get_method ( ) , "kqueue" ) ;\n<12> if ( event_base_set ( base1 , & ev1 ) || event_base_set ( base2 , & ev2 ) || event_add ( & ev1 , NULL ) || event_add ( & ev2 , NULL ) ) {\n<13> fprintf ( stderr , "%s: cannot set base, add\n" , __func__ ) ;\n<24> if ( test_ok && ! is_kqueue ) {
<1> int av_parse_color(uint8_t *rgba_color, const char *color_string, void *log_ctx)\n<19> if (!strncmp(color_string, "0x", 2)) {\n<23> int len = strlen(color_string);\n<25> int rgba = strtol(color_string, &tail, 16);\n<29> if (*tail || (len != 8 && len != 10)) {\n<37> if (len == 10) {\n<63> if (!entry) {\n<71> memcpy(rgba_color, entry->rgba_color, 4);
<1> int net_slirp_parse_legacy(QemuOptsList *opts_list, const char *optarg, int *ret)\n<5> if (strcmp(opts_list->name, "net") != 0 ||\n<7> strncmp(optarg, "channel,", strlen("channel,")) != 0) {\n<9> return 0;\n<15> error_report("The '-net channel' option is deprecated. "\n<23> optarg += strlen("channel,");\n<27> if (QTAILQ_EMPTY(&slirp_stacks)) {\n<35> pstrcpy(config->str, sizeof(config->str), optarg);\n<47> *ret = slirp_guestfwd(QTAILQ_FIRST(&slirp_stacks), optarg, 1);\n<53> return 1;
<1> void AUD_vlog (const char *cap, const char *fmt, va_list ap)\n<21> if (cap) {\n<23> fprintf (stderr, "%s: ", cap);\n<29> vfprintf (stderr, fmt, ap);
<1> static void qxl_reset_surfaces(PCIQXLDevice *d)\n<15> memset(&d->guest_surfaces.cmds, 0, sizeof(d->guest_surfaces.cmds));
<1> static void simple_write_cb ( int fd , short event , void * arg ) {\n<3> if ( arg == NULL ) return ;\n<4> len = write ( fd , TEST1 , strlen ( TEST1 ) + 1 ) ;\n<5> if ( len == - 1 ) test_ok = 0 ;
<1> static int gdb_handle_packet(GDBState *s, const char *line_buf)\n<31> ch = *p++;\n<33> switch(ch) {\n<325> len = strlen(p) / 2;\n<327> hextomem((uint8_t *)registers, p, len);\n<427> if (!gdb_has_xml)\n<431> addr = strtoull(p, (char **)&p, 16);\n<433> if (*p == '=')\n<435> p++;\n<437> reg_size = strlen(p) / 2;\n<439> hextomem(mem_buf, p, reg_size);\n<565> if (!strcmp(p,"qemu.sstepbits")) {\n<569> snprintf(buf, sizeof(buf), "ENABLE=%x,NOIRQ=%x,NOTIMER=%x",\n<577> put_packet(s, buf);\n<581> } else if (strncmp(p,"qemu.sstep",10) == 0) {\n<609> } else if (strcmp(p,"C") == 0) {\n<615> put_packet(s, "QC1");\n<619> } else if (strcmp(p,"fThreadInfo") == 0) {\n<621> s->query_cpu = first_cpu->env_ptr;\n<625> } else if (strcmp(p,"sThreadInfo") == 0) {\n<629> if (s->query_cpu) {\n<645> } else if (strncmp(p,"ThreadExtraInfo,", 16) == 0) {\n<701> else if (strncmp(p, "Rcmd,", 5) == 0) {\n<703> int len = strlen(p + 5);\n<707> if ((len % 2) != 0) {
<1> static int nb_add_value_list ( lcc_network_buffer_t * nb , const lcc_value_list_t * vl ) {\n<6> ident_src = & vl -> identifier ;\n<7> ident_dst = & nb -> state . identifier ;\n<8> if ( strcmp ( ident_dst -> host , ident_src -> host ) != 0 ) {\n<9> if ( nb_add_string ( & buffer , & buffer_size , TYPE_HOST , ident_src -> host , strlen ( ident_src -> host ) ) != 0 ) return ( - 1 ) ;\n<12> if ( strcmp ( ident_dst -> plugin , ident_src -> plugin ) != 0 ) {\n<13> if ( nb_add_string ( & buffer , & buffer_size , TYPE_PLUGIN , ident_src -> plugin , strlen ( ident_src -> plugin ) ) != 0 ) return ( - 1 ) ;\n<16> if ( strcmp ( ident_dst -> plugin_instance , ident_src -> plugin_instance ) != 0 ) {\n<17> if ( nb_add_string ( & buffer , & buffer_size , TYPE_PLUGIN_INSTANCE , ident_src -> plugin_instance , strlen ( ident_src -> plugin_instance ) ) != 0 ) return ( - 1 ) ;\n<20> if ( strcmp ( ident_dst -> type , ident_src -> type ) != 0 ) {\n<21> if ( nb_add_string ( & buffer , & buffer_size , TYPE_TYPE , ident_src -> type , strlen ( ident_src -> type ) ) != 0 ) return ( - 1 ) ;\n<24> if ( strcmp ( ident_dst -> type_instance , ident_src -> type_instance ) != 0 ) {\n<25> if ( nb_add_string ( & buffer , & buffer_size , TYPE_TYPE_INSTANCE , ident_src -> type_instance , strlen ( ident_src -> type_instance ) ) != 0 ) return ( - 1 ) ;\n<28> if ( nb -> state . time != vl -> time ) {
<1> static int wb_write_out ( struct archive_write * a ) {\n<2> struct iso9660 * iso9660 = ( struct iso9660 * ) a -> format_data ;\n<12> if ( nw ) {\n<14> memmove ( iso9660 -> wbuff , iso9660 -> wbuff + wsize - nw , nw ) ;
<1> static unsigned long sun4m_load_kernel ( const char * kernel_filename , const char * initrd_filename , ram_addr_t RAM_size ) {\n<6> linux_boot = ( kernel_filename != NULL ) ;\n<13> if ( kernel_size < 0 ) kernel_size = load_aout ( kernel_filename , KERNEL_LOAD_ADDR , RAM_size - KERNEL_LOAD_ADDR , bswap_needed , TARGET_PAGE_SIZE ) ;\n<14> if ( kernel_size < 0 ) kernel_size = load_image_targphys ( kernel_filename , KERNEL_LOAD_ADDR , RAM_size - KERNEL_LOAD_ADDR ) ;\n<15> if ( kernel_size < 0 ) {\n<16> fprintf ( stderr , "qemu: could not load kernel '%s'\n" , kernel_filename ) ;\n<21> initrd_size = load_image_targphys ( initrd_filename , INITRD_LOAD_ADDR , RAM_size - INITRD_LOAD_ADDR ) ;\n<22> if ( initrd_size < 0 ) {\n<23> fprintf ( stderr , "qemu: could not load initial ram disk '%s'\n" , initrd_filename ) ;
<1> void record_sys_stats ( void ) {\n<7> day = now . l_ui / 86400 + MJD_1900 ;\n<9> if ( sysstats . fp != NULL ) {\n<10> fprintf ( sysstats . fp , "%lu %s %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu %lu\n" , day , ulfptoa ( & now , 3 ) , current_time - sys_stattime , sys_received , sys_processed , sys_newversion , sys_oldversion , sys_restricted , sys_badlength , sys_badauth , sys_declined , sys_limitrejected , sys_kodsent ) ;\n<11> fflush ( sysstats . fp ) ;
<1> static void printout_rate_control_summary ( struct RateControlMetrics * rc , vpx_codec_enc_cfg_t * cfg , int frame_cnt ) {\n<4> printf ( "Total number of processed frames: %d\n\n" , frame_cnt - 1 ) ;\n<5> printf ( "Rate control layer stats for %d layer(s):\n\n" , cfg -> ts_number_layers ) ;\n<7> i < cfg -> ts_number_layers ;\n<8> ++ i ) {\n<9> const int num_dropped = ( i > 0 ) ? ( rc -> layer_input_frames [ i ] - rc -> layer_enc_frames [ i ] ) : ( rc -> layer_input_frames [ i ] - rc -> layer_enc_frames [ i ] - 1 ) ;\n<11> rc -> layer_encoding_bitrate [ i ] = 0.001 * rc -> layer_framerate [ i ] * rc -> layer_encoding_bitrate [ i ] / tot_num_frames ;\n<12> rc -> layer_avg_frame_size [ i ] = rc -> layer_avg_frame_size [ i ] / rc -> layer_enc_frames [ i ] ;\n<13> rc -> layer_avg_rate_mismatch [ i ] = 100.0 * rc -> layer_avg_rate_mismatch [ i ] / rc -> layer_enc_frames [ i ] ;\n<14> printf ( "For layer#: %d \n" , i ) ;\n<15> printf ( "Bitrate (target vs actual): %d %f \n" , cfg -> ts_target_bitrate [ i ] , rc -> layer_encoding_bitrate [ i ] ) ;\n<16> printf ( "Average frame size (target vs actual): %f %f \n" , rc -> layer_pfb [ i ] , rc -> layer_avg_frame_size [ i ] ) ;\n<17> printf ( "Average rate_mismatch: %f \n" , rc -> layer_avg_rate_mismatch [ i ] ) ;\n<18> printf ( "Number of input frames, encoded (non-key) frames, " "and perc dropped frames: %d %d %f \n" , rc -> layer_input_frames [ i ] , rc -> layer_enc_frames [ i ] , 100.0 * num_dropped / rc -> layer_input_frames [ i ] ) ;\n<19> printf ( "\n" ) ;
<1> static int rle_unpack(const unsigned char *src, int src_len, int src_count,\n<23> pd = dest;\n<31> *pd++ = *ps++;\n<47> l = *ps++;\n<51> l = (l & 0x7F) * 2;\n<53> if (pd + l > dest_end || ps_end - ps < l)\n<57> memcpy(pd, ps, l);\n<59> ps += l;\n<61> pd += l;\n<65> if (pd + i > dest_end || ps_end - ps < 2)\n<73> *pd++ = ps[1];\n<81> i += l;
<1> static int pcm_read_header(AVFormatContext *s)\n<33> av_opt_get(s->pb, "mime_type", AV_OPT_SEARCH_CHILDREN, &mime_type);\n<35> if (mime_type && s->iformat->mime_type) {\n<39> size_t len = strlen(s->iformat->mime_type);\n<41> if (!strncmp(s->iformat->mime_type, mime_type, len)) {\n<45> len = strlen(mime_type);\n<47> while (options < mime_type + len) {\n<49> options = strstr(options, ";");\n<51> if (!options++)\n<55> if (!rate)\n<57> sscanf(options, " rate=%d",     &rate);\n<59> if (!channels)\n<61> sscanf(options, " channels=%d", &channels);\n<65> if (rate <= 0) {\n<78> st->codecpar->sample_rate = rate;\n<80> if (channels > 0)\n<82> st->codecpar->channels = channels;
<1> static bluetooth_uuid_t get_uuid_from_handle ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data ) {\n<7> memset ( & uuid , 0 , sizeof uuid ) ;\n<20> return uuid ;
<1> static void fake_freeaddrinfo ( struct addrinfo * ai ) {\n<2> free ( ai -> ai_addr ) ;
<1> static int xhci_submit(XHCIState *xhci, XHCITransfer *xfer, XHCIEPContext *epctx)\n<9> DPRINTF("xhci_submit(slotid=%d,epid=%d)\n", xfer->slotid, xfer->epid);\n<13> xfer->in_xfer = epctx->type>>2;\n<17> switch(epctx->type) {\n<57> fprintf(stderr, "xhci: unknown or unhandled EP "
<1> static void init_check_host ( void ) {\n<7> i < acl_users . elements ;\n<10> if ( strchr ( acl_user -> host . hostname , wild_many ) || strchr ( acl_user -> host . hostname , wild_one ) || acl_user -> host . ip_mask ) {\n<12> for ( j = 0 ;\n<13> j < acl_wild_hosts . elements ;\n<16> if ( ! my_strcasecmp ( system_charset_info , acl_user -> host . hostname , acl -> hostname ) ) break ;\n<18> if ( j == acl_wild_hosts . elements ) ( void ) push_dynamic ( & acl_wild_hosts , ( uchar * ) & acl_user -> host ) ;\n<20> else if ( ! hash_search ( & acl_check_hosts , ( uchar * ) acl_user -> host . hostname , strlen ( acl_user -> host . hostname ) ) ) {\n<21> if ( my_hash_insert ( & acl_check_hosts , ( uchar * ) acl_user ) ) {
<1> int qcow2_check_refcounts(BlockDriverState *bs)\n<77> for(i = 0; i < s->refcount_table_size; i++) {\n<87> if (offset & (s->cluster_size - 1)) {\n<89> fprintf(stderr, "ERROR refcount block %d is not "\n<105> if (refcount_table[offset / s->cluster_size] != 1) {\n<107> fprintf(stderr, "ERROR refcount block %d refcount=%d\n",\n<121> for(i = 0; i < nb_clusters; i++) {\n<123> refcount1 = get_refcount(bs, i);\n<125> if (refcount1 < 0) {\n<127> fprintf(stderr, "Can't get refcount for cluster %d: %s\n",\n<129> i, strerror(-refcount1));\n<137> if (refcount1 != refcount2) {\n<139> fprintf(stderr, "ERROR cluster %d refcount=%d reference=%d\n",\n<151> qemu_free(refcount_table);
<1> static void test_lc_time_sz ( ) {\n<9> * month ;\n<11> set_if_bigger ( max_month_len , my_numchars_mb ( & my_charset_utf8_general_ci , * month , * month + strlen ( * month ) ) ) ;\n<14> * day ;\n<16> set_if_bigger ( max_day_len , my_numchars_mb ( & my_charset_utf8_general_ci , * day , * day + strlen ( * day ) ) ) ;
<1> static void docmd ( const char * cmdline ) {\n<7> tokenize ( cmdline , tokens , & ntok ) ;\n<9> i = findcmd ( tokens [ 0 ] , builtins , opcmds , & xcmd ) ;\n<10> if ( i == 0 ) {\n<11> ( void ) fprintf ( stderr , "***Command `%s' unknown\n" , tokens [ 0 ] ) ;\n<14> else if ( i >= 2 ) {\n<15> ( void ) fprintf ( stderr , "***Command `%s' ambiguous\n" , tokens [ 0 ] ) ;\n<19> i < ntok ;\n<21> fprintf ( stderr , "***Extra arg `%s' ignored\n" , tokens [ i ] ) ;\n<30> printusage ( xcmd , stderr ) ;\n<42> if ( * ( tokens [ i ] + 1 ) != '\0' ) fname = tokens [ i ] + 1 ;\n<43> else if ( ( i + 1 ) < ntok ) fname = tokens [ i + 1 ] ;\n<45> ( void ) fprintf ( stderr , "***No file for redirect\n" ) ;\n<48> current_output = fopen ( fname , "w" ) ;\n<49> if ( current_output == NULL ) {\n<50> ( void ) fprintf ( stderr , "***Error opening %s: " , fname ) ;
<1> void xmlInitializeGlobalState ( xmlGlobalStatePtr gs ) {\n<45> memset ( & gs -> xmlLastError , 0 , sizeof ( xmlError ) ) ;
<1> static int svq1_encode_plane(SVQ1Context *s, int plane,\n<3> unsigned char *src_plane,\n<9> int width, int height, int src_stride, int stride)\n<25> uint8_t *src     = s->scratchbuf + stride * 16;\n<161> s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly\n<167> for (i = 0; i < 16 && i + 16 * y < height; i++) {\n<169> memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n<173> for (x = width; x < 16 * block_width; x++)\n<175> src[i * stride + x] = src[i * stride + x - 1];\n<179> for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n<181> memcpy(&src[i * stride], &src[(i - 1) * stride],\n<183> 16 * block_width);\n<221> for (i = 0; i < 16 && i + 16 * y < height; i++) {\n<223> memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n<227> for (x = width; x < 16 * block_width; x++)\n<229> src[i * stride + x] = src[i * stride + x - 1];\n<233> for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n<235> memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);\n<301> score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,\n<389> score[1] += encode_block(s, src + 16 * x, temp + 16,\n<399> score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,
<1> static int runPgDump ( const char * dbname ) {\n<10> appendShellString ( cmd , connstrbuf -> data ) ;\n<11> if ( verbose ) fprintf ( stderr , _ ( "%s: running \"%s\"\n" ) , progname , cmd -> data ) ;\n<13> fflush ( stderr ) ;\n<14> ret = system ( cmd -> data ) ;
<1> qemu_irq *armv7m_init(int flash_size, int sram_size,\n<43> if (!env) {\n<45> fprintf(stderr, "Unable to find CPU definition\n");\n<121> image_size = load_elf(kernel_filename, 0, &entry, &lowaddr, NULL,\n<127> image_size = load_image_targphys(kernel_filename, 0, flash_size);\n<133> if (image_size < 0) {\n<135> fprintf(stderr, "qemu: could not load kernel '%s'\n",
<1> int ff_h264_decode_mb_cabac(H264Context *h) {\n<91> fill_decode_neighbors(h, -(MB_FIELD));\n<139> mb_type= decode_cabac_intra_mb_type(h, 32, 0);\n<191> mb_type= decode_cabac_intra_mb_type(h, 17, 0);\n<199> mb_type= decode_cabac_intra_mb_type(h, 3, 1);\n<229> if(IS_INTRA_PCM(mb_type)) {\n<233> const int mb_size = mb_sizes[h->sps.chroma_format_idc]*h->sps.bit_depth_luma >> 3;\n<245> ptr= h->cabac.bytestream;\n<247> if(h->cabac.low&0x1) ptr--;\n<251> if(h->cabac.low&0x1FF) ptr--;\n<261> memcpy(h->mb, ptr, mb_size); ptr+=mb_size;\n<281> memset(h->non_zero_count[mb_xy], 16, 48);
<1> static void free_symbols ( UChar * array [ ] , int32_t arrayLength ) {\n<4> i < arrayLength ;\n<6> free ( array [ i ] ) ;
<1> int tm_adopt ( char * id , int adoptCmd , pid_t pid ) {\n<9> if ( init_done ) return TM_BADINIT ;\n<11> if ( ( tm_jobid = getenv ( "PBS_JOBID" ) ) == NULL ) tm_jobid = ( char * ) "ADOPT JOB" ;\n<12> tm_jobid_len = strlen ( tm_jobid ) ;\n<13> if ( ( tm_jobcookie = getenv ( "PBS_JOBCOOKIE" ) ) == NULL ) tm_jobcookie = ( char * ) "ADOPT COOKIE" ;\n<14> tm_jobcookie_len = strlen ( tm_jobcookie ) ;\n<17> if ( ( env = getenv ( "PBS_MOMPORT" ) ) == NULL || ( tm_momport = atoi ( env ) ) == 0 ) tm_momport = PBS_MANAGER_SERVICE_PORT ;\n<19> if ( startcom ( adoptCmd , TM_NULL_EVENT , & chan ) != DIS_SUCCESS ) return TM_ESYSTEM ;\n<24> if ( diswsi ( chan , pid ) != DIS_SUCCESS ) {\n<28> if ( diswcs ( chan , id , strlen ( id ) ) != DIS_SUCCESS ) {\n<29> rc = TM_ENOTCONNECTED ;\n<32> DIS_tcp_wflush ( chan ) ;\n<33> status = disrsi ( chan , & ret ) ;\n<34> if ( ret != DIS_SUCCESS ) {\n<45> tm_adopt_cleanup : if ( chan != NULL ) DIS_tcp_cleanup ( chan ) ;\n<46> return rc ;
<1> int ff_h264_ref_picture(H264Context *h, H264Picture *dst, H264Picture *src)\n<59> if (src->hwaccel_picture_private) {\n<63> if (!dst->hwaccel_priv_buf)\n<79> memcpy(dst->ref_poc,   src->ref_poc,   sizeof(src->ref_poc));\n<81> memcpy(dst->ref_count, src->ref_count, sizeof(src->ref_count));
<1> static uint get_table_structure ( char * table , char * db , char * table_type , char * ignore_flag ) {\n<9> FILE * sql_file = md_result_file ;\n<16> * ignore_flag = check_if_ignore_table ( table , table_type ) ;\n<20> verbose_msg ( "-- Warning: Unable to use delayed inserts for table '%s' " "because it's of type %s\n" , table , table_type ) ;\n<35> result_table = quote_name ( table , table_buff , 1 ) ;\n<36> opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n<37> if ( opt_order_by_primary ) order_by = primary_key_fields ( result_table ) ;\n<39> if ( ! opt_no_create_info ) {\n<45> if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) DBUG_RETURN ( 0 ) ;\n<48> if ( strcmp ( table_type , "VIEW" ) == 0 ) print_comment ( sql_file , 0 , "\n--\n-- Temporary table structure for view %s\n--\n\n" , fix_for_comment ( result_table ) ) ;\n<49> else print_comment ( sql_file , 0 , "\n--\n-- Table structure for table %s\n--\n\n" , fix_for_comment ( result_table ) ) ;\n<55> field = mysql_fetch_field_direct ( result , 0 ) ;\n<56> if ( strcmp ( field -> name , "View" ) == 0 ) {\n<57> char * scv_buff = NULL ;\n<59> verbose_msg ( "-- It's a view, create dummy table for view\n" ) ;\n<60> if ( ( row = mysql_fetch_row ( result ) ) && ( scv_buff = row [ 1 ] ) ) scv_buff = my_strdup ( scv_buff , MYF ( 0 ) ) ;\n<61> mysql_free_result ( result ) ;\n<62> my_snprintf ( query_buff , sizeof ( query_buff ) , "SHOW FIELDS FROM %s" , result_table ) ;\n<63> if ( switch_character_set_results ( mysql , "binary" ) || mysql_query_with_error_report ( mysql , & result , query_buff ) || switch_character_set_results ( mysql , default_charset ) ) {\n<64> if ( mysql_errno ( mysql ) == ER_VIEW_INVALID ) fprintf ( sql_file , "\n-- failed on view %s: %s\n\n" , result_table , scv_buff ? scv_buff : "" ) ;\n<69> n_cols = mysql_num_rows ( result ) ;\n<70> if ( 0 != n_cols ) {\n<71> if ( n_cols >= 1000 ) fprintf ( stderr , "-- Warning: Creating a stand-in table for view %s may" " fail when replaying the dump file produced because " "of the number of columns exceeding 1000. Exercise " "caution when replaying the produced dump file.\n" , table ) ;\n<88> check_io ( sql_file ) ;\n<90> mysql_free_result ( result ) ;\n<91> if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n<92> seen_views = 1 ;\n<93> DBUG_RETURN ( 0 ) ;\n<96> is_log_table = general_log_or_slow_log_tables ( db , table ) ;\n<110> check_io ( sql_file ) ;\n<113> my_snprintf ( query_buff , sizeof ( query_buff ) , "show fields from %s" , result_table ) ;\n<145> verbose_msg ( "%s: Warning: Can't set SQL_QUOTE_SHOW_CREATE option (%s)\n" , my_progname_short , mysql_error ( mysql ) ) ;\n<153> print_comment ( sql_file , 0 , "\n--\n-- Table structure for table %s\n--\n\n" , fix_for_comment ( result_table ) ) ;\n<158> check_io ( sql_file ) ;\n<165> dynstr_append_checked ( & insert_pat , result_table ) ;\n<172> while ( ( row = mysql_fetch_row ( result ) ) ) {\n<177> check_io ( sql_file ) ;\n<185> print_xml_row ( sql_file , "field" , result , & row , NullS ) ;\n<188> if ( opt_keywords ) fprintf ( sql_file , " %s.%s %s" , result_table , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n<189> else fprintf ( sql_file , " %s %s" , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n<191> fputs ( " DEFAULT " , sql_file ) ;\n<192> unescape ( sql_file , row [ SHOW_DEFAULT ] , lengths [ SHOW_DEFAULT ] ) ;\n<194> if ( ! row [ SHOW_NULL ] [ 0 ] ) fputs ( " NOT NULL" , sql_file ) ;\n<195> if ( row [ SHOW_EXTRA ] [ 0 ] ) fprintf ( sql_file , " %s" , row [ SHOW_EXTRA ] ) ;\n<196> check_io ( sql_file ) ;\n<204> my_snprintf ( buff , sizeof ( buff ) , "show keys from %s" , result_table ) ;\n<205> if ( mysql_query_with_error_report ( mysql , & result , buff ) ) {\n<210> fprintf ( stderr , "%s: Can't get keys for table %s (%s)\n" , my_progname_short , result_table , mysql_error ( mysql ) ) ;\n<211> if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n<228> while ( ( row = mysql_fetch_row ( result ) ) ) {\n<230> print_xml_row ( sql_file , "key" , result , & row , NullS ) ;\n<234> if ( keynr ++ ) putc ( ')' , sql_file ) ;\n<235> if ( atoi ( row [ 1 ] ) ) fprintf ( sql_file , ",\n KEY %s (" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n<236> else if ( keynr == primary_key ) fputs ( ",\n PRIMARY KEY (" , sql_file ) ;\n<237> else fprintf ( sql_file , ",\n UNIQUE %s (" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n<240> fputs ( quote_name ( row [ 4 ] , name_buff , 0 ) , sql_file ) ;\n<241> if ( row [ 7 ] ) fprintf ( sql_file , " (%s)" , row [ 7 ] ) ;\n<242> check_io ( sql_file ) ;\n<255> verbose_msg ( "-- Warning: Couldn't get status information for " "table %s (%s)\n" , result_table , mysql_error ( mysql ) ) ;\n<258> else if ( ! ( row = mysql_fetch_row ( result ) ) ) {\n<259> fprintf ( stderr , "Error: Couldn't read status information for table %s (%s)\n" , result_table , mysql_error ( mysql ) ) ;\n<262> if ( opt_xml ) print_xml_row ( sql_file , "options" , result , & row , NullS ) ;\n<265> print_value ( sql_file , result , row , "engine=" , "Engine" , 0 ) ;\n<266> print_value ( sql_file , result , row , "" , "Create_options" , 0 ) ;\n<267> print_value ( sql_file , result , row , "comment=" , "Comment" , 1 ) ;
<1> static void test_2 ( void ) {\n<10> invalid_labels [ i ] ;\n<12> err = ksba_dn_str2der ( invalid_labels [ i ] , & buf , & len ) ;\n<14> err = ksba_dn_teststr ( invalid_labels [ i ] , 0 , & off , & len ) ;\n<16> printf ( "string ->%s<- error at %lu.%lu (%.*s)\n" , invalid_labels [ i ] , ( unsigned long ) off , ( unsigned long ) len , ( int ) len , invalid_labels [ i ] + off ) ;
<1> static int encode_hq_slice(AVCodecContext *avctx, void *arg)\n<7> VC2EncContext *s = slice_dat->ctx;\n<27> memset(put_bits_ptr(pb), 0, s->prefix_bytes);\n<29> skip_put_bytes(pb, s->prefix_bytes);
<1> static int raw_write_scrubbed_bootsect(BlockDriverState *bs,\n<3> const uint8_t *buf)\n<7> uint8_t bootsect[512];\n<13> memcpy(bootsect, buf, 512);\n<15> memset(bootsect, 0, 4);\n<19> return bdrv_write(bs->file, 0, bootsect, 1);
<1> TSReturnCode TSStringPercentEncode ( const char * str , int str_len , char * dst , size_t dst_size , size_t * length , const unsigned char * map ) {\n<5> if ( str_len < 0 ) {\n<6> str_len = strlen ( str ) ;
<1> static int lzh_decompress ( struct kwajd_stream * lzh ) {\n<10> memset ( & lzh -> window [ 0 ] , LZSS_WINDOW_FILL , ( size_t ) LZSS_WINDOW_SIZE ) ;
<1> static int spapr_populate_drconf_memory(sPAPRMachineState *spapr, void *fdt)\n<141> cur_index += 2;\n<143> for (i = 0; i < nr_nodes; i++) {\n<157> memcpy(cur_index, associativity, sizeof(associativity));\n<159> cur_index += 4;
<1> static void test_bug9520 ( ) {\n<6> int rc , row_count = 0 ;\n<15> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<20> mysql_stmt_bind_result ( stmt , my_bind ) ;\n<21> while ( ! ( rc = mysql_stmt_fetch ( stmt ) ) ) row_count ++ ;\n<23> if ( ! opt_silent ) printf ( "Fetched %d rows\n" , row_count ) ;\n<24> DBUG_ASSERT ( row_count == 3 ) ;
<1> int64_t cpu_get_icount ( void ) {\n<7> if ( ! can_do_io ( env ) ) {\n<8> fprintf ( stderr , "Bad clock read\n" ) ;
<1> static kadm5_ret_t check_pw_reuse ( krb5_context context , krb5_keyblock * hist_keyblocks , int n_new_key_data , krb5_key_data * new_key_data , unsigned int n_pw_hist_data , osa_pw_hist_ent * pw_hist_data ) {\n<11> ret = krb5_dbe_decrypt_key_data ( context , NULL , & ( new_key_data [ x ] ) , & newkey , NULL ) ;\n<23> ret = krb5_dbe_decrypt_key_data ( context , kb , key_data , & histkey , NULL ) ;\n<25> if ( newkey . length == histkey . length && newkey . enctype == histkey . enctype && memcmp ( newkey . contents , histkey . contents , histkey . length ) == 0 ) {\n<26> krb5_free_keyblock_contents ( context , & histkey ) ;\n<27> krb5_free_keyblock_contents ( context , & newkey ) ;\n<30> krb5_free_keyblock_contents ( context , & histkey ) ;\n<34> krb5_free_keyblock_contents ( context , & newkey ) ;
<1> static void select_input_picture(MpegEncContext *s){\n<35> if(s->picture_in_gop_number < s->gop_size && skip_check(s, s->input_picture[0], s->next_picture_ptr)){\n<67> ff_vbv_update(s, 0);\n<125> get_intra_count(s, s->input_picture[i  ]->data[0],\n<155> b_frames= estimate_best_b_count(s);\n<249> if(s->reordered_input_picture[0]){\n<327> memset(&s->new_picture, 0, sizeof(Picture));
<1> static int qcow2_write_snapshots(BlockDriverState *bs)\n<33> for(i = 0; i < s->nb_snapshots; i++) {\n<35> sn = s->snapshots + i;\n<37> offset = align_offset(offset, 8);\n<41> offset += sizeof(extra);\n<43> offset += strlen(sn->id_str);\n<45> offset += strlen(sn->name);\n<49> snapshots_size = offset;\n<71> for(i = 0; i < s->nb_snapshots; i++) {\n<73> sn = s->snapshots + i;\n<75> memset(&h, 0, sizeof(h));\n<101> memset(&extra, 0, sizeof(extra));\n<109> id_str_size = strlen(sn->id_str);\n<111> name_size = strlen(sn->name);\n<113> h.id_str_size = cpu_to_be16(id_str_size);\n<115> h.name_size = cpu_to_be16(name_size);\n<121> ret = bdrv_pwrite(bs->file, offset, &h, sizeof(h));\n<133> ret = bdrv_pwrite(bs->file, offset, &extra, sizeof(extra));\n<145> ret = bdrv_pwrite(bs->file, offset, sn->id_str, id_str_size);\n<157> ret = bdrv_pwrite(bs->file, offset, sn->name, name_size);
<1> ivshmem_server_parse_args(IvshmemServerArgs *args, int argc, char *argv[])\n<35> switch (c) {\n<63> args->pid_file = strdup(optarg);\n<71> args->unix_socket_path = strdup(optarg);\n<79> args->shm_path = strdup(optarg);\n<87> parse_option_size("shm_size", optarg, &args->shm_size, &errp);\n<89> if (errp) {\n<93> error_get_pretty(errp));\n<107> if (parse_uint_full(optarg, &v, 0) < 0) {\n<109> fprintf(stderr, "cannot parse n_vectors\n");\n<133> if (args->n_vectors > IVSHMEM_SERVER_MAX_VECTORS) {\n<135> fprintf(stderr, "too many requested vectors (max is %d)\n",\n<145> if (args->verbose == 1 && args->foreground == 0) {\n<147> fprintf(stderr, "cannot use verbose in daemon mode\n");
<1> static int64_t alloc_block(BlockDriverState* bs, int64_t offset)\n<5> BDRVVPCState *s = bs->opaque;\n<13> uint8_t bitmap[s->bitmap_size];\n<19> if ((offset < 0) || (offset > bs->total_sectors * BDRV_SECTOR_SIZE)) {\n<39> memset(bitmap, 0xff, s->bitmap_size);\n<41> ret = bdrv_pwrite_sync(bs->file, s->free_data_block_offset, bitmap,
<1> static VALUE ossl_asn1cons_to_der ( VALUE self ) {\n<10> if ( inf_length == Qtrue ) {\n<13> if ( rb_obj_class ( self ) == cASN1Sequence || rb_obj_class ( self ) == cASN1Set ) {\n<19> while ( ! found_prim ) {\n<44> p = ( unsigned char * ) RSTRING_PTR ( str ) ;\n<45> if ( tc == V_ASN1_UNIVERSAL ) ASN1_put_object ( & p , constructed , RSTRING_LENINT ( value ) , tn , tc ) ;\n<48> ASN1_put_object ( & p , constructed , seq_len , tn , tc ) ;\n<49> ASN1_put_object ( & p , constructed , RSTRING_LENINT ( value ) , tag , V_ASN1_UNIVERSAL ) ;\n<52> ASN1_put_object ( & p , constructed , RSTRING_LENINT ( value ) , tn , tc ) ;\n<55> memcpy ( p , RSTRING_PTR ( value ) , RSTRING_LEN ( value ) ) ;\n<56> p += RSTRING_LEN ( value ) ;
<1> static int nist_read_header(AVFormatContext *s)\n<5> char buffer[32], coding[32] = "pcm", format[32] = "01";\n<39> while (!url_feof(s->pb)) {\n<41> ff_get_line(s->pb, buffer, sizeof(buffer));\n<45> if (avio_tell(s->pb) >= header_size)\n<51> if (!memcmp(buffer, "end_head", 8)) {\n<53> if (!st->codec->bits_per_coded_sample)\n<59> if (!av_strcasecmp(coding, "pcm")) {\n<83> avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);\n<87> st->codec->block_align = st->codec->bits_per_coded_sample * st->codec->channels / 8;\n<91> if (avio_tell(s->pb) > header_size)\n<103> } else if (!memcmp(buffer, "channel_count", 13)) {\n<107> } else if (!memcmp(buffer, "sample_byte_format", 18)) {\n<109> sscanf(buffer, "%*s %*s %31s", format);\n<113> if (!av_strcasecmp(format, "01")) {\n<117> } else if (!av_strcasecmp(format, "10")) {\n<121> } else if (av_strcasecmp(format, "1")) {\n<129> } else if (!memcmp(buffer, "sample_coding", 13)) {\n<131> sscanf(buffer, "%*s %*s %31s", coding);\n<133> } else if (!memcmp(buffer, "sample_count", 12)) {\n<137> } else if (!memcmp(buffer, "sample_n_bytes", 14)) {\n<141> } else if (!memcmp(buffer, "sample_rate", 11)) {\n<145> } else if (!memcmp(buffer, "sample_sig_bits", 15)) {\n<151> char key[32], value[32];\n<153> if (sscanf(buffer, "%31s %*s %31s", key, value) == 3) {\n<155> av_dict_set(&s->metadata, key, value, AV_DICT_APPEND);\n<159> av_log(s, AV_LOG_ERROR, "Failed to parse '%s' as metadata\n", buffer);
<1> static int usbredir_handle_iso_data(USBRedirDevice *dev, USBPacket *p,\n<49> if (isop == NULL) {\n<83> if (len > p->len) {\n<93> memcpy(p->data, isop->data, len);\n<95> bufp_free(dev, isop, ep);\n<97> return len;
<1> static gpg_err_code_t point_from_keyparam ( gcry_mpi_point_t * r_a , gcry_sexp_t keyparam , const char * name ) {\n<5> ec = mpi_from_keyparam ( & a , keyparam , name ) ;\n<7> if ( a ) {\n<21> tmpname = gcry_malloc ( strlen ( name ) + 2 + 1 ) ;\n<22> if ( ! tmpname ) return gpg_err_code_from_syserror ( ) ;\n<23> strcpy ( stpcpy ( tmpname , name ) , ".x" ) ;
<1> static int tls1_P_hash ( const EVP_MD * md , const unsigned char * sec , int sec_len , const void * seed1 , int seed1_len , const void * seed2 , int seed2_len , const void * seed3 , int seed3_len , const void * seed4 , int seed4_len , const void * seed5 , int seed5_len , unsigned char * out , int olen ) {\n<37> if ( olen > chunk ) {\n<39> out += j ;\n<44> if ( ! EVP_DigestSignFinal ( & ctx , A1 , & A1_len ) ) goto err ;\n<45> memcpy ( out , A1 , olen ) ;
<4> if ( ! ipv6 ) {\n<12> memcpy ( & psaA -> sa6 . sin6_addr , & pres -> u . v6 . addr , sizeof ( psaA -> sa6 . sin6_addr ) ) ;\n<14> memcpy ( & psaM -> sa6 . sin6_addr , & pres -> u . v6 . mask , sizeof ( psaA -> sa6 . sin6_addr ) ) ;
<1> static void opt_output_file(void *optctx, const char *filename)\n<19> if (!strcmp(filename, "-"))\n<21> filename = "pipe:";\n<25> err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);\n<35> file_oformat= oc->oformat;\n<41> if (!strcmp(file_oformat->name, "ffm") &&\n<43> av_strstart(filename, "http:", NULL)) {\n<51> int err = read_ffserver_streams(o, oc, filename);\n<53> if (err < 0) {\n<61> for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) {\n<93> } else if (!o->nb_stream_maps) {\n<515> for (i = 0; i < o->nb_metadata; i++) {\n<527> val = strchr(o->metadata[i].u.str, '=');\n<529> if (!val) {\n<531> av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n",\n<543> parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);\n<545> if (type == 's') {\n<549> if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {\n<551> av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);\n<553> } else if (ret < 0)\n<559> printf("ret %d, stream_spec %s\n", ret, stream_spec);\n<595> av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);
<1> static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,\n<19> if (!pdev->romfile)\n<23> if (strlen(pdev->romfile) == 0)\n<25> return;\n<29> if (!pdev->rom_bar) {\n<51> if (DEVICE(pdev)->hotplugged) {\n<65> rom_add_vga(pdev->romfile);\n<69> rom_add_option(pdev->romfile, -1);\n<79> path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);
<1> int path_is_absolute(const char *path)\n<17> p = strchr(path, ':');\n<21> p++;\n<25> p = path;
<1> static int flic_read_header(AVFormatContext *s)\n<27> if (avio_read(pb, header, FLIC_HEADER_SIZE) != FLIC_HEADER_SIZE)\n<35> speed = AV_RL32(&header[0x10]);\n<47> if (!st)\n<87> st->codec->extradata = av_malloc(FLIC_HEADER_SIZE);\n<89> memcpy(st->codec->extradata, header, FLIC_HEADER_SIZE);\n<171> } else if (AV_RL16(&header[0x10]) == FLIC_CHUNK_MAGIC_1) {\n<185> av_free(st->codec->extradata);\n<189> st->codec->extradata = av_malloc(12);\n<191> memcpy(st->codec->extradata, header, 12);
<1> static int decode_subpacket(COOKContext *q, uint8_t *inbuffer,\n<29> decode_gain_info(&q->gb, &q->gain_current);\n<31> memcpy(&q->gain_copy, &q->gain_current ,sizeof(COOKgain));  //This copy does not seem to be used. FIXME\n<35> if(q->nb_channels==2 && q->joint_stereo==1){\n<37> joint_decode(q, q->decode_buf_ptr[0], q->decode_buf_ptr[2]);\n<71> gain_compensate(q, q->mono_mdct_output, q->gain_now_ptr,\n<105> memcpy(&q->gain_now, &q->gain_previous, sizeof(COOKgain));\n<107> memcpy(&q->gain_previous, &q->gain_current, sizeof(COOKgain));\n<111> } else if (q->nb_channels==2 && q->joint_stereo==0) {\n<115> mono_decode(q, q->decode_buf_ptr[0]);\n<139> gain_compensate(q, q->mono_mdct_output, q->gain_now_ptr,\n<173> decode_gain_info(&q->gb, &q->gain_current);\n<177> mono_decode(q, q->decode_buf_ptr[0]);\n<195> cook_imlt(q, q->decode_buf_ptr[0], q->mono_mdct_output,q->mlt_tmp);\n<197> gain_compensate(q, q->mono_mdct_output, q->gain_now_ptr, q->gain_previous_ptr, q->previous_buffer_ptr[0]);\n<229> memcpy(&q->gain_now, &q->gain_previous, sizeof(COOKgain));\n<231> memcpy(&q->gain_previous, &q->gain_current, sizeof(COOKgain));\n<237> mono_decode(q, q->decode_buf_ptr[0]);\n<263> gain_compensate(q, q->mono_mdct_output, q->gain_now_ptr,\n<283> memcpy(&q->gain_now, &q->gain_previous, sizeof(COOKgain));\n<285> memcpy(&q->gain_previous, &q->gain_current, sizeof(COOKgain));
<259> switch (ret) {\n<281> error_report("Error resizing image: %s", strerror(-ret));
<1> static unsigned __stdcall win32_start_routine(void *arg)\n<11> free(arg);
<1> int main ( int argc , char * * argv ) {\n<2> int frame_cnt = 0 ;\n<16> if ( ! ( outfile = fopen ( argv [ 2 ] , "wb" ) ) ) die ( "Failed to open %s for writing." , argv [ 2 ] ) ;\n<21> info = vpx_video_reader_get_info ( reader ) ;\n<24> printf ( "Using %s\n" , vpx_codec_iface_name ( decoder -> codec_interface ( ) ) ) ;\n<33> ++ frame_cnt ;\n<34> skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ;\n<44> printf ( "Processed %d frames.\n" , frame_cnt ) ;\n<46> printf ( "Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\n" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ;
<1> static socket_handle_t adb_connect ( const char * server_ip , unsigned short * server_tcp_port ) {\n<8> memset ( & server , 0x0 , sizeof ( server ) ) ;\n<12> if ( ( sock = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ) == INVALID_SOCKET ) {\n<13> errmsg_print ( "ERROR: Cannot open system TCP socket: %s" , strerror ( errno ) ) ;\n<18> status = connect ( sock , ( struct sockaddr * ) & server , ( socklen_t ) sizeof ( server ) ) ;\n<32> if ( connect ( sock , ( struct sockaddr * ) & server , sizeof ( server ) ) == SOCKET_ERROR ) {\n<33> errmsg_print ( "ERROR: Cannot connect to ADB: <%s> Please check that adb daemon is running." , strerror ( errno ) ) ;\n<43> if ( getsockname ( sock , ( struct sockaddr * ) & client , & length ) ) {\n<44> errmsg_print ( "ERROR getsockname: %s" , strerror ( errno ) ) ;
<1> int qemuMonitorTextScreendump ( qemuMonitorPtr mon , const char * file ) {\n<3> char * reply = NULL ;\n<9> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<13> if ( strstr ( reply , "unknown command:" ) ) {\n<14> ret = - 2 ;\n<17> ret = 0 ;\n<18> cleanup : VIR_FREE ( reply ) ;
<1> static void destroy_attr_val_fifo ( attr_val_fifo * av_fifo ) {\n<3> if ( av_fifo != NULL ) {\n<5> UNLINK_FIFO ( av , * av_fifo , link ) ;\n<6> if ( av != NULL ) {\n<7> if ( T_String == av -> type ) free ( av -> value . s ) ;\n<8> free ( av ) ;\n<11> while ( av != NULL ) ;\n<12> free ( av_fifo ) ;
<1> static int pfkey_send_acquire ( struct xfrm_state * x , struct xfrm_tmpl * t , struct xfrm_policy * xp ) {\n<16> if ( ( xfrm_ctx = x -> security ) ) {\n<17> ctx_size = PFKEY_ALIGN8 ( xfrm_ctx -> ctx_len ) ;\n<53> if ( xfrm_ctx ) {\n<54> sec_ctx = ( struct sadb_x_sec_ctx * ) skb_put ( skb , sizeof ( struct sadb_x_sec_ctx ) + ctx_size ) ;\n<55> sec_ctx -> sadb_x_sec_len = ( sizeof ( struct sadb_x_sec_ctx ) + ctx_size ) / sizeof ( uint64_t ) ;\n<56> sec_ctx -> sadb_x_sec_exttype = SADB_X_EXT_SEC_CTX ;\n<57> sec_ctx -> sadb_x_ctx_doi = xfrm_ctx -> ctx_doi ;\n<58> sec_ctx -> sadb_x_ctx_alg = xfrm_ctx -> ctx_alg ;\n<59> sec_ctx -> sadb_x_ctx_len = xfrm_ctx -> ctx_len ;\n<60> memcpy ( sec_ctx + 1 , xfrm_ctx -> ctx_str , xfrm_ctx -> ctx_len ) ;
<1> static void _slurm_rpc_composite_msg ( slurm_msg_t * msg ) {\n<12> memset ( & comp_resp_msg , 0 , sizeof ( composite_msg_t ) ) ;\n<16> if ( config_update != slurmctld_conf . last_update ) {\n<17> char * sched_params = slurm_get_sched_params ( ) ;\n<20> defer_sched = ( sched_params && strstr ( sched_params , "defer" ) ) ;\n<22> if ( sched_params && ( tmp_ptr = strstr ( sched_params , "max_sched_time=" ) ) ) {\n<23> sched_timeout = atoi ( tmp_ptr + 15 ) ;\n<24> if ( ( sched_timeout <= 0 ) || ( sched_timeout > time_limit ) ) {\n<34> xfree ( sched_params ) ;\n<40> _slurm_rpc_comp_msg_list ( comp_msg , & run_scheduler , comp_resp_msg . msg_list , & start_tv , sched_timeout ) ;\n<43> if ( list_count ( comp_resp_msg . msg_list ) ) {\n<48> memcpy ( & resp_msg . address , & comp_msg -> sender , sizeof ( slurm_addr_t ) ) ;\n<50> resp_msg . data = & comp_resp_msg ;\n<53> FREE_NULL_LIST ( comp_resp_msg . msg_list ) ;\n<55> if ( ! LOTS_OF_AGENTS && ! defer_sched ) ( void ) schedule ( 0 ) ;
<1> static void test_double_compare ( ) {\n<23> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<36> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static void write_target_close(BlockDriverState *bs) {\n<3> BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n<7> free(s->qcow_filename);
<1> static int vhost_user_call(struct vhost_dev *dev, unsigned long int request,\n<3> void *arg)\n<29> msg.request = msg_request;\n<31> msg.flags = VHOST_USER_VERSION;\n<33> msg.size = 0;\n<37> switch (request) {\n<51> msg.u64 = *((__u64 *) arg);\n<53> msg.size = sizeof(m.u64);\n<121> msg.size += fd_num * sizeof(VhostUserMemoryRegion);\n<141> memcpy(&msg.state, arg, sizeof(struct vhost_vring_state));\n<143> msg.size = sizeof(m.state);\n<151> memcpy(&msg.state, arg, sizeof(struct vhost_vring_state));\n<153> msg.size = sizeof(m.state);\n<163> memcpy(&msg.addr, arg, sizeof(struct vhost_vring_addr));\n<165> msg.size = sizeof(m.addr);\n<179> msg.u64 = file->index & VHOST_USER_VRING_IDX_MASK;\n<181> msg.size = sizeof(m.u64);\n<189> msg.u64 |= VHOST_USER_VRING_NOFD_MASK;\n<207> if (vhost_user_write(dev, &msg, fds, fd_num) < 0) {\n<249> *((__u64 *) arg) = msg.u64;\n<255> if (msg.size != sizeof(m.state)) {\n<263> memcpy(arg, &msg.state, sizeof(struct vhost_vring_state));
<1> void ff_clean_intra_table_entries ( MpegEncContext * s ) {\n<5> memset ( s -> ac_val [ 0 ] [ xy ] , 0 , 32 * sizeof ( int16_t ) ) ;\n<6> memset ( s -> ac_val [ 0 ] [ xy + wrap ] , 0 , 32 * sizeof ( int16_t ) ) ;\n<13> memset ( s -> ac_val [ 1 ] [ xy ] , 0 , 16 * sizeof ( int16_t ) ) ;\n<14> memset ( s -> ac_val [ 2 ] [ xy ] , 0 , 16 * sizeof ( int16_t ) ) ;
<1> int ff_h264_slice_context_init(H264Context *h, H264SliceContext *sl)\n<5> ERContext *er = &sl->er;\n<33> if (sl != h->slice_ctx) {\n<35> memset(er, 0, sizeof(*er));
<1> static inline int coupling_strategy(AC3DecodeContext *s, int blk,\n<3> uint8_t *bit_alloc_stages)\n<17> memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);
<1> static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) {\n<4> memset ( & roi , 0 , sizeof ( roi ) ) ;\n<19> roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ;\n<21> i < roi . rows * roi . cols ;\n<22> ++ i ) roi . roi_map [ i ] = i % 4 ;\n<23> if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , "Failed to set ROI map" ) ;\n<24> free ( roi . roi_map ) ;
<1> struct pxa2xx_lcdc_s *pxa2xx_lcdc_init(target_phys_addr_t base, qemu_irq irq,\n<43> switch (s->ds->depth) {\n<103> fprintf(stderr, "%s: Bad color depth\n", __FUNCTION__);
<1> static int count_lines ( const char * fn ) {\n<3> char * line = NULL ;\n<7> if ( ! f ) return - 1 ;\n<8> while ( getline ( & line , & sz , f ) != - 1 ) {\n<11> free ( line ) ;
<1> static void vnc_dpy_copy(DisplayChangeListener *dcl,\n<65> src_row += pitch * (h-1);\n<67> dst_row += pitch * (h-1);\n<112> cmp_bytes = s * VNC_SERVER_FB_BYTES;\n<114> if (memcmp(src_row, dst_row, cmp_bytes) == 0)\n<118> memmove(dst_row, src_row, cmp_bytes);\n<131> src_row += pitch - w * VNC_SERVER_FB_BYTES;\n<133> dst_row += pitch - w * VNC_SERVER_FB_BYTES;
<1> static int usb_net_handle_data(USBDevice *dev, USBPacket *p)\n<19> ret = usb_net_handle_statusin(s, p);\n<27> ret = usb_net_handle_datain(s, p);\n<49> ret = usb_net_handle_dataout(s, p);\n<75> if (ret == USB_RET_STALL)\n<77> fprintf(stderr, "usbnet: failed data transaction: "
<1> void del_event ( event_info * ep ) {\n<2> if ( ep -> e_prev ) ep -> e_prev -> e_next = ep -> e_next ;\n<3> else event_hash [ ep -> e_event % EVENT_HASH ] = ep -> e_next ;\n<5> switch ( ep -> e_mtype ) {\n<7> case TM_TASKS : case TM_GETINFO : case TM_RESOURCES : free ( ep -> e_info ) ;\n<9> default : TM_DBPRT ( ( "del_event: unknown event command %d\n" , ep -> e_mtype ) ) break ;\n<11> free ( ep ) ;
<1> void remoteDispatchFormatError ( remote_error * rerr , const char * fmt , ... ) {\n<5> va_start ( args , fmt ) ;\n<6> vsnprintf ( msgbuf , sizeof msgbuf , fmt , args ) ;\n<7> va_end ( args ) ;
<1> static void test_qemu_strtoul_max(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoul(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> static void dump_marks ( void ) {\n<5> if ( hold_lock_file_for_update ( & mark_lock , export_marks_file , 0 ) < 0 ) {\n<6> failure |= error ( "Unable to write marks file %s: %s" , export_marks_file , strerror ( errno ) ) ;\n<10> if ( ! f ) {\n<11> int saved_errno = errno ;\n<13> failure |= error ( "Unable to write marks file %s: %s" , export_marks_file , strerror ( saved_errno ) ) ;\n<17> if ( commit_lock_file ( & mark_lock ) ) {\n<18> failure |= error ( "Unable to commit marks file %s: %s" , export_marks_file , strerror ( errno ) ) ;
<1> extern List as_mysql_get_resvs ( mysql_conn_t * mysql_conn , uid_t uid , slurmdb_reservation_cond_t * resv_cond ) {\n<29> if ( private_data & PRIVATE_DATA_RESERVATIONS ) {\n<30> if ( ! ( is_admin = is_user_min_admin_level ( mysql_conn , uid , SLURMDB_ADMIN_OPERATOR ) ) ) {\n<36> memset ( & job_cond , 0 , sizeof ( slurmdb_job_cond_t ) ) ;\n<42> local_cluster_list = setup_cluster_list_with_inx ( mysql_conn , & job_cond , ( void * * ) & curr_cluster ) ;\n<85> if ( ! job_cond . resvid_list ) job_cond . resvid_list = list_create ( NULL ) ;\n<86> list_append ( job_cond . resvid_list , row [ RESV_REQ_ID ] ) ;\n<99> List job_list = as_mysql_jobacct_process_get_jobs ( mysql_conn , uid , & job_cond ) ;\n<128> FREE_NULL_LIST ( job_cond . resvid_list ) ;
<1> static void isofile_free ( struct isofile * file ) {\n<4> while ( con != NULL ) {\n<5> tmp = con ;\n<7> free ( tmp ) ;\n<9> archive_entry_free ( file -> entry ) ;\n<14> free ( file ) ;
<1> static void usbredir_interrupt_packet(void *priv, uint32_t id,\n<5> uint8_t *data, int data_len)\n<21> if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n<25> free(data);\n<35> if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n<39> free(data);
<1> static void virtio_balloon_set_config(VirtIODevice *vdev,\n<3> const uint8_t *config_data)\n<13> memcpy(&config, config_data, 8);
<1> static void test_bug5399 ( ) {\n<9> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;
<1> static ssize_t stellaris_enet_receive(NetClientState *nc, const uint8_t *buf, size_t size)\n<19> if (s->np >= 31) {\n<27> DPRINTF("Received packet len=%zu\n", size);\n<45> *(p++) = (size + 6) >> 8;\n<47> memcpy (p, buf, size);\n<49> p += size;\n<51> crc = crc32(~0, buf, size);\n<59> *(p++) = crc >> 24;\n<63> if ((size & 3) != 2) {\n<65> memset(p, 0, (6 - size) & 3);
<1> static void ipmi_init_sensors_from_sdrs(IPMIBmcSim *s)\n<11> for (i = 0; i < MAX_SENSORS; i++) {\n<13> memset(s->sensors + i, 0, sizeof(*sens));
<1> static ssize_t rtl8139_do_receive(VLANClientState *nc, const uint8_t *buf, size_t size_, int do_interrupt)\n<19> uint8_t buf1[MIN_BUF_SIZE + VLAN_HLEN];\n<63> if (s->RxConfig & AcceptAllPhys) {\n<73> if (!memcmp(buf,  broadcast_macaddr, 6)) {\n<77> if (!(s->RxConfig & AcceptBroadcast))\n<111> } else if (buf[0] & 0x01) {\n<135> int mcast_idx = compute_mcast_idx(buf);\n<173> } else if (s->phys[0] == buf[0] &&\n<175> s->phys[1] == buf[1] &&\n<177> s->phys[2] == buf[2] &&\n<179> s->phys[3] == buf[3] &&\n<181> s->phys[4] == buf[4] &&\n<183> s->phys[5] == buf[5]) {\n<247> if (size < MIN_BUF_SIZE + VLAN_HLEN) {\n<249> memcpy(buf1, buf, size);\n<251> memset(buf1 + size, 0, MIN_BUF_SIZE + VLAN_HLEN - size);\n<253> buf = buf1;\n<391> dot1q_buf = &buf[ETHER_ADDR_LEN * 2];\n<475> cpu_physical_memory_write(rx_addr, buf, 2 * ETHER_ADDR_LEN);\n<477> cpu_physical_memory_write(rx_addr + 2 * ETHER_ADDR_LEN,\n<479> buf + 2 * ETHER_ADDR_LEN + VLAN_HLEN,\n<485> cpu_physical_memory_write(rx_addr, buf, size);\n<503> val = cpu_to_le32(crc32(0, buf, size_));\n<695> rtl8139_write_buffer(s, buf, size);
<1> int read_ndx_and_attrs ( int f_in , int f_out , int * iflag_ptr , uchar * type_ptr , char * buf , int * len_ptr ) {\n<61> if ( sanitize_paths ) {\n<62> sanitize_path ( buf , buf , "" , 0 , SP_DEFAULT ) ;\n<63> len = strlen ( buf ) ;\n<70> * len_ptr = len ;
<1> int rfc2231_parse ( struct rfc822_parser_context * ctx , const char * const * * result_r ) {\n<14> while ( ( ret = rfc822_parse_content_param ( ctx , & key , & value ) ) != 0 ) {\n<15> if ( ret < 0 ) {\n<21> p = strchr ( key , '*' ) ;\n<22> if ( p != NULL ) {\n<40> rfc2231_param . key = t_strdup_until ( key , p2 ) ;\n<46> array_append ( & result , & key , 1 ) ;
<1> static int usb_host_scan(void *opaque, USBScanFunc *func)\n<17> char devpath[PATH_MAX];\n<31> strcpy(devpath, USBPROCBUS_PATH);\n<49> strcpy(devpath, USBDEVBUS_PATH);\n<65> strcpy(devpath, USBDEVBUS_PATH);\n<75> if (!usb_fs_type) {\n<87> usb_host_device_path = qemu_mallocz(strlen(devpath)+1);\n<91> strcpy(usb_host_device_path, devpath);
<1> static int file_compare_by_parent_uri ( NautilusFile * file_a , NautilusFile * file_b ) {\n<4> parent_uri_a = nautilus_file_get_parent_uri ( file_a ) ;\n<5> parent_uri_b = nautilus_file_get_parent_uri ( file_b ) ;\n<6> ret = strcmp ( parent_uri_a , parent_uri_b ) ;\n<7> g_free ( parent_uri_a ) ;\n<8> g_free ( parent_uri_b ) ;\n<9> return ret ;
<1> static void mmap_release_buffer(AVPacket *pkt)\n<6> memset(&buf, 0, sizeof(struct v4l2_buffer));\n<12> res = ioctl (fd, VIDIOC_QBUF, &buf);
<1> static int get_options ( int argc , char * * argv ) {\n<5> tmp = ( char * ) getenv ( "MYSQL_HOST" ) ;\n<6> if ( tmp ) current_host = my_strdup ( tmp , MYF ( MY_WME ) ) ;\n<7> pagpoint = getenv ( "PAGER" ) ;\n<8> if ( ! ( ( char * ) ( pagpoint ) ) ) {\n<12> else strmov ( pager , pagpoint ) ;
<1> static void * nbd_client_thread ( void * arg ) {\n<32> pthread_create ( & show_parts_thread , NULL , show_parts , device ) ;\n<33> if ( verbose ) {\n<34> fprintf ( stderr , "NBD device %s is now connected to %s\n" , device , srcpath ) ;
<1> static void handle_new_lock_ctx ( struct xml_ctx * ctx , int tag_closed ) {\n<2> struct remote_lock * lock = ( struct remote_lock * ) ctx -> userData ;\n<5> if ( tag_closed && ctx -> cdata ) {\n<6> if ( ! strcmp ( ctx -> name , DAV_ACTIVELOCK_OWNER ) ) {\n<7> lock -> owner = xstrdup ( ctx -> cdata ) ;\n<9> else if ( ! strcmp ( ctx -> name , DAV_ACTIVELOCK_TIMEOUT ) ) {\n<11> if ( skip_prefix ( ctx -> cdata , "Second-" , & arg ) ) lock -> timeout = strtol ( arg , NULL , 10 ) ;\n<13> else if ( ! strcmp ( ctx -> name , DAV_ACTIVELOCK_TOKEN ) ) {\n<14> lock -> token = xstrdup ( ctx -> cdata ) ;\n<15> git_SHA1_Init ( & sha_ctx ) ;\n<16> git_SHA1_Update ( & sha_ctx , lock -> token , strlen ( lock -> token ) ) ;\n<17> git_SHA1_Final ( lock_token_sha1 , & sha_ctx ) ;\n<18> lock -> tmpfile_suffix [ 0 ] = '_' ;\n<19> memcpy ( lock -> tmpfile_suffix + 1 , sha1_to_hex ( lock_token_sha1 ) , 40 ) ;
<1> static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n<17> for (y = 0; y < height; y++)\n<19> memset(t1->data[y], 0, width * sizeof(**t1->data));\n<31> for (y = 0; y < height+2; y++)\n<33> memset(t1->flags[y], 0, (width + 2)*sizeof(**t1->flags));
<1> static struct cgroup_meta_data * lxc_cgroup_put_meta ( struct cgroup_meta_data * meta_data ) {\n<3> if ( ! meta_data ) return NULL ;\n<4> if ( -- meta_data -> ref > 0 ) return meta_data ;\n<8> i <= meta_data -> maximum_hierarchy ;\n<9> i ++ ) lxc_cgroup_hierarchy_free ( meta_data -> hierarchies [ i ] ) ;\n<11> free ( meta_data -> hierarchies ) ;\n<12> free ( meta_data ) ;
<1> VirtIODevice *virtio_9p_init(DeviceState *dev, V9fsConf *conf)\n<17> s = (V9fsState *)virtio_common_init("virtio-9p",\n<45> fse = get_fsdev_fsentry(conf->fsdev_id);\n<49> if (!fse) {\n<53> fprintf(stderr, "Virtio-9p device couldn't find fsdev "\n<63> if (!fse->path || !conf->tag) {\n<79> if (!strcmp(fse->security_model, "passthrough")) {\n<83> s->ctx.fs_sm = SM_PASSTHROUGH;\n<85> } else if (!strcmp(fse->security_model, "mapped")) {\n<93> s->ctx.fs_sm = SM_MAPPED;\n<99> fprintf(stderr, "one of the following must be specified as the"\n<105> return NULL;\n<111> if (lstat(fse->path, &stat)) {\n<113> fprintf(stderr, "share path %s does not exist\n", fse->path);\n<117> } else if (!S_ISDIR(stat.st_mode)) {\n<119> fprintf(stderr, "share path %s is not a directory \n", fse->path);\n<127> s->ctx.fs_root = qemu_strdup(fse->path);\n<129> len = strlen(conf->tag);\n<131> if (len > MAX_TAG_LEN) {\n<139> s->tag = qemu_malloc(len);\n<141> memcpy(s->tag, conf->tag, len);\n<143> s->tag_len = len;\n<145> s->ctx.uid = -1;\n<149> s->ops = fse->ops;\n<151> s->vdev.get_features = virtio_9p_get_features;\n<153> s->config_size = sizeof(struct virtio_9p_config) +\n<155> s->tag_len;\n<157> s->vdev.get_config = virtio_9p_get_config;\n<161> return &s->vdev;
<1> int wifi_key_prepare ( char * key_string ) {\n<5> if ( key_string == NULL ) return - E_INVALID ;\n<6> ks = strdup ( key_string ) ;\n<7> if ( ( p = strchr ( ks , ':' ) ) != NULL ) * p = 0 ;\n<8> if ( ! strcasecmp ( ks , "wep" ) ) {\n<10> status = set_wep_key ( p + 1 ) ;\n<14> status = set_wpa_key ( p + 1 ) ;
<1> void SSL3_RECORD_set_seq_num ( SSL3_RECORD * r , const unsigned char * seq_num ) {\n<2> memcpy ( r -> seq_num , seq_num , SEQ_NUM_SIZE ) ;
<1> static void send_version_response ( int fd , version_ack_t ack , uint32_t payload , int userid , struct query * q ) {\n<3> switch ( ack ) {\n<4> case VERSION_ACK : strncpy ( out , "VACK" , sizeof ( out ) ) ;\n<6> case VERSION_NACK : strncpy ( out , "VNAK" , sizeof ( out ) ) ;\n<8> case VERSION_FULL : strncpy ( out , "VFUL" , sizeof ( out ) ) ;
<1> static void writer_print_data_hash ( WriterContext * wctx , const char * name , uint8_t * data , int size ) {\n<5> if ( ! hash ) return ;\n<8> snprintf ( buf , sizeof ( buf ) , "%s:" , av_hash_get_name ( hash ) ) ;\n<9> p = buf + strlen ( buf ) ;\n<10> av_hash_final_hex ( hash , p , buf + sizeof ( buf ) - p ) ;
<1> uint get_errcode_from_name ( const char * error_name , const char * error_end , st_error * e ) {\n<6> e ++ ) {\n<7> if ( ! strncmp ( error_name , e -> name , ( int ) ( error_end - error_name ) ) && ( uint ) strlen ( e -> name ) == ( uint ) ( error_end - error_name ) ) {
<1> static void ps2_common_post_load ( PS2State * s ) {\n<2> PS2Queue * q = & s -> queue ;\n<4> uint8_t tmp_data [ PS2_QUEUE_SIZE ] ;\n<7> i < size ;\n<12> tmp_data [ i ] = q -> data [ q -> rptr ++ ] ;\n<14> memcpy ( q -> data , tmp_data , size ) ;\n<16> q -> wptr = size ;\n<17> q -> count = size ;
<1> static void find_deltas ( struct object_entry * * list , unsigned * list_size , int window , int depth , unsigned * processed ) {\n<5> array = xcalloc ( window , sizeof ( struct unpacked ) ) ;\n<66> array [ dst ] = swap ;\n<73> i < window ;\n<76> free ( array [ i ] . data ) ;\n<78> free ( array ) ;
<1> static void add_error ( Scanner * s , char * error ) {\n<3> s -> errors -> error_messages = realloc ( s -> errors -> error_messages , s -> errors -> error_count * sizeof ( timelib_error_message ) ) ;\n<6> s -> errors -> error_messages [ s -> errors -> error_count - 1 ] . message = strdup ( error ) ;
<1> void * jas_malloc ( size_t size ) {\n<3> JAS_DBGLOG ( 101 , ( "jas_malloc(%zu)\n" , size ) ) ;\n<4> result = malloc ( size ) ;\n<5> JAS_DBGLOG ( 100 , ( "jas_malloc(%zu) -> %p\n" , size , result ) ) ;
<1> static void sun4uv_init(ram_addr_t RAM_size,\n<111> if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n<113> fprintf(stderr, "qemu: too many IDE bus\n");
<43> static void default_print_section_header ( WriterContext * wctx ) {\n<54> if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( "[%s]\n" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;
<1> static int decode_update_thread_context(AVCodecContext *dst, const AVCodecContext *src){\n<3> H264Context *h= dst->priv_data, *h1= src->priv_data;\n<25> if(!inited){\n<39> memcpy(&h->s + 1, &h1->s + 1, sizeof(H264Context) - sizeof(MpegEncContext)); //copy all fields after MpegEnc\n<41> memset(h->sps_buffers, 0, sizeof(h->sps_buffers));\n<43> memset(h->pps_buffers, 0, sizeof(h->pps_buffers));\n<45> ff_h264_alloc_tables(h);\n<47> context_init(h);\n<61> h->thread_context[0] = h;\n<73> s->dsp.clear_blocks(h->mb);\n<87> copy_parameter_set((void**)h->sps_buffers, (void**)h1->sps_buffers, MAX_SPS_COUNT, sizeof(SPS));\n<91> copy_parameter_set((void**)h->pps_buffers, (void**)h1->pps_buffers, MAX_PPS_COUNT, sizeof(PPS));\n<101> copy_fields(h, h1, dequant4_buffer, dequant4_coeff);\n<123> copy_fields(h, h1, poc_lsb, redundant_pic_count);\n<129> copy_fields(h, h1, ref_count, intra_gb);\n<131> copy_fields(h, h1, short_ref, cabac_init_idc);\n<153> ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
<1> static int qemu_chr_open_udp(QemuOpts *opts, CharDriverState **_chr)\n<23> if (fd < 0) {\n<25> fprintf(stderr, "inet_dgram_opts failed\n");
<1> static void wiener_denoise ( WMAVoiceContext * s , int fcb_type , float * synth_pf , int size , const float * lpcs ) {\n<3> if ( fcb_type != FCB_TYPE_SILENCE ) {\n<4> float * tilted_lpcs = s -> tilted_lpcs_pf , * coeffs = s -> denoise_coeffs_pf , tilt_mem = 0 ;\n<6> memcpy ( & tilted_lpcs [ 1 ] , lpcs , sizeof ( lpcs [ 0 ] ) * s -> lsps ) ;\n<7> memset ( & tilted_lpcs [ s -> lsps + 1 ] , 0 , sizeof ( tilted_lpcs [ 0 ] ) * ( 128 - s -> lsps - 1 ) ) ;\n<8> ff_tilt_compensation ( & tilt_mem , 0.7 * tilt_factor ( lpcs , s -> lsps ) , tilted_lpcs , s -> lsps + 2 ) ;\n<10> calc_input_response ( s , tilted_lpcs , fcb_type , coeffs , remainder ) ;\n<11> memset ( & synth_pf [ size ] , 0 , sizeof ( synth_pf [ 0 ] ) * ( 128 - size ) ) ;\n<23> s -> irdft . rdft_calc ( & s -> irdft , synth_pf ) ;\n<25> if ( s -> denoise_filter_cache_size ) {\n<31> memmove ( s -> denoise_filter_cache , & s -> denoise_filter_cache [ size ] , sizeof ( s -> denoise_filter_cache [ 0 ] ) * s -> denoise_filter_cache_size ) ;\n<38> if ( lim < remainder ) {\n<39> memcpy ( & s -> denoise_filter_cache [ lim ] , & synth_pf [ size + lim ] , sizeof ( s -> denoise_filter_cache [ 0 ] ) * ( remainder - lim ) ) ;
<1> int xmlHashRemoveEntry3 ( xmlHashTablePtr table , const xmlChar * name , const xmlChar * name2 , const xmlChar * name3 , xmlHashDeallocator f ) {\n<7> if ( table -> table [ key ] . valid == 0 ) {\n<12> entry != NULL ;\n<14> if ( xmlStrEqual ( entry -> name , name ) && xmlStrEqual ( entry -> name2 , name2 ) && xmlStrEqual ( entry -> name3 , name3 ) ) {\n<15> if ( ( f != NULL ) && ( entry -> payload != NULL ) ) f ( entry -> payload , entry -> name ) ;\n<16> entry -> payload = NULL ;\n<18> if ( entry -> name ) xmlFree ( entry -> name ) ;\n<19> if ( entry -> name2 ) xmlFree ( entry -> name2 ) ;\n<20> if ( entry -> name3 ) xmlFree ( entry -> name3 ) ;\n<27> if ( entry -> next == NULL ) {\n<31> entry = entry -> next ;\n<32> memcpy ( & ( table -> table [ key ] ) , entry , sizeof ( xmlHashEntry ) ) ;\n<33> xmlFree ( entry ) ;
<1> static int tunnel_bind ( int bind_fd , int dns_fd ) {\n<8> fromlen = sizeof ( struct sockaddr ) ;\n<9> r = recvfrom ( bind_fd , packet , sizeof ( packet ) , 0 , ( struct sockaddr * ) & from , & fromlen ) ;\n<10> if ( r <= 0 ) return 0 ;\n<11> id = dns_get_id ( packet , r ) ;\n<12> if ( debug >= 2 ) {\n<13> fprintf ( stderr , "RX: Got response on query %u from DNS\n" , ( id & 0xFFFF ) ) ;\n<17> if ( debug >= 2 ) {\n<18> fprintf ( stderr , "Lost sender of id %u, dropping reply\n" , ( id & 0xFFFF ) ) ;\n<22> if ( debug >= 2 ) {\n<23> fprintf ( stderr , "TX: client %s id %u, %d bytes\n" , format_addr ( & query -> addr , query -> addrlen ) , ( id & 0xffff ) , r ) ;\n<25> if ( sendto ( dns_fd , packet , r , 0 , ( const struct sockaddr * ) & ( query -> addr ) , query -> addrlen ) <= 0 ) {
<1> static void copy_frame_default ( AVFrame * f , const uint8_t * src , int src_stride , int linelen , int height ) {\n<4> dst += ( height - 1 ) * f -> linesize [ 0 ] ;\n<6> i ;\n<8> memcpy ( dst , src , linelen ) ;\n<9> src += src_stride ;\n<10> dst -= f -> linesize [ 0 ] ;
<1> static void process_event(JSONMessageParser *parser, QList *tokens)\n<85> if (ret < 0) {\n<87> g_warning("error sending error response: %s", strerror(-ret));
<1> static void cleanup_preferred_base ( void ) {\n<6> while ( it ) {\n<7> struct pbase_tree * this = it ;\n<9> free ( this -> pcache . tree_data ) ;\n<10> free ( this ) ;\n<13> i < ARRAY_SIZE ( pbase_tree_cache ) ;\n<15> if ( ! pbase_tree_cache [ i ] ) continue ;\n<16> free ( pbase_tree_cache [ i ] -> tree_data ) ;\n<17> free ( pbase_tree_cache [ i ] ) ;\n<20> free ( done_pbase_paths ) ;
<1> static int get_cod(J2kDecoderContext *s, J2kCodingStyle *c, uint8_t *properties)\n<19> tmp.log2_prec_height = 15;\n<23> tmp.csty = bytestream_get_byte(&s->buf);\n<37> tmp.nlayers = bytestream_get_be16(&s->buf);\n<39> tmp.mct = bytestream_get_byte(&s->buf); // multiple component transformation\n<43> get_cox(s, &tmp);\n<45> for (compno = 0; compno < s->ncomponents; compno++){\n<47> if (!(properties[compno] & HAD_COC))\n<49> memcpy(c + compno, &tmp, sizeof(J2kCodingStyle));
<1> static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n<67> if (!region)\n<73> if (!region->dirty)\n<111> clut_table = clut->clut4;\n<117> clut_table = clut->clut256;\n<125> clut_table = clut->clut16;\n<133> rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n<135> memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n<139> rect->pict.data[0] = av_malloc(region->buf_size);\n<141> memcpy(rect->pict.data[0], region->pbuf, region->buf_size);
<1> static gpgme_error_t gpgsm_passwd ( void * engine , gpgme_key_t key , unsigned int flags ) {\n<5> if ( ! key || ! key -> subkeys || ! key -> subkeys -> fpr ) return gpg_error ( GPG_ERR_INV_CERT_OBJ ) ;\n<6> if ( asprintf ( & line , "PASSWD -- %s" , key -> subkeys -> fpr ) < 0 ) return gpg_error_from_syserror ( ) ;\n<7> gpgsm_clear_fd ( gpgsm , OUTPUT_FD ) ;\n<8> gpgsm_clear_fd ( gpgsm , INPUT_FD ) ;\n<9> gpgsm_clear_fd ( gpgsm , MESSAGE_FD ) ;\n<10> gpgsm -> inline_data = NULL ;\n<11> err = start ( gpgsm , line ) ;\n<12> free ( line ) ;\n<13> return err ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<2> VBDecContext * const c = avctx -> priv_data ;\n<10> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n<18> offset = i + j * avctx -> width ;\n<22> vb_decode_framedata ( c , offset ) ;\n<27> vb_decode_palette ( c , size ) ;\n<29> memcpy ( frame -> data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n<31> outptr = frame -> data [ 0 ] ;\n<32> srcptr = c -> frame ;\n<34> i < avctx -> height ;\n<36> memcpy ( outptr , srcptr , avctx -> width ) ;\n<37> srcptr += avctx -> width ;\n<38> outptr += frame -> linesize [ 0 ] ;
<1> int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n<153> inc_refcounts(bs, res, refcount_table, nb_clusters,\n<191> if ((new_offset >> s->cluster_bits) >= nb_clusters) {\n<203> memset(&refcount_table[old_nb_clusters], 0, (nb_clusters\n<211> inc_refcounts(bs, res, refcount_table, nb_clusters,\n<355> g_free(refcount_table);
<1> static void _selectTablespace ( ArchiveHandle * AH , const char * tablespace ) {\n<6> have = AH -> currTablespace ;\n<8> if ( ! want ) return ;\n<9> if ( have && strcmp ( want , have ) == 0 ) return ;\n<10> qry = createPQExpBuffer ( ) ;\n<11> if ( strcmp ( want , "" ) == 0 ) {\n<12> appendPQExpBufferStr ( qry , "SET default_tablespace = ''" ) ;\n<15> appendPQExpBuffer ( qry , "SET default_tablespace = %s" , fmtId ( want ) ) ;\n<26> AH -> currTablespace = pg_strdup ( want ) ;\n<27> destroyPQExpBuffer ( qry ) ;
<1> int ff_init_vlc_sparse(VLC *vlc, int nb_bits, int nb_codes,\n<23> VLC dyn_vlc = *vlc;\n<27> if (vlc->table_size)\n<51> memcpy(vlc->table, dyn_vlc.table, dyn_vlc.table_size * sizeof(*vlc->table));\n<55> ff_free_vlc(&dyn_vlc);
<1> static int mem_write ( jas_stream_obj_t * obj , char * buf , int cnt ) {\n<7> assert ( buf ) ;\n<22> if ( n > 0 ) {\n<23> memset ( & m -> buf_ [ m -> len_ ] , 0 , n ) ;\n<24> m -> len_ += n ;\n<32> if ( ret > 0 ) {\n<33> memcpy ( & m -> buf_ [ m -> pos_ ] , buf , ret ) ;\n<34> m -> pos_ += ret ;\n<39> assert ( ret == cnt ) ;
<1> void *av_malloc(unsigned int size)\n<17> if(size > (INT_MAX-16) )\n<99> ptr = malloc(size);\n<103> return ptr;
<1> void command_loop(void)\n<15> for (i = 0; !done && i < ncmdline; i++) {\n<17> input = strdup(cmdline[i]);\n<19> if (!input) {\n<21> fprintf(stderr, _("cannot strdup command '%s': %s\n"),\n<23> cmdline[i], strerror(errno));\n<29> v = breakline(input, &c);\n<33> ct = find_command(v[0]);\n<35> if (ct) {\n<55> fprintf(stderr, _("command \"%s\" not found\n"), v[0]);\n<61> doneline(input, v);\n<65> if (cmdline) {\n<67> free(cmdline);\n<77> if (!prompted) {\n<79> printf("%s", get_prompt());\n<111> v = breakline(input, &c);\n<115> ct = find_command(v[0]);\n<117> if (ct) {\n<123> fprintf(stderr, _("command \"%s\" not found\n"), v[0]);\n<129> doneline(input, v);
<1> void mips_malta_init(MachineState *machine)\n<129> if (cpu == NULL) {\n<131> fprintf(stderr, "Unable to find CPU definition\n");\n<159> if (ram_size > (2048u << 20)) {\n<165> ((unsigned int)ram_size / (1 << 20)));\n<431> if (!rom_copy(memory_region_get_ram_ptr(bios_copy),\n<435> memcpy(memory_region_get_ram_ptr(bios_copy),\n<437> memory_region_get_ram_ptr(bios), BIOS_SIZE);
<1> static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)\n<13> if (s->current_bulk_in != NULL) {\n<15> ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);\n<17> memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);\n<19> s->current_bulk_in->pos += ret;\n<35> if (ret > 0) {
<1> PyObject * PyString_Repr ( PyObject * obj , int smartquotes ) {\n<11> if ( v == NULL ) {\n<20> if ( smartquotes && memchr ( op -> ob_sval , '\'' , Py_SIZE ( op ) ) && ! memchr ( op -> ob_sval , '"' , Py_SIZE ( op ) ) ) quote = '"' ;\n<24> i < Py_SIZE ( op ) ;\n<26> assert ( newsize - ( p - PyString_AS_STRING ( v ) ) >= 5 ) ;\n<32> else if ( c < ' ' || c >= 0x7f ) {\n<33> sprintf ( p , "\\x%02x" , c & 0xff ) ;\n<34> p += 4 ;
<1> void usage_exit ( ) {\n<2> fprintf ( stderr , "Usage: %s <codec> <width> <height> <infile> <outfile> " "<keyframe-interval> [<error-resilient>]\nSee comments in " "simple_encoder.c for more information.\n" , exec_name ) ;
<1> static void cooked ( struct parse * pcmd , FILE * fp ) {\n<3> ( void ) fprintf ( fp , "Output set to cooked\n" ) ;
<1> static void pc_isa_bios_init(MemoryRegion *rom_memory,\n<51> flash_ptr = memory_region_get_ram_ptr(flash_mem);\n<53> isa_bios_ptr = memory_region_get_ram_ptr(isa_bios);\n<57> ((uint8_t*)flash_ptr) + (flash_size - isa_bios_size),
<1> static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,\n<59> if (offset > INT64_MAX - s->cluster_size) {\n<71> if (ret < 0) {\n<79> if (size < 0) {\n<91> assert(*nb_clusters >= old_nb_clusters);\n<101> if (!new_refcount_table) {\n<111> *refcount_table = new_refcount_table;\n<115> memset(*refcount_table + old_nb_clusters, 0,\n<123> if (cluster >= *nb_clusters) {\n<135> ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n<159> fprintf(stderr, "ERROR could not resize image: %s\n",\n<161> strerror(-ret));\n<177> ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n<187> if ((*refcount_table)[cluster] != 1) {\n<221> if ((new_offset >> s->cluster_bits) >= *nb_clusters) {\n<229> *refcount_table = g_renew(uint16_t, *refcount_table,\n<241> (*refcount_table)[cluster]--;\n<243> ret = inc_refcounts(bs, res, refcount_table, nb_clusters,
<1> static int iff_read_header(AVFormatContext *s)\n<269> if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)\n<273> if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))\n<275> st->codec->pix_fmt = AV_PIX_FMT_RGB24;\n<277> else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))\n<279> st->codec->pix_fmt = AV_PIX_FMT_RGBA;\n<281> else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))\n<283> st->codec->pix_fmt = AV_PIX_FMT_BGRA;\n<285> else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))\n<287> st->codec->pix_fmt = AV_PIX_FMT_ARGB;\n<289> else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))\n<291> st->codec->pix_fmt = AV_PIX_FMT_ABGR;\n<295> av_log_ask_for_sample(s, "unsupported color format\n");\n<297> return AVERROR_PATCHWELCOME;\n<373> if (metadata_tag) {
<1> int main ( int argc , char * * argv ) {\n<7> if ( ! argc ) {\n<10> else if ( ! strcmp ( * argv , "--from-str" ) ) {\n<13> for ( argv ++ , argc -- ;\n<14> argc ;\n<15> argc -- , argv ++ ) {\n<16> err = ksba_oid_from_str ( * argv , & buffer , & buflen ) ;\n<17> if ( err ) {\n<18> fprintf ( stderr , "can't convert `%s': %s\n" , * argv , gpg_strerror ( err ) ) ;\n<21> printf ( "%s ->" , * argv ) ;\n<23> n < buflen ;\n<24> n ++ ) printf ( " %02X" , buffer [ n ] ) ;\n<26> free ( buffer ) ;\n<29> else if ( ! strcmp ( * argv , "--to-str" ) ) {\n<33> argv ++ ;\n<34> argc -- ;\n<35> buffer = read_into_buffer ( stdin , & buflen ) ;\n<36> result = ksba_oid_to_str ( buffer , buflen ) ;\n<37> free ( buffer ) ;\n<38> printf ( "%s\n" , result ? result : "[malloc failed]" ) ;\n<39> free ( result ) ;\n<43> return 1 ;\n<45> return 0 ;
<1> static int opt_sections ( void * optctx , const char * opt , const char * arg ) {\n<2> printf ( "Sections:\n" "W.. = Section is a wrapper (contains other sections, no local entries)\n" ".A. = Section contains an array of elements of the same type\n" "..V = Section may contain a variable number of fields with variable keys\n" "FLAGS NAME/UNIQUE_NAME\n" "---\n" ) ;
<1> static int compress_filter_close ( struct archive_read_filter * self ) {\n<2> struct private_data * state = ( struct private_data * ) self -> data ;\n<3> free ( state -> out_block ) ;\n<4> free ( state ) ;
<1> static int ff_vp56_decode_mbs(AVCodecContext *avctx, void *data,\n<51> if (s->parse_coeff_models(s))\n<57> memset(s->prev_dc, 0, sizeof(s->prev_dc));\n<95> for (mb_row=0; mb_row<s->mb_height; mb_row++) {\n<117> memset(s->coeff_ctx, 0, sizeof(s->coeff_ctx));\n<119> memset(s->coeff_ctx_last, 24, sizeof(s->coeff_ctx_last));\n<155> int ret = vp56_decode_mb(s, mb_row, mb_col, is_alpha);\n<165> vp56_conceal_mb(s, mb_row, mb_col, is_alpha);
<1> static block_t * Encode ( encoder_t * p_enc , picture_t * p_pic ) {\n<81> p_enc_buf = schro_encoder_pull ( p_sys -> p_schro , & i_presentation_frame ) ;\n<82> p_block = block_Alloc ( p_enc_buf -> length ) ;\n<83> if ( ! p_block ) return NULL ;\n<84> memcpy ( p_block -> p_buffer , p_enc_buf -> data , p_enc_buf -> length ) ;\n<85> schro_buffer_unref ( p_enc_buf ) ;\n<86> if ( 0 == p_block -> p_buffer [ 4 ] ) {\n<88> if ( ! p_enc -> fmt_out . p_extra ) {\n<92> uint32_t len = GetDWBE ( p_block -> p_buffer + 5 ) ;\n<93> if ( len > UINT32_MAX - sizeof ( eos ) ) return NULL ;\n<94> p_enc -> fmt_out . p_extra = malloc ( len + sizeof ( eos ) ) ;\n<95> if ( ! p_enc -> fmt_out . p_extra ) return NULL ;\n<96> memcpy ( p_enc -> fmt_out . p_extra , p_block -> p_buffer , len ) ;\n<97> memcpy ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len , eos , sizeof ( eos ) ) ;\n<98> SetDWBE ( ( uint8_t * ) p_enc -> fmt_out . p_extra + len + sizeof ( eos ) - 4 , len ) ;\n<102> if ( ReadDiracPictureNumber ( & u_pic_num , p_block ) ) {\n<107> block_ChainAppend ( & p_output_chain , p_block ) ;\n<110> block_ChainAppend ( & p_output_chain , p_block ) ;
<1> int tls_construct_finished ( SSL * s , const char * sender , int slen ) {\n<5> p = ssl_handshake_start ( s ) ;\n<6> i = s -> method -> ssl3_enc -> final_finish_mac ( s , sender , slen , s -> s3 -> tmp . finish_md ) ;\n<7> if ( i <= 0 ) return 0 ;\n<9> memcpy ( p , s -> s3 -> tmp . finish_md , i ) ;\n<10> l = i ;\n<11> if ( ! s -> server ) {\n<12> OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n<13> memcpy ( s -> s3 -> previous_client_finished , s -> s3 -> tmp . finish_md , i ) ;\n<14> s -> s3 -> previous_client_finished_len = i ;\n<17> OPENSSL_assert ( i <= EVP_MAX_MD_SIZE ) ;\n<18> memcpy ( s -> s3 -> previous_server_finished , s -> s3 -> tmp . finish_md , i ) ;\n<19> s -> s3 -> previous_server_finished_len = i ;
<1> static void mpegts_insert_pcr_only(AVFormatContext *s, AVStream *st)\n<45> memset(q, 0xFF, TS_PACKET_SIZE - (q - buf));
<43> static void default_print_section_header ( WriterContext * wctx ) {\n<54> if ( ! ( section -> flags & ( SECTION_FLAG_IS_WRAPPER | SECTION_FLAG_IS_ARRAY ) ) ) printf ( "[%s]\n" , upcase_string ( buf , sizeof ( buf ) , section -> name ) ) ;
<1> int ahprintf ( ArchiveHandle * AH , const char * fmt , ... ) {\n<11> cnt = pvsnprintf ( p , len , fmt , args ) ;\n<13> if ( cnt < len ) break ;\n<14> free ( p ) ;\n<17> ahwrite ( p , 1 , cnt , AH ) ;\n<18> free ( p ) ;
<1> void qemu_acl_reset(qemu_acl *acl)\n<19> QTAILQ_REMOVE(&acl->entries, entry, next);\n<21> free(entry->match);\n<23> free(entry);
<1> static time_t xstrpisotime ( const char * s , char * * endptr ) {\n<4> memset ( & tm , 0 , sizeof ( tm ) ) ;\n<26> res = time_from_tm ( & tm ) ;
<1> static int compress_filter ( void * opaque , int control , IOBUF a , byte * buf , size_t * ret_len ) {\n<19> if ( ! zfx -> status ) {\n<23> memset ( & cd , 0 , sizeof cd ) ;\n<28> pkt . pkt . compressed = & cd ;
<1> static int bink_decode_plane ( BinkContext * c , AVFrame * frame , GetBitContext * gb , int plane_idx , int is_chroma ) {\n<38> dst = frame -> data [ plane_idx ] + 8 * by * stride ;\n<42> bx ++ , dst += 8 , prev += 8 ) {\n<50> switch ( blk ) {\n<54> switch ( blk ) {\n<79> case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<80> dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n<81> read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n<82> c -> bdsp . idct_put ( ublock , 8 , dctblock ) ;\n<135> j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n<140> j ++ ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n<144> if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n<159> case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<160> dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n<161> read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n<162> c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n<171> memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<172> dctblock [ 0 ] = get_value ( c , BINK_SRC_INTER_DC ) ;\n<173> read_dct_coeffs ( gb , dctblock , bink_scan , bink_inter_quant , - 1 ) ;\n<174> c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n<185> j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n<189> i < 8 ;\n<190> i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINK_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;
<1> void append_info ( DYNAMIC_STRING * ds , ulonglong affected_rows , const char * info ) {\n<2> char buf [ 40 ] , buff2 [ 21 ] ;\n<3> sprintf ( buf , "affected rows: %s\n" , llstr ( affected_rows , buff2 ) ) ;\n<4> dynstr_append ( ds , buf ) ;
<1> static vpx_fixed_buf_t pass0 ( vpx_image_t * raw , FILE * infile , const VpxInterface * encoder , const vpx_codec_enc_cfg_t * cfg ) {\n<12> while ( get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_GOOD_QUALITY , & stats ) ) {\n<14> printf ( "Pass 0 complete. Processed %d frames.\n" , frame_count ) ;
<1> static void _isoent_free ( struct isoent * isoent ) {\n<3> free ( isoent -> children_sorted ) ;\n<4> free ( isoent -> identifier ) ;\n<6> while ( er != NULL ) {\n<8> free ( er ) ;\n<11> free ( isoent ) ;
<1> static void test_set_variable ( ) {\n<6> char var [ NAME_LEN + 1 ] ;\n<12> memset ( get_bind , 0 , sizeof ( get_bind ) ) ;\n<22> rc = mysql_stmt_bind_result ( stmt1 , get_bind ) ;\n<26> if ( ! opt_silent ) fprintf ( stdout , "\n max_error_count(default): %d" , get_count ) ;\n<27> def_count = get_count ;\n<28> DIE_UNLESS ( strcmp ( var , "max_error_count" ) == 0 ) ;\n<33> memset ( set_bind , 0 , sizeof ( set_bind ) ) ;\n<36> rc = mysql_stmt_bind_param ( stmt , set_bind ) ;\n<46> if ( ! opt_silent ) fprintf ( stdout , "\n max_error_count : %d" , get_count ) ;\n<47> DIE_UNLESS ( get_count == set_count ) ;\n<57> if ( ! opt_silent ) fprintf ( stdout , "\n max_error_count(default): %d" , get_count ) ;\n<58> DIE_UNLESS ( get_count == set_count ) ;
<1> static void dumpcmap ( struct alltabs * at , SplineFont * sf , enum fontformat format ) {\n<14> memset ( table , '\0' , sizeof ( table ) ) ;\n<16> table [ 29 ] = table [ 8 ] = table [ 0 ] = 1 ;\n<17> table [ 9 ] = table [ 13 ] = 2 ;\n<23> if ( sc != NULL && sc -> ttf_glyph != - 1 ) table [ i ] = sc -> ttf_glyph ;\n<25> if ( table [ 0 ] == 0 ) table [ 0 ] = 1 ;\n<26> if ( modformat == ff_ttfsym ) {\n<28> memset ( table , '\0' , sizeof ( table ) ) ;\n<42> if ( map -> map [ i ] != - 1 && ( sc = sf -> glyphs [ map -> map [ i ] ] ) != NULL && sc -> ttf_glyph != - 1 && table [ i - 0xf000 ] == 0 ) table [ i - 0xf000 ] = sc -> ttf_glyph ;\n<54> if ( map -> map [ i ] != - 1 && ( sc = sf -> glyphs [ map -> map [ i ] ] ) != NULL && sc -> ttf_glyph != - 1 && table [ i ] == 0 ) table [ i ] = sc -> ttf_glyph ;\n<169> ++ i ) if ( table [ i ] >= 256 ) {\n<179> ++ i ) putc ( table [ i ] , at -> cmap ) ;\n<189> ++ i ) putshort ( at -> cmap , table [ i ] ) ;
<1> static void release_request ( struct transfer_request * request ) {\n<3> if ( request == request_queue_head ) {\n<8> if ( entry -> next == request ) entry -> next = entry -> next -> next ;\n<10> free ( request -> url ) ;\n<11> free ( request ) ;
<1> static QEMUCursor *qxl_cursor(PCIQXLDevice *qxl, QXLCursor *cursor)\n<13> c = cursor_alloc(cursor->header.width, cursor->header.height);\n<19> switch (cursor->header.type) {\n<23> size = sizeof(uint32_t) * cursor->header.width * cursor->header.height;\n<25> memcpy(c->data, cursor->chunk.data, size);\n<29> cursor_print_ascii_art(c, "qxl/alpha");\n<53> fprintf(stderr, "%s: not implemented: type %d\n",\n<61> return c;
<1> static int avi_sync ( AVFormatContext * s , int exit_early ) {\n<8> start_sync : memset ( d , - 1 , sizeof ( d ) ) ;\n<15> j ++ ) d [ j ] = d [ j + 1 ] ;\n<17> size = d [ 4 ] + ( d [ 5 ] << 8 ) + ( d [ 6 ] << 16 ) + ( d [ 7 ] << 24 ) ;\n<18> n = get_stream_idx ( d + 2 ) ;\n<20> if ( i * ( avi -> io_fsize > 0 ) + ( uint64_t ) size > avi -> fsize || d [ 0 ] > 127 ) continue ;\n<21> if ( ( d [ 0 ] == 'i' && d [ 1 ] == 'x' && n < s -> nb_streams ) || ( d [ 0 ] == 'J' && d [ 1 ] == 'U' && d [ 2 ] == 'N' && d [ 3 ] == 'K' ) || ( d [ 0 ] == 'i' && d [ 1 ] == 'd' && d [ 2 ] == 'x' && d [ 3 ] == '1' ) || ( d [ 0 ] == 'i' && d [ 1 ] == 'n' && d [ 2 ] == 'd' && d [ 3 ] == 'x' ) ) {\n<25> if ( d [ 0 ] == 'L' && d [ 1 ] == 'I' && d [ 2 ] == 'S' && d [ 3 ] == 'T' ) {\n<29> n = get_stream_idx ( d ) ;\n<30> if ( ! ( ( i - avi -> last_pkt_pos ) & 1 ) && get_stream_idx ( d + 1 ) < s -> nb_streams ) continue ;\n<31> if ( d [ 2 ] == 'i' && d [ 3 ] == 'x' && n < s -> nb_streams ) {\n<48> if ( d [ 2 ] == 'w' && d [ 3 ] == 'b' && n == 0 && st -> codecpar -> codec_type == AVMEDIA_TYPE_VIDEO && st1 -> codecpar -> codec_type == AVMEDIA_TYPE_AUDIO && ast -> prefix == 'd' * 256 + 'c' && ( d [ 2 ] * 256 + d [ 3 ] == ast1 -> prefix || ! ast1 -> prefix_count ) ) {\n<56> if ( ! exit_early ) {\n<62> if ( d [ 2 ] == 'p' && d [ 3 ] == 'c' && size <= 4 * 256 + 4 ) {\n<72> else if ( ( ( ast -> prefix_count < 5 || sync + 9 > i ) && d [ 2 ] < 128 && d [ 3 ] < 128 ) || d [ 2 ] * 256 + d [ 3 ] == ast -> prefix ) {\n<74> if ( d [ 2 ] * 256 + d [ 3 ] == ast -> prefix ) ast -> prefix_count ++ ;\n<76> ast -> prefix = d [ 2 ] * 256 + d [ 3 ] ;
<1> static int rtp_packetize_amr ( sout_stream_id_sys_t * id , block_t * in ) {\n<4> uint8_t * p_data = in -> p_buffer ;\n<8> i < i_count ;\n<14> out -> p_buffer [ 13 ] = p_data [ 0 ] & 0x7C ;\n<15> memcpy ( & out -> p_buffer [ 14 ] , p_data + 1 , i_payload - 1 ) ;\n<20> p_data += i_payload ;
<1> void SSL3_RECORD_clear ( SSL3_RECORD * r , unsigned int num_recs ) {\n<5> i < num_recs ;\n<8> memset ( & r [ i ] , 0 , sizeof ( * r ) ) ;
<13> if ((ret = ff_tls_open_underlying(s, h, uri, options)) < 0)\n<47> if (s->verify)\n<49> CHECK_ERROR(SSLSetPeerDomainName, c->ssl_context, s->host, strlen(s->host));
<1> static int rtp_packetize_ac3 ( sout_stream_id_sys_t * id , block_t * in ) {\n<4> uint8_t * p_data = in -> p_buffer ;\n<8> i < i_count ;\n<10> int i_payload = __MIN ( i_max , i_data ) ;\n<15> memcpy ( & out -> p_buffer [ 14 ] , p_data , i_payload ) ;\n<19> p_data += i_payload ;\n<20> i_data -= i_payload ;
<1> static void parse_waveformatex(AVIOContext *pb, AVCodecParameters *par)\n<13> ff_get_guid(pb, &subformat);\n<17> (const uint8_t[]){ FF_MEDIASUBTYPE_BASE_GUID }, 12)) {\n<19> par->codec_tag = AV_RL32(subformat);\n<21> par->codec_id  = ff_wav_codec_get_id(par->codec_tag,\n<23> par->bits_per_coded_sample);\n<27> par->codec_id = ff_codec_guid_get_id(ff_codec_wav_guids, subformat);
<1> int dissect_ber_GeneralizedTime ( gboolean implicit_tag , asn1_ctx_t * actx , proto_tree * tree , tvbuff_t * tvb , int offset , gint hf_id ) {\n<6> char first_delim [ 2 ] ;\n<8> char second_delim [ 2 ] ;\n<38> if ( ( len < 14 ) || ( len > 23 ) ) {\n<49> strptr += g_snprintf ( str , 20 , "%.4s-%.2s-%.2s %.2s:%.2s:%.2s" , tmpstr , tmpstr + 4 , tmpstr + 6 , tmpstr + 8 , tmpstr + 10 , tmpstr + 12 ) ;\n<50> first_delim [ 0 ] = 0 ;\n<51> second_delim [ 0 ] = 0 ;\n<52> ret = sscanf ( tmpstr , "%14d%1[.,+-Z]%4d%1[+-Z]%4d" , & tmp_int , first_delim , & first_digits , second_delim , & second_digits ) ;\n<53> if ( ret < 1 ) {\n<61> strptr += g_snprintf ( strptr , 5 , "%c%.3d" , first_delim [ 0 ] , first_digits ) ;\n<67> g_snprintf ( strptr , 12 , " (UTC%c%.4d)" , second_delim [ 0 ] , second_digits ) ;\n<78> g_snprintf ( strptr , 12 , " (UTC%c%.4d)" , first_delim [ 0 ] , first_digits ) ;\n<90> invalid : cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , "invalid_generalized_time" , "GeneralizedTime invalid format: %s" , tmpstr ) ;
<1> void OS2FigureCodePages ( SplineFont * sf , uint32 CodePage [ 2 ] ) {\n<10> memset ( latin1 , 0 , sizeof ( latin1 ) ) ;\n<17> if ( sc -> unicodeenc < 256 && sc -> unicodeenc >= 0 ) latin1 [ ( sc -> unicodeenc >> 5 ) ] |= 1 << ( sc -> unicodeenc & 31 ) ;\n<22> has_ascii = latin1 [ 1 ] == 0xffffffff && latin1 [ 2 ] == 0xffffffff && ( latin1 [ 3 ] & 0x7fffffff ) == 0x7fffffff ;
<1> int unix_connect_opts(QemuOpts *opts)\n<13> if (NULL == path) {\n<15> fprintf(stderr, "unix connect: no path specified\n");\n<25> if (sock < 0) {\n<35> memset(&un, 0, sizeof(un));\n<39> snprintf(un.sun_path, sizeof(un.sun_path), "%s", path);\n<41> if (connect(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {\n<43> fprintf(stderr, "connect(unix:%s): %s\n", path, strerror(errno));\n<52> if (sockets_debug)\n<54> fprintf(stderr, "connect(unix:%s): OK\n", path);
<1> static void stop_server ( char * prefix , char * port ) {\n<3> int pid , path_size = strlen ( prefix ) + strlen ( port ) + 20 ;\n<4> path = ss_malloc ( path_size ) ;\n<5> snprintf ( path , path_size , "%s/.shadowsocks_%s.pid" , prefix , port ) ;\n<7> if ( f == NULL ) {\n<14> if ( fscanf ( f , "%d" , & pid ) != EOF ) {\n<15> kill ( pid , SIGTERM ) ;\n<17> fclose ( f ) ;
<7> ++ i ) putlong ( at -> loca , at -> gi . loca [ i ] ) ;\n<13> ++ i ) putshort ( at -> loca , at -> gi . loca [ i ] / 2 ) ;\n<17> if ( at -> format != ff_type42 && at -> format != ff_type42cid ) {\n<18> free ( at -> gi . loca ) ;
<1> int ff_mpv_reallocate_putbitbuffer(MpegEncContext *s, size_t threshold, size_t size_increase)\n<10> av_fast_padded_malloc(&new_buffer, &new_buffer_size,\n<12> if (!new_buffer)\n<13> memcpy(new_buffer, s->avctx->internal->byte_buffer, s->avctx->internal->byte_buffer_size);\n<14> av_free(s->avctx->internal->byte_buffer);\n<15> s->avctx->internal->byte_buffer      = new_buffer;\n<17> rebase_put_bits(&s->pb, new_buffer, new_buffer_size);
<1> static void rtsp_cmd_describe(HTTPContext *c, const char *url)\n<23> path = path1;\n<25> if (*path == '/')\n<27> path++;\n<31> for(stream = first_stream; stream != NULL; stream = stream->next) {\n<33> if (!stream->is_feed && !strcmp(stream->fmt->name, "rtp") &&\n<35> !strcmp(path, stream->filename)) {\n<59> len = sizeof(my_addr);\n<61> getsockname(c->fd, (struct sockaddr *)&my_addr, &len);\n<63> content_length = prepare_sdp_description(stream, &content, my_addr.sin_addr);\n<65> if (content_length < 0) {
<1> static int ipvideo_decode_block_opcode_0xA(IpvideoContext *s, AVFrame *frame)\n<6> bytestream2_get_buffer(&s->stream_ptr, P, 4);\n<26> vert = P[4] <= P[5];\n<39> memcpy(P, P + 4, 4);
<1> static const char * update_rule_action ( cmd_parms * cmd , directory_config * dcfg , const char * p1 , const char * p2 , int offset ) {\n<20> if ( new_actionset == NULL ) return FATAL_ERROR ;\n<22> if ( ( new_actionset -> id != NOT_SET_P ) && ( rule -> actionset -> id != NULL ) && ( strcmp ( rule -> actionset -> id , new_actionset -> id ) != 0 ) ) {\n<33> msre_actionset_set_defaults ( rule -> actionset ) ;
<1> static jpc_enc_tcmpt_t * tcmpt_create ( jpc_enc_tcmpt_t * tcmpt , jpc_enc_cp_t * cp , jas_image_t * image , jpc_enc_tile_t * tile ) {\n<17> cmptno = tcmpt - tile -> tcmpts ;\n<35> if ( ! ( tcmpt -> tsfb = jpc_cod_gettsfb ( tcmpt -> qmfbid , tcmpt -> numrlvls - 1 ) ) ) {\n<50> memset ( tcmpt -> stepsizes , 0 , tcmpt -> numstepsizes * sizeof ( uint_fast16_t ) ) ;\n<56> rlvlno < tcmpt -> numrlvls ;\n<59> rlvl -> tcmpt = tcmpt ;\n<61> for ( rlvlno = 0 , rlvl = tcmpt -> rlvls ;\n<62> rlvlno < tcmpt -> numrlvls ;\n<64> if ( ! rlvl_create ( rlvl , cp , tcmpt , bandinfos ) ) {\n<68> return tcmpt ;\n<69> error : tcmpt_destroy ( tcmpt ) ;
<1> char * Curl_checkheaders ( const struct connectdata * conn , const char * thisheader ) {\n<3> size_t thislen = strlen ( thisheader ) ;\n<8> if ( Curl_raw_nequal ( head -> data , thisheader , thislen ) ) return head -> data ;
<1> static void ipvideo_decode_opcodes(IpvideoContext *s, AVFrame *frame)\n<17> if (!s->is_16bpp) {\n<21> memcpy(frame->data[1], s->pal, AVPALETTE_SIZE);\n<71> ret = ipvideo_decode_block[opcode](s, frame);\n<79> ret = ipvideo_decode_block16[opcode](s, frame);
<1> static void test_wl4166_2 ( ) {\n<18> memset ( bind_out , 0 , sizeof ( bind_out ) ) ;\n<23> rc = mysql_stmt_bind_result ( stmt , bind_out ) ;
<1> static void spapr_reset_htab(sPAPRMachineState *spapr)\n<13> if (shift > 0) {\n<33> memset(spapr->htab, 0, HTAB_SIZE(spapr));\n<37> for (index = 0; index < HTAB_SIZE(spapr) / HASH_PTE_SIZE_64; index++) {\n<39> DIRTY_HPTE(HPTE(spapr->htab, index));
<1> static size_t try_block ( const char * d , size_t dlen , const char * fromcode , const char * tocode , encoder_t * encoder , size_t * wlen ) {\n<7> if ( fromcode ) {\n<8> iconv_t cd = mutt_ch_iconv_open ( tocode , fromcode , 0 ) ;\n<13> obl = sizeof ( buf ) - strlen ( tocode ) ;\n<14> if ( iconv ( cd , ( ICONV_CONST char * * ) & ib , & ibl , & ob , & obl ) == ( size_t ) ( - 1 ) || iconv ( cd , NULL , NULL , & ob , & obl ) == ( size_t ) ( - 1 ) ) {\n<23> if ( dlen > ( sizeof ( buf ) - strlen ( tocode ) ) ) return ( sizeof ( buf ) - strlen ( tocode ) + 1 ) ;\n<24> memcpy ( buf , d , dlen ) ;\n<25> ob = buf + dlen ;\n<27> count = 0 ;\n<28> for ( char * p = buf ;\n<29> p < ob ;\n<30> p ++ ) {\n<31> unsigned char c = * p ;\n<32> assert ( strchr ( MimeSpecials , '?' ) ) ;\n<33> if ( ( c >= 0x7f ) || ( c < 0x20 ) || ( * p == '_' ) || ( ( c != ' ' ) && strchr ( MimeSpecials , * p ) ) ) {\n<37> len = ENCWORD_LEN_MIN - 2 + strlen ( tocode ) ;\n<38> len_b = len + ( ( ( ob - buf ) + 2 ) / 3 ) * 4 ;\n<39> len_q = len + ( ob - buf ) + 2 * count ;\n<40> if ( mutt_str_strcasecmp ( tocode , "ISO-2022-JP" ) == 0 ) len_q = ENCWORD_LEN_MAX + 1 ;\n<41> if ( ( len_b < len_q ) && ( len_b <= ENCWORD_LEN_MAX ) ) {\n<51> else return dlen ;
<1> static void test_rename ( ) {\n<14> if ( ! opt_silent ) fprintf ( stdout , "rename without t3\n" ) ;\n<19> if ( ! opt_silent ) fprintf ( stdout , "rename with t3\n" ) ;\n<22> if ( ! opt_silent ) fprintf ( stdout , "rename renamed\n" ) ;\n<27> if ( ! opt_silent ) fprintf ( stdout , "rename reverted\n" ) ;
<1> static void mpeg_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,\n<9> MpegEncContext *s = opaque;\n<26> memcpy(s->mv, mv, sizeof(*mv));\n<30> ff_init_block_index(s);\n<32> ff_update_block_index(s);\n<66> ff_mpv_reconstruct_mb(s, s->block);
<1> static gcry_err_code_t pss_encode ( gcry_mpi_t * r_result , unsigned int nbits , int algo , const unsigned char * value , size_t valuelen , int saltlen , const void * random_override , size_t random_override_len ) {\n<19> if ( ! buf ) {\n<23> mhash = buf + 8 ;\n<24> salt = mhash + hlen ;\n<26> if ( valuelen != hlen ) {\n<30> memcpy ( mhash , value , hlen ) ;\n<31> if ( emlen < hlen + saltlen + 2 ) {\n<40> h = em + emlen - 1 - hlen ;\n<41> if ( saltlen ) {\n<42> if ( random_override ) {\n<43> if ( random_override_len != saltlen ) {\n<47> memcpy ( salt , random_override , saltlen ) ;\n<49> else gcry_randomize ( salt , saltlen , GCRY_STRONG_RANDOM ) ;\n<51> memset ( buf , 0 , 8 ) ;\n<52> gcry_md_hash_buffer ( algo , h , buf , 8 + hlen + saltlen ) ;\n<53> p = em + emlen - 1 - hlen - saltlen - 1 ;\n<54> memset ( em , 0 , p - em ) ;\n<55> * p ++ = 0x01 ;\n<56> memcpy ( p , salt , saltlen ) ;\n<60> n ++ , p ++ ) em [ n ] ^= * p ;\n<61> em [ 0 ] &= 0xFF >> ( 8 * emlen - nbits ) ;\n<63> err = gcry_mpi_scan ( r_result , GCRYMPI_FMT_USG , em , emlen , NULL ) ;
<1> int qcow2_check_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n<31> fprintf(stderr, "ERROR need to rebuild refcount structures\n");
<1> static int inject_fake_duration_metadata(RTMPContext *rt)\n<17> uint8_t* old_flv_data = rt->flv_data;\n<21> if (!(rt->flv_data = av_malloc(rt->flv_size + 55))) {\n<33> memcpy(rt->flv_data, old_flv_data, 13);\n<37> memcpy(rt->flv_data + 13 + 55, old_flv_data + 13, rt->flv_size - 13);\n<45> av_free(old_flv_data);\n<49> p = rt->flv_data + 13;
<1> int qemuMonitorTextAttachDrive ( qemuMonitorPtr mon , const char * drivestr , virDomainDevicePCIAddress * controllerAddr , virDomainDeviceDriveAddress * driveAddr ) {\n<3> char * reply = NULL ;\n<12> try_command : if ( virAsprintf ( & cmd , "drive_add %s%.2x:%.2x:%.2x %s" , ( tryOldSyntax ? "" : "pci_addr=" ) , controllerAddr -> domain , controllerAddr -> bus , controllerAddr -> slot , safe_str ) < 0 ) {\n<16> if ( qemuMonitorHMPCommand ( mon , cmd , & reply ) < 0 ) {\n<20> if ( strstr ( reply , "unknown command:" ) ) {\n<21> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , _ ( "drive hotplug is not supported" ) ) ;\n<24> if ( qemudParseDriveAddReply ( reply , driveAddr ) < 0 ) {\n<25> if ( ! tryOldSyntax && strstr ( reply , "invalid char in expression" ) ) {\n<26> VIR_FREE ( reply ) ;\n<27> VIR_FREE ( cmd ) ;\n<28> tryOldSyntax = 1 ;\n<31> qemuReportError ( VIR_ERR_OPERATION_FAILED , _ ( "adding %s disk failed: %s" ) , drivestr , reply ) ;\n<36> VIR_FREE ( reply ) ;
<1> static void rc4030_reset(DeviceState *dev)\n<5> rc4030State *s = RC4030(dev);\n<19> memset(s->dma_regs, 0, sizeof(s->dma_regs));\n<21> rc4030_dma_tt_update(s, 0, 0);
<1> static inline void softusb_read_dmem(MilkymistSoftUsbState *s,\n<3> uint32_t offset, uint8_t *buf, uint32_t len)\n<7> if (offset + len >= s->dmem_size) {\n<20> memcpy(buf, s->dmem_ptr + offset, len);
<1> static void test_bug8330 ( ) {\n<5> const char * query = "select a,b from t1 where a=?" ;\n<9> stmt_text = "drop table if exists t1" ;\n<10> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<12> stmt_text = "create table t1 (a int, b int)" ;\n<13> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<15> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<17> i < 2 ;\n<19> stmt [ i ] = mysql_stmt_init ( mysql ) ;\n<20> rc = mysql_stmt_prepare ( stmt [ i ] , query , strlen ( query ) ) ;\n<25> mysql_stmt_bind_param ( stmt [ i ] , & my_bind [ i ] ) ;\n<35> stmt_text = "drop table t1" ;\n<36> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static guint32 dissect_ies ( tvbuff_t * tvb , packet_info * pinfo , guint32 offset , proto_tree * iax_tree , proto_item * iax_item , iax2_ie_data * ie_data ) {\n<22> TVB_SET_ADDRESS ( & ie_data -> peer_address , AT_IPv4 , tvb , offset + 6 , 4 ) ;\n<77> if ( apparent_addr_family == LINUX_AF_INET ) {\n<80> memcpy ( & addr , ie_data -> peer_address . data , 4 ) ;\n<81> proto_tree_add_ipv4 ( sockaddr_tree , hf_IAX_IE_APPARENTADDR_SINADDR , tvb , offset + 6 , 4 , addr ) ;
<1> static void search_postfix_add ( const char * domain ) {\n<4> while ( domain [ 0 ] == '.' ) domain ++ ;\n<5> domain_len = strlen ( domain ) ;\n<7> if ( ! global_search_state ) return ;\n<9> sdomain = ( struct search_domain * ) malloc ( sizeof ( struct search_domain ) + domain_len ) ;\n<10> if ( ! sdomain ) return ;\n<11> memcpy ( ( ( u8 * ) sdomain ) + sizeof ( struct search_domain ) , domain , domain_len ) ;\n<13> sdomain -> len = domain_len ;
<1> static void config_access ( config_tree * ptree ) {\n<113> if ( ( RES_MSSNTP & flags ) && ! warned_signd ) {\n<115> fprintf ( stderr , "%s\n" , signd_warning ) ;\n<116> msyslog ( LOG_WARNING , signd_warning ) ;\n<118> ZERO_SOCK ( & addr ) ;\n<134> AF ( & addr ) = ( u_short ) my_node -> addr -> type ;\n<135> if ( getnetnum ( my_node -> addr -> address , & addr , 1 , t_UNK ) != 1 ) {\n<137> memset ( & hints , 0 , sizeof ( hints ) ) ;\n<138> hints . ai_protocol = IPPROTO_UDP ;\n<139> hints . ai_socktype = SOCK_DGRAM ;\n<140> hints . ai_family = my_node -> addr -> type ;\n<141> rc = getaddrinfo ( my_node -> addr -> address , "ntp" , & hints , & ai_list ) ;\n<142> if ( rc ) {\n<147> pai = ai_list ;\n<148> NTP_INSIST ( pai -> ai_addr != NULL ) ;\n<149> NTP_INSIST ( sizeof ( addr ) >= pai -> ai_addrlen ) ;\n<150> memcpy ( & addr , pai -> ai_addr , pai -> ai_addrlen ) ;\n<151> NTP_INSIST ( AF_INET == AF ( & addr ) || AF_INET6 == AF ( & addr ) ) ;\n<153> SET_HOSTMASK ( & mask , AF ( & addr ) ) ;\n<164> AF ( & addr ) = AF_INET ;\n<166> hack_restrict ( RESTRICT_FLAGS , & addr , & mask , mflags , flags , 0 ) ;\n<167> AF ( & addr ) = AF_INET6 ;\n<171> hack_restrict ( RESTRICT_FLAGS , & addr , & mask , mflags , flags , 0 ) ;\n<172> if ( pai != NULL && NULL != ( pai = pai -> ai_next ) ) {\n<173> NTP_INSIST ( pai -> ai_addr != NULL ) ;\n<174> NTP_INSIST ( sizeof ( addr ) >= pai -> ai_addrlen ) ;\n<175> ZERO_SOCK ( & addr ) ;\n<176> memcpy ( & addr , pai -> ai_addr , pai -> ai_addrlen ) ;\n<177> NTP_INSIST ( AF_INET == AF ( & addr ) || AF_INET6 == AF ( & addr ) ) ;\n<178> SET_HOSTMASK ( & mask , AF ( & addr ) ) ;\n<181> while ( pai != NULL ) ;
<1> static guint8 * get_value ( packet_info * pinfo , guint32 handle , bluetooth_data_t * bluetooth_data , guint * length ) {\n<9> guint8 * data = NULL ;\n<22> if ( ! fragment_data || ( fragment_data && fragment_data -> offset >= last_offset ) ) break ;\n<23> if ( first ) {\n<24> size = fragment_data -> offset + fragment_data -> length ;\n<25> data = ( guint8 * ) wmem_alloc ( pinfo -> pool , size ) ;\n<29> else if ( fragment_data -> offset + fragment_data -> length != last_offset ) {\n<32> memcpy ( data + fragment_data -> offset , fragment_data -> data , fragment_data -> length ) ;\n<33> if ( fragment_data -> offset == 0 ) return data ;
<1> void helper_movcal(CPUSH4State *env, uint32_t address, uint32_t value)\n<5> if (cpu_sh4_is_cached (env, address))\n<9> memory_content *r = malloc (sizeof(memory_content));\n<19> *(env->movcal_backup_tail) = r;\n<21> env->movcal_backup_tail = &(r->next);
<1> static int rtp_packetize_mpa ( sout_stream_id_sys_t * id , block_t * in ) {\n<4> uint8_t * p_data = in -> p_buffer ;\n<8> i < i_count ;\n<10> int i_payload = __MIN ( i_max , i_data ) ;\n<12> rtp_packetize_common ( id , out , ( i == i_count - 1 ) ? 1 : 0 , in -> i_pts ) ;\n<13> SetWBE ( out -> p_buffer + 12 , 0 ) ;\n<14> SetWBE ( out -> p_buffer + 14 , i * i_max ) ;\n<15> memcpy ( & out -> p_buffer [ 16 ] , p_data , i_payload ) ;\n<18> rtp_packetize_send ( id , out ) ;\n<19> p_data += i_payload ;\n<20> i_data -= i_payload ;
<1> void curl_formfree ( struct curl_httppost * form ) {\n<3> if ( ! form ) return ;\n<6> if ( form -> more ) curl_formfree ( form -> more ) ;\n<7> if ( ! ( form -> flags & HTTPPOST_PTRNAME ) && form -> name ) free ( form -> name ) ;\n<8> if ( ! ( form -> flags & ( HTTPPOST_PTRCONTENTS | HTTPPOST_BUFFER | HTTPPOST_CALLBACK ) ) && form -> contents ) free ( form -> contents ) ;\n<9> if ( form -> contenttype ) free ( form -> contenttype ) ;\n<10> if ( form -> showfilename ) free ( form -> showfilename ) ;\n<11> free ( form ) ;\n<13> while ( ( form = next ) != NULL ) ;
<1> static int decode_channel ( RALFContext * ctx , GetBitContext * gb , int ch , int length , int mode , int bits ) {\n<7> int * dst = ctx -> channel_data [ ch ] ;\n<20> if ( ctx -> filter_params == FILTER_NONE ) {\n<21> memset ( dst , 0 , sizeof ( * dst ) * length ) ;
<1> int tm_rescinfo ( tm_node_id node , char * resource , int len , tm_event_t * event ) {\n<8> if ( diswsi ( chan , node ) != DIS_SUCCESS ) {\n<14> rhold = ( struct reschold * ) calloc ( 1 , sizeof ( struct reschold ) ) ;\n<15> assert ( rhold != NULL ) ;
<1> static int decode_frame(AVCodecContext *avctx,\n<21> if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n<25> if (!avctx->frame_number) {\n<27> for (i=0; i<avctx->height; i++)\n<29> memset(s->frame->data[0]+ i*s->frame->linesize[0], 0, avctx->width);\n<31> memset(s->frame->data[1], 0, AVPALETTE_SIZE);\n<41> set_palette((uint32_t *)s->frame->data[1]);\n<45> erase_screen(avctx);\n<85> draw_char(avctx, ' ');\n<91> hscroll(avctx);\n<101> erase_screen(avctx);\n<113> draw_char(avctx, buf[0]);\n<133> draw_char(avctx, 0x1B);\n<181> av_log(avctx, AV_LOG_WARNING, "args overflow (%i)\n", s->nb_args);\n<187> if ((ret = execute_code(avctx, buf[0])) < 0)
<1> static int kex_agree_crypt ( LIBSSH2_SESSION * session , libssh2_endpoint_data * endpoint , unsigned char * crypt , unsigned long crypt_len ) {\n<7> while ( s && * s ) {\n<8> unsigned char * p = ( unsigned char * ) strchr ( ( char * ) s , ',' ) ;\n<9> size_t method_len = ( p ? ( size_t ) ( p - s ) : strlen ( ( char * ) s ) ) ;\n<22> while ( * cryptp && ( * cryptp ) -> name ) {\n<23> s = kex_agree_instr ( crypt , crypt_len , ( unsigned char * ) ( * cryptp ) -> name , strlen ( ( * cryptp ) -> name ) ) ;\n<25> endpoint -> crypt = * cryptp ;
<1> void memory_region_del_eventfd(MemoryRegion *mr,\n<39> if (memory_region_ioeventfd_equal(mrfd, mr->ioeventfds[i])) {\n<49> memmove(&mr->ioeventfds[i], &mr->ioeventfds[i+1],\n<51> sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb - (i+1)));
<1> static FILE * checkdupstoredtable ( SplineFont * sf , uint32 tag , int * len , struct alltabs * all , int me ) {\n<4> if ( tab == NULL ) {\n<12> if ( test != NULL && test -> len == tab -> len && memcmp ( test -> data , tab -> data , tab -> len ) == 0 ) {
<1> REGRESSION_TEST ( SDK_API_TSMgmtGet ) ( RegressionTest * test , int , int * pstatus ) {\n<9> const char * CONFIG_PARAM_STRING_VALUE = "Traffic Server" ;\n<15> TSMgmtString svalue = nullptr ;\n<41> if ( TS_SUCCESS != TSMgmtStringGet ( CONFIG_PARAM_STRING_NAME , & svalue ) ) {\n<45> else if ( strcmp ( svalue , CONFIG_PARAM_STRING_VALUE ) != 0 ) {\n<47> err = 1 ;\n<50> SDK_RPRINT ( test , "TSMgmtStringGet" , "TestCase1.4" , TC_PASS , "ok" ) ;
<1> static int encode_frame ( vpx_codec_ctx_t * codec , vpx_image_t * img , int frame_index , int flags , VpxVideoWriter * writer ) {\n<9> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) {\n<14> printf ( keyframe ? "K" : "." ) ;
<239> if (h->short_ref_count)
<25> if (ret == -1)\n<35> *host_array = malloc(nsems*sizeof(unsigned short));
<1> static const struct ogg_codec * ogg_find_codec ( uint8_t * buf , int size ) {\n<5> i ++ ) if ( size >= ogg_codecs [ i ] -> magicsize && ! memcmp ( buf , ogg_codecs [ i ] -> magic , ogg_codecs [ i ] -> magicsize ) ) return ogg_codecs [ i ] ;
<1> static const char * get_current_charset ( struct archive * a ) {\n<5> cur_charset = default_iconv_charset ( a -> current_code ) ;\n<6> if ( a -> current_code == NULL ) {\n<7> a -> current_code = strdup ( cur_charset ) ;\n<12> return ( cur_charset ) ;
<1> jas_image_fmtinfo_t * jas_image_lookupfmtbyname ( const char * name ) {\n<4> for ( i = 0 , fmtinfo = jas_image_fmtinfos ;\n<5> i < jas_image_numfmts ;\n<6> ++ i , ++ fmtinfo ) {\n<7> if ( ! strcmp ( fmtinfo -> name , name ) ) {\n<8> return fmtinfo ;
<1> int test_rshift1 ( BIO * bp ) {\n<24> if ( ! BN_is_zero ( c ) && ! BN_abs_is_word ( c , 1 ) ) {\n<25> fprintf ( stderr , "Right shift one test failed!\n" ) ;
<1> static void formant_postfilter(G723_1_Context *p, int16_t *lpc, int16_t *buf)\n<7> int filter_signal[LPC_ORDER + FRAME_LEN], *signal_ptr;\n<13> memcpy(buf, p->fir_mem, LPC_ORDER * sizeof(*buf));\n<15> memcpy(filter_signal, p->iir_mem, LPC_ORDER * sizeof(*filter_signal));\n<33> iir_filter(filter_coef[0], filter_coef[1], buf + i,\n<35> filter_signal + i);\n<43> memcpy(p->fir_mem, buf + FRAME_LEN, LPC_ORDER * sizeof(*p->fir_mem));\n<45> memcpy(p->iir_mem, filter_signal + FRAME_LEN,\n<47> LPC_ORDER * sizeof(*p->iir_mem));\n<51> buf_ptr    = buf + LPC_ORDER;\n<53> signal_ptr = filter_signal + LPC_ORDER;\n<55> for (i = 0; i < SUBFRAMES; i++) {\n<57> int16_t temp_vector[SUBFRAME_LEN];\n<69> memcpy(temp_vector, buf_ptr, SUBFRAME_LEN * sizeof(*temp_vector));\n<71> scale = scale_vector(temp_vector, SUBFRAME_LEN);\n<129> gain_scale(p, buf_ptr, energy);\n<133> buf_ptr    += SUBFRAME_LEN;
<1> int _evsignal_set_handler ( struct event_base * base , int evsignal , void ( * handler ) ( int ) ) {\n<6> if ( evsignal >= sig -> sh_old_max ) {\n<9> p = realloc ( sig -> sh_old , new_max * sizeof ( * sig -> sh_old ) ) ;\n<10> if ( p == NULL ) {\n<11> event_warn ( "realloc" ) ;\n<14> memset ( ( char * ) p + sig -> sh_old_max * sizeof ( * sig -> sh_old ) , 0 , ( new_max - sig -> sh_old_max ) * sizeof ( * sig -> sh_old ) ) ;\n<18> sig -> sh_old [ evsignal ] = malloc ( sizeof * sig -> sh_old [ evsignal ] ) ;\n<19> if ( sig -> sh_old [ evsignal ] == NULL ) {\n<20> event_warn ( "malloc" ) ;\n<35> free ( sig -> sh_old [ evsignal ] ) ;
<1> int inet_aton (const char * str, struct in_addr * add)\n<11> add1 = atoi(pch);\n<13> pch = strpbrk(pch,".");\n<15> if (pch == 0 || ++pch == 0) goto done;\n<17> add2 = atoi(pch);\n<19> pch = strpbrk(pch,".");\n<21> if (pch == 0 || ++pch == 0) goto done;\n<23> add3 = atoi(pch);\n<25> pch = strpbrk(pch,".");\n<27> if (pch == 0 || ++pch == 0) goto done;
<1> static int matroska_read_header(AVFormatContext *s, AVFormatParameters *ap)\n<23> Ebml ebml = { 0 };\n<41> || ebml.id_length > sizeof(uint32_t) || strcmp(ebml.doctype, "matroska")\n<57> ebml_free(ebml_syntax, &ebml);\n<67> matroska_execute_seekhead(matroska);\n<77> if (matroska->title)\n<81> sizeof(matroska->ctx->title)-1);\n<91> MatroskaTrack *track = &tracks[i];\n<103> int extradata_offset = 0;\n<125> if (track->codec_id == NULL)\n<187> uint8_t *codec_priv = track->codec_priv.data;\n<189> int offset = matroska_decode_buffer(&track->codec_priv.data,\n<205> } else if (offset > 0) {\n<207> track->codec_priv.data = av_malloc(track->codec_priv.size + offset);\n<213> memcpy(track->codec_priv.data+offset, codec_priv,\n<217> track->codec_priv.size += offset;\n<221> if (codec_priv != track->codec_priv.data)\n<231> for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n<233> if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n<235> strlen(ff_mkv_codec_tags[j].str))){\n<249> if (st == NULL)\n<255> if (!strcmp(track->codec_id, "V_MS/VFW/FOURCC")\n<257> && track->codec_priv.size >= 40\n<259> && track->codec_priv.data != NULL) {\n<261> track->video.fourcc = AV_RL32(track->codec_priv.data + 16);\n<263> codec_id = codec_get_id(codec_bmp_tags, track->video.fourcc);\n<265> } else if (!strcmp(track->codec_id, "A_MS/ACM")\n<267> && track->codec_priv.size >= 18\n<269> && track->codec_priv.data != NULL) {\n<271> uint16_t tag = AV_RL16(track->codec_priv.data);\n<273> codec_id = codec_get_id(codec_wav_tags, tag);\n<275> } else if (!strcmp(track->codec_id, "V_QUICKTIME")\n<277> && (track->codec_priv.size >= 86)\n<279> && (track->codec_priv.data != NULL)) {\n<281> track->video.fourcc = AV_RL32(track->codec_priv.data);\n<283> codec_id=codec_get_id(codec_movvideo_tags, track->video.fourcc);\n<285> } else if (codec_id == CODEC_ID_PCM_S16BE) {\n<297> } else if (codec_id == CODEC_ID_PCM_S16LE) {\n<309> } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {\n<315> int profile = matroska_aac_profile(track->codec_id);\n<321> if (extradata == NULL)\n<329> if (strstr(track->codec_id, "SBR")) {\n<331> sri = matroska_aac_sri(track->audio.out_samplerate);\n<333> extradata[2] = 0x56;\n<335> extradata[3] = 0xE5;\n<337> extradata[4] = 0x80 | (sri<<3);\n<339> extradata_size = 5;\n<343> extradata_size = 2;\n<345> } else if (codec_id == CODEC_ID_TTA) {\n<353> if (extradata == NULL)\n<377> extradata_offset = 26;\n<423> extradata_offset = 78;\n<433> if (codec_id == CODEC_ID_NONE)\n<441> if (track->time_scale < 0.01)\n<445> av_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */\n<449> st->codec->codec_id = codec_id;\n<451> st->start_time = 0;\n<453> if (strcmp(track->language, "und"))\n<455> av_strlcpy(st->language, track->language, 4);\n<459> if (track->flag_default)\n<465> if (track->default_duration)\n<473> if(extradata){\n<479> } else if(track->codec_priv.data && track->codec_priv.size > 0){\n<481> st->codec->extradata = av_malloc(track->codec_priv.size);\n<483> if(st->codec->extradata == NULL)\n<543> if (!(attachements[j].filename && attachements[j].mime &&\n<547> av_log(matroska->ctx, AV_LOG_ERROR, "incomplete attachment\n");\n<563> st->codec->extradata  = av_malloc(attachements[j].bin.size);\n<565> if(st->codec->extradata == NULL)\n<571> memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);\n<575> for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {\n<577> if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n<579> strlen(ff_mkv_mime_tags[i].str))) {\n<617> av_log(matroska->ctx, AV_LOG_WARNING, "Working around broken index.\n");\n<635> if (track && track->stream)
<1> static int mpeg_decode_mb(MpegEncContext *s,\n<183> s->qscale = get_qscale(s);\n<187> if (s->concealment_motion_vectors) {\n<211> memset(s->last_mv, 0, sizeof(s->last_mv)); /* reset mv prediction */\n<239> if (mpeg2_decode_block_intra(s, s->pblocks[i], i) < 0)\n<249> if (mpeg1_decode_block_intra(s, s->pblocks[i], i) < 0)
<1> int av_open_input_stream(AVFormatContext **ic_ptr,\n<17> if(!ap){\n<19> ap=&default_ap;\n<21> memset(ap, 0, sizeof(default_ap));\n<27> if(!ap->prealloced_context)\n<79> err = ic->iformat->read_header(ic, ap);
<1> static int commit_bitstream_and_slice_buffer(AVCodecContext *avctx,\n<93> static const unsigned start_code_size = sizeof(start_code);\n<121> size     = slice->SliceBytesInBuffer;\n<123> if (start_code_size + size > end - current) {\n<133> slice->BSNALunitDataLocation = current - dxva_data;\n<157> memcpy(current, start_code, start_code_size);\n<159> current += start_code_size;\n<163> memcpy(current, &ctx_pic->bitstream[position], size);\n<165> current += size;\n<169> padding = FFMIN(128 - ((current - dxva_data) & 127), end - current);\n<171> if (slice && padding > 0) {\n<173> memset(current, 0, padding);\n<175> current += padding;\n<179> slice->SliceBytesInBuffer += padding;
<1> void *g_realloc(void *ptr, size_t size)\n<11> if (!ptr)\n<17> copy = old_size < size ? old_size : size;\n<19> new_ptr = g_malloc(size);\n<21> memcpy(new_ptr, ptr, copy);\n<23> g_free(ptr);\n<25> return new_ptr;
<1> static char * strippath ( const char * fullfile ) {\n<4> filename = strdup ( fullfile ) ;\n<5> if ( ! filename ) return NULL ;\n<6> base = strdup ( basename ( filename ) ) ;\n<7> free ( filename ) ;\n<8> return base ;
<1> static void test_bug29306 ( ) {\n<18> while ( ( field = mysql_fetch_field ( res ) ) ) {\n<19> if ( ! opt_silent ) {\n<20> printf ( "field name %s\n" , field -> name ) ;\n<21> printf ( "field table %s\n" , field -> table ) ;\n<22> printf ( "field decimals %d\n" , field -> decimals ) ;\n<23> if ( field -> decimals < 1 ) printf ( "Error! No decimals! \n" ) ;\n<24> printf ( "\n\n" ) ;\n<26> DIE_UNLESS ( field -> decimals == 1 ) ;
<1> static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n<9> char access[11];\n<11> char type[11];\n<31> while (*p) {\n<49> if (ret < 4 || strcmp(access, "RW")) {\n<53> } else if (!strcmp(type, "FLAT")) {\n<55> if (ret != 5 || flat_offset < 0) {\n<63> } else if (!strcmp(type, "VMFS")) {\n<65> if (ret == 4) {\n<77> } else if (ret != 4) {\n<87> if (sectors <= 0 ||\n<89> (strcmp(type, "FLAT") && strcmp(type, "SPARSE") &&\n<91> strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) ||\n<93> (strcmp(access, "RW"))) {\n<111> if (ret) {\n<121> if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) {\n<127> ret = vmdk_add_extent(bs, extent_file, true, sectors,\n<129> 0, 0, 0, 0, 0, &extent, errp);\n<131> if (ret < 0) {\n<140> } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) {\n<144> char *buf = vmdk_read_desc(extent_file, 0, errp);\n<146> if (!buf) {\n<156> if (ret) {\n<169> error_setg(errp, "Unsupported extent type '%s'", type);\n<172> return -ENOTSUP;\n<176> extent->type = g_strdup(type);\n<182> while (*p) {
<1> gpg_error_t keydb_add_resource ( const char * url , unsigned int flags ) {\n<3> const char * resname = url ;\n<12> if ( strlen ( resname ) > 11 && ! strncmp ( resname , "gnupg-ring:" , 11 ) ) {\n<14> resname += 11 ;\n<16> else if ( strlen ( resname ) > 10 && ! strncmp ( resname , "gnupg-kbx:" , 10 ) ) {\n<18> resname += 10 ;
<1> static int check_authkey_line ( struct ssh * ssh , struct passwd * pw , struct sshkey * key , char * cp , const char * loc , struct sshauthopt * * authoptsp ) {\n<5> char * key_options = NULL , * fp = NULL ;\n<38> debug ( "%s: matching %s found: %s %s" , loc , sshkey_is_cert ( key ) ? "CA" : "key" , sshkey_type ( found ) , fp ) ;\n<44> verbose ( "Accepted key %s %s found at %s" , sshkey_type ( found ) , fp , loc ) ;\n<63> verbose ( "Accepted certificate ID \"%s\" (serial %llu) " "signed by CA %s %s found at %s" , key -> cert -> key_id , ( unsigned long long ) key -> cert -> serial , sshkey_type ( found ) , fp , loc ) ;\n<73> out : free ( fp ) ;
<1> static inline void ipv6_addr_prefix ( struct in6_addr * pfx , const struct in6_addr * addr , int plen ) {\n<2> int o = plen >> 3 , b = plen & 0x7 ;\n<3> memset ( pfx -> s6_addr , 0 , sizeof ( pfx -> s6_addr ) ) ;\n<4> memcpy ( pfx -> s6_addr , addr , o ) ;
<1> static int alloc_tables(H264Context *h){\n<17> CHECKED_ALLOCZ(h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(uint8_t))\n<37> memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(uint8_t));\n<39> h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;\n<75> init_dequant_tables(h);
<1> static int test_address_cache ( xd3_stream * stream , int unused ) {\n<13> if ( ( ret = xd3_encode_init_partial ( stream ) ) ) {\n<17> modes = ( uint8_t * ) xd3_alloc ( stream , sizeof ( uint8_t ) , ADDR_CACHE_ROUNDS ) ;\n<18> memset ( mode_counts , 0 , sizeof ( mode_counts ) ) ;\n<19> memset ( modes , 0 , ADDR_CACHE_ROUNDS ) ;\n<24> offset < ADDR_CACHE_ROUNDS ;\n<43> if ( ( ret = xd3_encode_address ( stream , addr , offset , & modes [ offset ] ) ) ) {\n<47> mode_counts [ modes [ offset ] ] += 1 ;\n<49> big_buf = ( uint8_t * ) xd3_alloc ( stream , xd3_sizeof_output ( ADDR_HEAD ( stream ) ) , 1 ) ;\n<50> for ( offset = 0 , outp = ADDR_HEAD ( stream ) ;\n<51> outp != NULL ;\n<52> offset += outp -> next , outp = outp -> next_page ) {\n<53> memcpy ( big_buf + offset , outp -> base , outp -> next ) ;\n<62> if ( ( ret = xd3_decode_address ( stream , offset , modes [ offset ] , & buf , buf_max , & addr ) ) ) {\n<77> if ( mode_counts [ i ] == 0 ) {\n<82> xd3_free ( stream , modes ) ;
<1> static int bethsoftvid_decode_frame(AVCodecContext *avctx,\n<39> dst = vid->frame.data[0];\n<53> yoffset = bytestream_get_le16(&buf);\n<59> dst += vid->frame.linesize[0] * yoffset;\n<67> while((code = *buf++)){\n<75> while(length > remaining){\n<79> bytestream_get_buffer(&buf, dst, remaining);\n<81> else if(block_type == VIDEO_I_FRAME)\n<83> memset(dst, buf[0], remaining);\n<85> length -= remaining;      // decrement the number of bytes to be copied\n<87> dst += remaining + wrap_to_next_line;    // skip over extra bytes at end of frame\n<91> if(dst == frame_end)\n<103> bytestream_get_buffer(&buf, dst, length);\n<105> else if(block_type == VIDEO_I_FRAME)\n<107> memset(dst, *buf++, length);\n<109> remaining -= length;\n<111> dst += length;
<1> int MDC2_Update ( MDC2_CTX * c , const unsigned char * in , size_t len ) {\n<5> if ( len < MDC2_BLOCK - i ) {\n<6> memcpy ( & ( c -> data [ i ] ) , in , len ) ;\n<7> c -> num += ( int ) len ;\n<11> j = MDC2_BLOCK - i ;\n<12> memcpy ( & ( c -> data [ i ] ) , in , j ) ;\n<13> len -= j ;\n<14> in += j ;\n<16> mdc2_body ( c , & ( c -> data [ 0 ] ) , MDC2_BLOCK ) ;\n<20> if ( i > 0 ) mdc2_body ( c , in , i ) ;\n<22> if ( j > 0 ) {\n<23> memcpy ( & ( c -> data [ 0 ] ) , & ( in [ i ] ) , j ) ;\n<24> c -> num = ( int ) j ;
<1> void select_soundhw(const char *optarg)\n<9> if (*optarg == '?') {\n<15> printf("Valid sound card names (comma separated):\n");\n<17> for (c = soundhw; c->name; ++c) {\n<19> printf ("%-11s %s\n", c->name, c->descr);\n<23> printf("\n-soundhw all will enable all of the above\n");\n<41> if (!strcmp(optarg, "all")) {\n<43> for (c = soundhw; c->name; ++c) {\n<49> return;\n<55> p = optarg;\n<57> while (*p) {\n<59> e = strchr(p, ',');\n<61> l = !e ? strlen(p) : (size_t) (e - p);\n<67> if (!strncmp(c->name, p, l) && !c->name[l]) {\n<79> if (!c->name) {\n<81> if (l > 80) {\n<91> fprintf(stderr, "Unknown sound card name `%.*s'\n",\n<101> p += l + (e != NULL);\n<107> if (bad_card) {
<1> static void find_best_state(uint8_t best_state[256][256],\n<39> occ[j] = 1.0;\n<41> for (k = 0; k < 256; k++) {\n<43> double newocc[256] = { 0 };\n<67> newocc[one_state[m]]             += occ[m] * p;\n<69> newocc[256 - one_state[256 - m]] += occ[m] * (1 - p);\n<73> memcpy(occ, newocc, sizeof(occ));
<1> static int archive_read_format_cpio_options ( struct archive_read * a , const char * key , const char * val ) {\n<5> if ( strcmp ( key , "compat-2x" ) == 0 ) {\n<6> cpio -> init_default_conversion = ( val != NULL ) ? 1 : 0 ;\n<7> return ( ARCHIVE_OK ) ;\n<9> else if ( strcmp ( key , "hdrcharset" ) == 0 ) {\n<10> if ( val == NULL || val [ 0 ] == 0 ) archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "cpio: hdrcharset option needs a character-set name" ) ;\n<16> return ( ret ) ;\n<18> return ( ARCHIVE_WARN ) ;
<1> uint8_t *av_packet_pack_dictionary(AVDictionary *dict, int *size)\n<9> *size = 0;\n<19> while ((t = av_dict_get(dict, "", t, AV_DICT_IGNORE_SUFFIX))) {\n<21> const int keylen = strlen(t->key);\n<23> const int valuelen = strlen(t->value);\n<25> const size_t new_size = *size + keylen + 1 + valuelen + 1;\n<31> if (!new_data)\n<35> data = new_data;\n<39> memcpy(data + *size, t->key, keylen + 1);\n<41> memcpy(data + *size + keylen + 1, t->value, valuelen + 1);\n<45> *size = new_size;
<1> static int qio_channel_websock_handshake_process(QIOChannelWebsock *ioc,\n<61> if (!key) {\n<125> if (!g_str_equal(version, QIO_CHANNEL_WEBSOCK_SUPPORTED_VERSION)) {\n<137> if (strlen(key) != QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN) {\n<139> error_setg(errp, "Key length '%zu' was not as expected '%d'",\n<141> strlen(key), QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN);\n<143> return -1;\n<149> if (!g_strrstr(connection, QIO_CHANNEL_WEBSOCK_CONNECTION_UPGRADE)) {\n<169> return qio_channel_websock_handshake_send_response(ioc, key, errp);
<1> static void test_view_insert ( ) {\n<8> const char * query = "insert into v1 values (?)" ;\n<19> rc = mysql_stmt_prepare ( insert_stmt , query , strlen ( query ) ) ;\n<21> query = "select * from t1" ;\n<23> rc = mysql_stmt_prepare ( select_stmt , query , strlen ( query ) ) ;\n<25> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<30> rc = mysql_stmt_bind_param ( insert_stmt , my_bind ) ;
<1> static void send_raw ( int fd , char * buf , int buflen , int user , int cmd , struct query * q ) {\n<4> len = MIN ( sizeof ( packet ) - RAW_HDR_LEN , buflen ) ;\n<5> memcpy ( packet , raw_header , RAW_HDR_LEN ) ;\n<6> if ( len ) {\n<7> memcpy ( & packet [ RAW_HDR_LEN ] , buf , len ) ;\n<9> len += RAW_HDR_LEN ;\n<10> packet [ RAW_HDR_CMD ] = cmd | ( user & 0x0F ) ;\n<11> if ( debug >= 2 ) {\n<12> fprintf ( stderr , "TX-raw: client %s, cmd %d, %d bytes\n" , format_addr ( & q -> from , q -> fromlen ) , cmd , len ) ;\n<14> sendto ( fd , packet , len , 0 , ( struct sockaddr * ) & q -> from , q -> fromlen ) ;
<1> static int mpeg_decode_frame(AVCodecContext *avctx,\n<9> Mpeg1Context *s = avctx->priv_data;\n<99> len = buf_ptr - buf_start;\n<101> if (len + (s->buf_ptr - s->buffer) > s->buffer_size) {\n<113> memcpy(s->buf_ptr, buf_start, len);\n<115> s->buf_ptr += len;
<233> if (!(st->codec->extradata = av_malloc(12 + FF_INPUT_BUFFER_PADDING_SIZE)))\n<239> memcpy(st->codec->extradata, comm_chunk, 12);
<1> static void gen_fcb_excitation ( int16_t * vector , G723_1_Subframe * subfrm , enum Rate cur_rate , int pitch_lag , int index ) {\n<3> memset ( vector , 0 , SUBFRAME_LEN * sizeof ( * vector ) ) ;\n<22> if ( subfrm -> dirac_train == 1 ) gen_dirac_train ( vector , pitch_lag ) ;\n<43> i ++ ) vector [ i ] += beta * vector [ i - lag ] >> 15 ;
<1> static int iso9660_options ( struct archive_write * a , const char * key , const char * value ) {\n<5> switch ( key [ 0 ] ) {\n<6> case 'a' : if ( strcmp ( key , "abstract-file" ) == 0 ) {\n<7> r = get_str_opt ( a , & ( iso9660 -> abstract_file_identifier ) , ABSTRACT_FILE_SIZE , key , value ) ;\n<8> iso9660 -> opt . abstract_file = r == ARCHIVE_OK ;\n<9> return ( r ) ;\n<11> if ( strcmp ( key , "application-id" ) == 0 ) {\n<12> r = get_str_opt ( a , & ( iso9660 -> application_identifier ) , APPLICATION_IDENTIFIER_SIZE , key , value ) ;\n<13> iso9660 -> opt . application_id = r == ARCHIVE_OK ;\n<14> return ( r ) ;\n<16> if ( strcmp ( key , "allow-vernum" ) == 0 ) {\n<17> iso9660 -> opt . allow_vernum = value != NULL ;\n<18> return ( ARCHIVE_OK ) ;\n<21> case 'b' : if ( strcmp ( key , "biblio-file" ) == 0 ) {\n<22> r = get_str_opt ( a , & ( iso9660 -> bibliographic_file_identifier ) , BIBLIO_FILE_SIZE , key , value ) ;\n<23> iso9660 -> opt . biblio_file = r == ARCHIVE_OK ;\n<24> return ( r ) ;\n<26> if ( strcmp ( key , "boot" ) == 0 ) {\n<27> if ( value == NULL ) iso9660 -> opt . boot = 0 ;\n<32> return ( ARCHIVE_OK ) ;\n<34> if ( strcmp ( key , "boot-catalog" ) == 0 ) {\n<35> r = get_str_opt ( a , & ( iso9660 -> el_torito . catalog_filename ) , 1024 , key , value ) ;\n<36> iso9660 -> opt . boot_catalog = r == ARCHIVE_OK ;\n<37> return ( r ) ;\n<39> if ( strcmp ( key , "boot-info-table" ) == 0 ) {\n<40> iso9660 -> opt . boot_info_table = value != NULL ;\n<41> return ( ARCHIVE_OK ) ;\n<43> if ( strcmp ( key , "boot-load-seg" ) == 0 ) {\n<45> iso9660 -> opt . boot_load_seg = 0 ;\n<46> if ( value == NULL ) goto invalid_value ;\n<47> seg = 0 ;\n<48> p = value ;\n<49> if ( p [ 0 ] == '0' && ( p [ 1 ] == 'x' || p [ 1 ] == 'X' ) ) p += 2 ;\n<50> while ( * p ) {\n<57> archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , "Invalid value(over 0xffff) for " "option ``%s''" , key ) ;\n<66> if ( strcmp ( key , "boot-load-size" ) == 0 ) {\n<67> int num = 0 ;\n<68> r = get_num_opt ( a , & num , 0xffff , 1 , key , value ) ;\n<69> iso9660 -> opt . boot_load_size = r == ARCHIVE_OK ;\n<70> if ( r != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ;\n<74> if ( strcmp ( key , "boot-type" ) == 0 ) {\n<75> if ( value == NULL ) goto invalid_value ;\n<76> if ( strcmp ( value , "no-emulation" ) == 0 ) iso9660 -> opt . boot_type = OPT_BOOT_TYPE_NO_EMU ;\n<77> else if ( strcmp ( value , "fd" ) == 0 ) iso9660 -> opt . boot_type = OPT_BOOT_TYPE_FD ;\n<78> else if ( strcmp ( value , "hard-disk" ) == 0 ) iso9660 -> opt . boot_type = OPT_BOOT_TYPE_HARD_DISK ;\n<80> return ( ARCHIVE_OK ) ;
<1> static char * strtok_r ( char * s , const char * delim , char * * state ) {\n<2> return strtok ( s , delim ) ;
<1> static void decode_pitch_vector ( AMRWBContext * ctx , const AMRWBSubFrame * amr_subframe , const int subframe ) {\n<12> ff_acelp_interpolatef ( exc , exc + 1 - pitch_lag_int , ac_inter , 4 , pitch_lag_frac + ( pitch_lag_frac > 0 ? 0 : 4 ) , LP_ORDER , AMRWB_SFR_SIZE + 1 ) ;\n<13> if ( amr_subframe -> ltp ) {\n<14> memcpy ( ctx -> pitch_vector , exc , AMRWB_SFR_SIZE * sizeof ( float ) ) ;\n<19> i ++ ) ctx -> pitch_vector [ i ] = 0.18 * exc [ i - 1 ] + 0.64 * exc [ i ] + 0.18 * exc [ i + 1 ] ;\n<20> memcpy ( exc , ctx -> pitch_vector , AMRWB_SFR_SIZE * sizeof ( float ) ) ;
<1> static void integratorcp_init(QEMUMachineInitArgs *args)\n<39> if (!cpu) {\n<41> fprintf(stderr, "Unable to find CPU definition\n");
<1> static void ctl_putstr ( const char * tag , const char * data , size_t len ) {\n<2> char buffer [ 512 ] ;\n<5> tl = strlen ( tag ) ;\n<6> memcpy ( buffer , tag , tl ) ;\n<7> cp = buffer + tl ;\n<8> if ( len > 0 ) {\n<9> INSIST ( tl + 3 + len <= sizeof ( buffer ) ) ;\n<11> * cp ++ = '"' ;\n<12> memcpy ( cp , data , len ) ;\n<13> cp += len ;\n<16> ctl_putdata ( buffer , ( u_int ) ( cp - buffer ) , 0 ) ;
<1> int gs_main_run_string_begin ( gs_main_instance * minst , int user_errors , int * pexit_code , ref * perror_object ) {\n<2> const char * setup = ".runstringbegin" ;\n<6> make_const_string ( & rstr , avm_foreign | a_readonly | a_executable , strlen ( setup ) , ( const byte * ) setup ) ;
<1> static int scsi_disk_emulate_mode_sense(SCSIDiskReq *r, uint8_t *outbuf)\n<23> DPRINTF("Mode Sense(%d) (page %d, xfer %zd, page_control %d)\n",\n<27> memset(outbuf, 0, r->req.cmd.xfer);\n<29> p = outbuf;\n<149> buflen = p - outbuf;\n<173> if (buflen > r->req.cmd.xfer) {
<1> static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n<21> dprintf("VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\n",\n<25> if (req == NULL) {\n<27> fprintf(stderr, "VSCSI: Can't find request for tag 0x%x\n", tag);\n<39> if (reason == SCSI_REASON_DONE) {\n<49> uint8_t *buf = sdev->info->get_buf(sdev, tag);\n<55> dprintf("VSCSI: Sense data, %d bytes:\n", len);\n<57> dprintf("       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\n",\n<63> dprintf("       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\n",\n<69> memcpy(req->sense, buf, len);\n<71> req->senselen = len;\n<143> if (rc < 0) {\n<145> fprintf(stderr, "VSCSI: RDMA error rc=%d!\n", rc);
<1> static int com_server_help ( String * buffer __attribute__ ( ( unused ) ) , char * line __attribute__ ( ( unused ) ) , char * help_arg ) {\n<16> server_cmd = cmd_buf ;\n<21> if ( ! connected && reconnect ( ) ) return 1 ;\n<22> if ( ( error = mysql_real_query_for_lazy ( server_cmd , ( int ) strlen ( server_cmd ) ) ) || ( error = mysql_store_result_for_lazy ( & result ) ) ) return error ;
<1> int match_re ( my_regex_t * re , char * str ) {\n<2> while ( my_isspace ( charset_info , * str ) ) str ++ ;\n<3> if ( str [ 0 ] == '/' && str [ 1 ] == '*' ) {\n<4> char * comm_end = strstr ( str , "*/" ) ;\n<5> if ( ! comm_end ) die ( "Statement is unterminated comment" ) ;
<54> case WT_RSRC : case WT_RSP : fnam = _warc_rduri ( buf , eoh - buf ) ;\n<55> if ( fnam . len == 0 || fnam . str [ fnam . len - 1 ] == '/' ) {\n<60> if ( fnam . len + 1U > w -> pool . len ) {\n<61> w -> pool . len = ( ( fnam . len + 64U ) / 64U ) * 64U ;\n<62> w -> pool . str = realloc ( w -> pool . str , w -> pool . len ) ;\n<64> memcpy ( w -> pool . str , fnam . str , fnam . len ) ;\n<66> fnam . str = w -> pool . str ;\n<77> case WT_RSRC : case WT_RSP : if ( fnam . len > 0U ) {
<1> void tcg_gen_callN(void *func, TCGTemp *ret, int nargs, TCGTemp **args)\n<125> op = &s->gen_op_buf[i];\n<131> memset(op, 0, offsetof(TCGOp, args));\n<295> tcg_debug_assert(op->calli == real_args);\n<297> tcg_debug_assert(pi <= ARRAY_SIZE(op->args));
<1> static int decode_rle ( AVCodecContext * avctx , AVSubtitle * sub , int rect , const uint8_t * buf , unsigned int buf_size ) {\n<6> if ( ! sub -> rects [ rect ] -> pict . data [ 0 ] ) return - 1 ;\n<7> pixel_count = 0 ;\n<14> if ( color == 0x00 ) {\n<18> color = flags & 0x80 ? bytestream_get_byte ( & buf ) : 0 ;\n<20> if ( run > 0 && pixel_count + run <= sub -> rects [ rect ] -> w * sub -> rects [ rect ] -> h ) {\n<21> memset ( sub -> rects [ rect ] -> pict . data [ 0 ] + pixel_count , color , run ) ;\n<22> pixel_count += run ;\n<25> if ( pixel_count % sub -> rects [ rect ] -> w > 0 ) av_log ( avctx , AV_LOG_ERROR , "Decoded %d pixels, when line should be %d pixels\n" , pixel_count % sub -> rects [ rect ] -> w , sub -> rects [ rect ] -> w ) ;
<1> static int save_xbzrle_page(QEMUFile *f, uint8_t *current_data,\n<15> if (!cache_is_cached(XBZRLE.cache, current_addr)) {\n<41> memcpy(XBZRLE.current_buf, current_data, TARGET_PAGE_SIZE);\n<47> encoded_len = xbzrle_encode_buffer(prev_cached_page, XBZRLE.current_buf,\n<59> } else if (encoded_len == -1) {\n<67> memcpy(prev_cached_page, current_data, TARGET_PAGE_SIZE);\n<77> if (!last_stage) {\n<79> memcpy(prev_cached_page, XBZRLE.current_buf, TARGET_PAGE_SIZE);
<1> int v9fs_device_realize_common(V9fsState *s, Error **errp)\n<59> if (!s->fsconf.tag) {\n<79> len = strlen(s->fsconf.tag);\n<81> if (len > MAX_TAG_LEN - 1) {\n<83> error_setg(errp, "mount tag '%s' (%d bytes) is longer than "\n<93> s->tag = g_strdup(s->fsconf.tag);\n<131> if (s->ops->name_to_path(&s->ctx, NULL, "/", &path) < 0) {\n<135> "error in converting name to path %s", strerror(errno));
<1> static uint32_t CnvExtWrite ( NewConverter * cnvData , const UConverterStaticData * staticData , UNewDataMemory * pData , int32_t tableType ) {\n<72> top += length * 4 ;\n<128> printf ( "size of extension data: %ld\n" , ( long ) top ) ;
<1> static int decode_mb_cavlc(H264Context *h){\n<141> if(IS_INTRA_PCM(mb_type)){\n<207> memset(h->non_zero_count[mb_xy], 16, 16);
<1> static int decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *pkt)\n<133> dst  = c->pic.data[plane_idx]  + 8*by*stride;\n<137> for (bx = 0; bx < bw; bx++, dst += 8, prev += 8) {\n<335> dst[coordmap[*scan++]] = v;\n<341> dst[coordmap[*scan++]] = get_value(c, BINK_SRC_COLORS);\n<349> dst[coordmap[*scan++]] = get_value(c, BINK_SRC_COLORS);\n<435> dst[i*stride + j] = col[v & 1];\n<443> for (i = 0; i < 8; i++)\n<445> memcpy(dst + i*stride, c->bundle[BINK_SRC_COLORS].cur_ptr + i*8, 8);
<1> static int vc1_decode_intra_block(VC1Context *v, int16_t block[64], int n,\n<143> ac_val2 = ac_val;\n<153> ac_val -= 16;\n<157> ac_val -= 16 * s->block_wrap[n];\n<183> if (coded) {\n<317> memset(ac_val2, 0, 16 * 2);\n<321> if (use_pred) {\n<323> memcpy(ac_val2, ac_val, 8 * 2);\n<337> ac_val2[k] = (ac_val2[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<345> if (use_pred) {\n<347> memcpy(ac_val2 + 8, ac_val + 8, 8 * 2);\n<361> ac_val2[k + 8] = (ac_val2[k + 8] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<379> block[k << v->left_blk_sh] = ac_val2[k] * scale;\n<391> block[k << v->top_blk_sh] = ac_val2[k + 8] * scale;
<1> static void __attribute__ ( ( __format__ ( __printf__ , 1 , 0 ) ) ) vwarning ( const char * fmt , va_list ap ) {\n<2> int serrno = errno ;\n<3> ( void ) fprintf ( stderr , "%s: " , progname ) ;\n<4> vfprintf ( stderr , fmt , ap ) ;\n<5> ( void ) fprintf ( stderr , ": %s" , strerror ( serrno ) ) ;
<1> static void json_print_int ( WriterContext * wctx , const char * key , long long int value ) {\n<2> JSONContext * json = wctx -> priv ;\n<4> if ( wctx -> nb_item [ wctx -> level ] ) printf ( "%s" , json -> item_sep ) ;\n<7> printf ( "\"%s\": %lld" , json_escape_str ( & buf , key , wctx ) , value ) ;
<1> static int qcelp_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<4> QCELPContext * q = avctx -> priv_data ;\n<12> if ( ( ret = ff_get_buffer ( avctx , frame , 0 ) ) < 0 ) {\n<25> if ( q -> bitrate > SILENCE ) {\n<30> memset ( & q -> frame , 0 , sizeof ( QCELPFrame ) ) ;\n<55> if ( decode_lspf ( q , quantized_lspf ) < 0 ) {\n<59> apply_pitch_filters ( q , outbuffer ) ;\n<65> decode_lspf ( q , quantized_lspf ) ;\n<66> apply_pitch_filters ( q , outbuffer ) ;\n<73> interpolate_lpc ( q , quantized_lspf , lpc , i ) ;\n<77> postfilter ( q , outbuffer , lpc ) ;\n<78> memcpy ( q -> formant_mem , q -> formant_mem + 160 , 10 * sizeof ( float ) ) ;\n<79> memcpy ( q -> prev_lspf , quantized_lspf , sizeof ( q -> prev_lspf ) ) ;
<1> void web_server_destroy ( void ) {\n<2> if ( bWebServerState == WEB_SERVER_ENABLED ) {\n<4> alias_release ( & gAliasDoc ) ;\n<6> memset ( & gAliasDoc , 0 , sizeof ( struct xml_alias_t ) ) ;
<1> int ff_rtsp_connect(AVFormatContext *s)\n<65> while (option_list) {\n<69> option = ++option_list;\n<71> option_list = strchr(option_list, '&');\n<75> *option_list = 0;\n<81> if (!strcmp(option, "udp")) {\n<83> lower_transport_mask |= (1<< RTSP_LOWER_TRANSPORT_UDP);\n<85> } else if (!strcmp(option, "multicast")) {\n<87> lower_transport_mask |= (1<< RTSP_LOWER_TRANSPORT_UDP_MULTICAST);\n<89> } else if (!strcmp(option, "tcp")) {\n<91> lower_transport_mask |= (1<< RTSP_LOWER_TRANSPORT_TCP);\n<93> } else if(!strcmp(option, "http")) {\n<95> lower_transport_mask |= (1<< RTSP_LOWER_TRANSPORT_TCP);\n<97> rt->control_transport = RTSP_MODE_TUNNEL;\n<105> int len = strlen(option);\n<107> memmove(++filename, option, len);\n<109> filename += len;\n<111> if (option_list) *filename = '&';
<1> static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale){\n<11> memset(state, 128, sizeof(state));\n<17> int len= get_symbol(c, state, 0) + 1;
<1> static int qemu_rdma_reg_control(RDMAContext *rdma, int idx)\n<11> if (rdma->wr_data[idx].control_mr) {\n<19> fprintf(stderr, "qemu_rdma_reg_control failed!\n");
<1> static void flush ( AVCodecContext * avctx ) {\n<5> i < avctx -> channels ;\n<6> i ++ ) memset ( s -> channel [ i ] . out , 0 , s -> samples_per_frame * sizeof ( * s -> channel [ i ] . out ) ) ;
<1> static void pcx_palette(const uint8_t **src, uint32_t *dst, unsigned int pallen) {\n<9> *dst++ = 0xFF000000 | bytestream_get_be24(src);\n<11> if (pallen < 256)\n<13> memset(dst, 0, (256 - pallen) * sizeof(*dst));
<1> gcry_error_t _gcry_sexp_vbuild ( gcry_sexp_t * retsexp , size_t * erroff , const char * format , va_list arg_ptr ) {\n<2> return vsexp_sscan ( retsexp , erroff , format , strlen ( format ) , 1 , NULL , arg_ptr ) ;
<1> static int auth_server_connection_input_line ( struct auth_server_connection * conn , const char * line ) {\n<4> args = t_strsplit_tabescaped ( line ) ;\n<5> if ( args [ 0 ] == NULL ) {\n<9> if ( strcmp ( args [ 0 ] , "OK" ) == 0 ) return auth_server_input_ok ( conn , args + 1 ) ;\n<10> else if ( strcmp ( args [ 0 ] , "CONT" ) == 0 ) return auth_server_input_cont ( conn , args + 1 ) ;\n<11> else if ( strcmp ( args [ 0 ] , "FAIL" ) == 0 ) return auth_server_input_fail ( conn , args + 1 ) ;\n<12> else if ( strcmp ( args [ 0 ] , "MECH" ) == 0 ) return auth_server_input_mech ( conn , args + 1 ) ;\n<13> else if ( strcmp ( args [ 0 ] , "SPID" ) == 0 ) return auth_server_input_spid ( conn , args + 1 ) ;\n<14> else if ( strcmp ( args [ 0 ] , "CUID" ) == 0 ) return auth_server_input_cuid ( conn , args + 1 ) ;\n<15> else if ( strcmp ( args [ 0 ] , "COOKIE" ) == 0 ) return auth_server_input_cookie ( conn , args + 1 ) ;\n<16> else if ( strcmp ( args [ 0 ] , "DONE" ) == 0 ) return auth_server_input_done ( conn ) ;\n<18> i_error ( "Auth server sent unknown command: %s" , args [ 0 ] ) ;\n<19> return - 1 ;
<1> static int write_extradata(FFV1Context *f)\n<17> memset(state2, 128, sizeof(state2));\n<19> memset(state, 128, sizeof(state));\n<37> put_symbol(c, state, f->version, 0);
<1> GList * completion_get_servertags ( const char * word ) {\n<5> g_return_val_if_fail ( word != NULL , NULL ) ;\n<6> len = strlen ( word ) ;\n<12> if ( g_ascii_strncasecmp ( rec -> tag , word , len ) == 0 ) {
<1> void record_peer_stats ( sockaddr_u * addr , int status , double offset , double delay , double dispersion , double jitter ) {\n<7> day = now . l_ui / 86400 + MJD_1900 ;\n<9> if ( peerstats . fp != NULL ) {\n<10> fprintf ( peerstats . fp , "%lu %s %s %x %.9f %.9f %.9f %.9f\n" , day , ulfptoa ( & now , 3 ) , stoa ( addr ) , status , offset , delay , dispersion , jitter ) ;\n<11> fflush ( peerstats . fp ) ;
<1> static int fmtint ( char * * sbuffer , char * * buffer , size_t * currlen , size_t * maxlen , LLONG value , int base , int min , int max , int flags ) {\n<3> const char * prefix = "" ;\n<21> if ( base == 8 ) prefix = "0" ;\n<22> if ( base == 16 ) prefix = "0x" ;\n<33> spadlen = min - OSSL_MAX ( max , place ) - ( signvalue ? 1 : 0 ) - strlen ( prefix ) ;\n<48> prefix ++ ;
<1> static void virtio_ioport_write ( void * opaque , uint32_t addr , uint32_t val ) {\n<5> switch ( addr ) {\n<38> default : fprintf ( stderr , "%s: unexpected address 0x%x value 0x%x\n" , __func__ , addr , val ) ;
<1> static int wma_decode_frame ( WMACodecContext * s , float * * samples , int samples_offset ) {\n<14> ch < s -> avctx -> channels ;\n<16> memcpy ( samples [ ch ] + samples_offset , s -> frame_out [ ch ] , s -> frame_len * sizeof ( * s -> frame_out [ ch ] ) ) ;\n<17> memmove ( & s -> frame_out [ ch ] [ 0 ] , & s -> frame_out [ ch ] [ s -> frame_len ] , s -> frame_len * sizeof ( * s -> frame_out [ ch ] ) ) ;
<1> void aes_crypt_cbc ( aes_context * ctx , int mode , int length , unsigned char iv [ 16 ] , const unsigned char * input , unsigned char * output ) {\n<3> unsigned char temp [ 16 ] ;\n<8> while ( length > 0 ) {\n<9> memcpy ( temp , input , 16 ) ;\n<10> aes_crypt_ecb ( ctx , mode , input , output ) ;\n<13> i ++ ) output [ i ] = ( unsigned char ) ( output [ i ] ^ iv [ i ] ) ;\n<14> memcpy ( iv , temp , 16 ) ;\n<15> input += 16 ;
<1> static void dump_esp_combs ( struct sk_buff * skb , const struct xfrm_tmpl * t ) {\n<4> p = ( struct sadb_prop * ) skb_put ( skb , sizeof ( struct sadb_prop ) ) ;\n<8> memset ( p -> sadb_prop_reserved , 0 , sizeof ( p -> sadb_prop_reserved ) ) ;\n<23> if ( ! ( aalg_tmpl_set ( t , aalg ) && aalg -> available ) ) continue ;\n<24> c = ( struct sadb_comb * ) skb_put ( skb , sizeof ( struct sadb_comb ) ) ;\n<25> memset ( c , 0 , sizeof ( * c ) ) ;\n<27> c -> sadb_comb_auth = aalg -> desc . sadb_alg_id ;\n<28> c -> sadb_comb_auth_minbits = aalg -> desc . sadb_alg_minbits ;\n<29> c -> sadb_comb_auth_maxbits = aalg -> desc . sadb_alg_maxbits ;\n<30> c -> sadb_comb_encrypt = ealg -> desc . sadb_alg_id ;\n<31> c -> sadb_comb_encrypt_minbits = ealg -> desc . sadb_alg_minbits ;\n<32> c -> sadb_comb_encrypt_maxbits = ealg -> desc . sadb_alg_maxbits ;\n<33> c -> sadb_comb_hard_addtime = 24 * 60 * 60 ;\n<34> c -> sadb_comb_soft_addtime = 20 * 60 * 60 ;\n<35> c -> sadb_comb_hard_usetime = 8 * 60 * 60 ;\n<36> c -> sadb_comb_soft_usetime = 7 * 60 * 60 ;
<1> static void check_add_res(HEVCDSPContext h, int bit_depth)\n<17> for (i = 2; i <= 5; i++) {\n<29> randomize_buffers(res0, size);\n<31> randomize_buffers2(dst0, size);\n<33> memcpy(res1, res0, sizeof(*res0) * size);\n<35> memcpy(dst1, dst0, size);\n<39> if (check_func(h.add_residual[i - 2], "add_res_%dx%d_%d", block_size, block_size, bit_depth)) {\n<41> call_ref(dst0, res0, stride);\n<43> call_new(dst1, res1, stride);\n<45> if (memcmp(dst0, dst1, size))\n<47> fail();\n<49> bench_new(dst1, res1, stride);
<1> void rfbClientConnFailed ( rfbClientPtr cl , const char * reason ) {\n<3> int len = strlen ( reason ) ;\n<4> rfbLog ( "rfbClientConnFailed(\"%s\")\n" , reason ) ;\n<5> buf = ( char * ) malloc ( 8 + len ) ;\n<6> ( ( uint32_t * ) buf ) [ 0 ] = Swap32IfLE ( rfbConnFailed ) ;\n<7> ( ( uint32_t * ) buf ) [ 1 ] = Swap32IfLE ( len ) ;\n<8> memcpy ( buf + 8 , reason , len ) ;\n<9> if ( rfbWriteExact ( cl , buf , 8 + len ) < 0 ) rfbLogPerror ( "rfbClientConnFailed: write" ) ;\n<10> free ( buf ) ;
<1> static void pll_delete ( struct proclistlist * pll ) {\n<2> free ( pll -> proclist ) ;\n<3> free ( pll ) ;
<1> void rfbClientConnectionGone ( rfbClientPtr cl ) {\n<22> free ( cl -> beforeEncBuf ) ;\n<23> free ( cl -> afterEncBuf ) ;\n<25> cl -> clientGoneHook ( cl ) ;
<1> static int dtls1_process_out_of_seq_message ( SSL * s , struct hm_header_st * msg_hdr , int * ok ) {\n<7> if ( ( msg_hdr -> frag_off + frag_len ) > msg_hdr -> msg_len ) goto err ;\n<8> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<9> seq64be [ 6 ] = ( unsigned char ) ( msg_hdr -> seq >> 8 ) ;\n<10> seq64be [ 7 ] = ( unsigned char ) msg_hdr -> seq ;\n<11> item = pqueue_find ( s -> d1 -> buffered_messages , seq64be ) ;\n<12> if ( item != NULL && frag_len < msg_hdr -> msg_len ) item = NULL ;\n<13> if ( msg_hdr -> seq <= s -> d1 -> handshake_read_seq || msg_hdr -> seq > s -> d1 -> handshake_read_seq + 10 || item != NULL || ( s -> d1 -> handshake_read_seq == 0 && msg_hdr -> type == SSL3_MT_FINISHED ) ) {\n<22> if ( frag_len && frag_len < msg_hdr -> msg_len ) return dtls1_reassemble_fragment ( s , msg_hdr , ok ) ;\n<24> if ( frag == NULL ) goto err ;\n<25> memcpy ( & ( frag -> msg_header ) , msg_hdr , sizeof ( * msg_hdr ) ) ;\n<26> if ( frag_len ) {\n<28> if ( i <= 0 || ( unsigned long ) i != frag_len ) goto err ;\n<30> memset ( seq64be , 0 , sizeof ( seq64be ) ) ;\n<31> seq64be [ 6 ] = ( unsigned char ) ( msg_hdr -> seq >> 8 ) ;\n<32> seq64be [ 7 ] = ( unsigned char ) ( msg_hdr -> seq ) ;\n<33> item = pitem_new ( seq64be , frag ) ;
<1> int ff_h264_decode_mb_cavlc(H264Context *h){\n<143> if(IS_INTRA_PCM(mb_type)){\n<175> memset(h->non_zero_count[mb_xy], 16, 48);
<1> static inline void xan_wc3_copy_pixel_run(XanContext *s,\n<21> palette_plane = s->current_frame.data[0];\n<23> prev_palette_plane = s->last_frame.data[0];\n<31> curframe_index = y * stride + x;\n<35> prevframe_index = (y + motion_y) * stride + x + motion_x;\n<39> while(pixel_count && (curframe_index < s->frame_size)) {\n<41> int count = FFMIN3(pixel_count, width - curframe_x, width - prevframe_x);\n<45> memcpy(palette_plane + curframe_index, prev_palette_plane + prevframe_index, count);\n<47> pixel_count     -= count;\n<49> curframe_index  += count;\n<51> prevframe_index += count;\n<53> curframe_x      += count;\n<55> prevframe_x     += count;\n<61> curframe_index += line_inc;\n<71> prevframe_index += line_inc;
<1> static int cgfs_nrtasks ( void * hdata ) {\n<24> if ( ! abs_path ) return - 1 ;\n<25> ret = cgroup_recursive_task_count ( abs_path ) ;\n<26> free ( abs_path ) ;
<1> static int sap_read_header(AVFormatContext *s)\n<5> struct SAPState *sap = s->priv_data;\n<53> if (ret)\n<67> ret = ffurl_read(sap->ann_fd, recvbuf, sizeof(recvbuf) - 1);\n<69> if (ret == AVERROR(EAGAIN))\n<79> if (ret < 8) {\n<89> if ((recvbuf[0] & 0xe0) != 0x20) {\n<101> if (recvbuf[0] & 0x04) {\n<127> pos += auth_len * 4;\n<129> if (pos + 4 >= ret) {\n<139> if (strcmp(&recvbuf[pos], MIME) == 0) {\n<141> pos += strlen(MIME) + 1;\n<143> } else if (strncmp(&recvbuf[pos], "v=0\r\n", 5) == 0) {\n<149> av_log(s, AV_LOG_WARNING, "Unsupported mime type %s\n",\n<159> sap->sdp = av_strdup(&recvbuf[pos]);\n<167> av_log(s, AV_LOG_VERBOSE, "SDP:\n%s\n", sap->sdp);\n<169> ffio_init_context(&sap->sdp_pb, sap->sdp, strlen(sap->sdp), 0, NULL, NULL,\n<175> infmt = av_find_input_format("sdp");\n<177> if (!infmt)
<1> static void version ( ) {\n<2> printf ( "icucal version %s (ICU version %s), created by Stephen F. Booth.\n" , CAL_VERSION , U_ICU_VERSION ) ;
<1> TEST ( BuildTime , TimeLooksValid ) {\n<2> char build_time [ ] = "00:00:00" ;\n<3> EXPECT_EQ ( 8u , strlen ( build_time ) ) ;\n<4> EXPECT_EQ ( ':' , build_time [ 2 ] ) ;\n<5> EXPECT_EQ ( ':' , build_time [ 5 ] ) ;
<1> static int vc1_decode_i_block_adv(VC1Context *v, int16_t block[64], int n,\n<121> ac_val2 = ac_val;\n<131> ac_val -= 16;\n<135> ac_val -= 16 * s->block_wrap[n];\n<163> if (coded) {\n<309> memset(ac_val2, 0, 16 * 2);\n<313> if (use_pred) {\n<315> memcpy(ac_val2, ac_val, 8 * 2);\n<329> ac_val2[k] = (ac_val2[k] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<337> if (use_pred) {\n<339> memcpy(ac_val2 + 8, ac_val + 8, 8 * 2);\n<353> ac_val2[k + 8] = (ac_val2[k + 8] * q2 * ff_vc1_dqscale[q1 - 1] + 0x20000) >> 18;\n<371> block[k << v->left_blk_sh] = ac_val2[k] * scale;\n<383> block[k << v->top_blk_sh] = ac_val2[k + 8] * scale;
<1> static int decode_frame(AVCodecContext *avctx,\n<61> out = outdata;\n<68> if (code & 0x80 ) { /* run */\n<69> pix = *buf++;\n<70> if ((out + (257 - code)) > (outdata +  a->pic.linesize[0]))\n<72> memset(out, pix, 257 - code);\n<73> out += 257 - code;\n<79> if (buf_end - buf < code + 1)\n<80> memcpy(out, buf, code + 1);\n<81> out += code + 1;\n<82> buf += code + 1;
<1> static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) {\n<40> get_tile_buffers ( pbi , data , data_end , tile_cols , tile_rows , tile_buffers ) ;\n<41> qsort ( tile_buffers [ 0 ] , tile_cols , sizeof ( tile_buffers [ 0 ] [ 0 ] ) , compare_tile_buffers ) ;\n<44> while ( group_start < tile_cols ) {\n<47> memmove ( tile_buffers [ 0 ] + group_start , tile_buffers [ 0 ] + group_start + 1 , ( group_end - group_start ) * sizeof ( tile_buffers [ 0 ] [ 0 ] ) ) ;\n<48> tile_buffers [ 0 ] [ group_end ] = largest ;
<1> static int64_t load_kernel(void)\n<27> kernel_size = load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys,\n<35> if (kernel_size >= 0) {\n<43> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<61> initrd_size = get_image_size (loaderparams.initrd_filename);\n<67> if (initrd_offset + initrd_size > ram_size) {\n<79> initrd_size = load_image_targphys(loaderparams.initrd_filename,\n<87> if (initrd_size == (target_ulong) -1) {\n<89> fprintf(stderr, "qemu: could not load initial ram disk '%s'\n",
<1> void dtls1_start_timer ( SSL * s ) {\n<3> memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;
<1> static void restore_layer_context ( VP8_COMP * cpi , const int layer ) {\n<2> LAYER_CONTEXT * lc = & cpi -> layer_context [ layer ] ;\n<29> memcpy ( cpi -> mb . count_mb_ref_frame_usage , lc -> count_mb_ref_frame_usage , sizeof ( cpi -> mb . count_mb_ref_frame_usage ) ) ;
<1> static int spapr_phb_init(SysBusDevice *s)\n<5> sPAPRPHBState *sphb = SPAPR_PCI_HOST_BRIDGE(s);\n<19> namebuf = alloca(strlen(sphb->dtbusname) + 32);\n<25> sprintf(namebuf, "%s.mmio", sphb->dtbusname);\n<27> memory_region_init(&sphb->memspace, namebuf, INT64_MAX);\n<31> sprintf(namebuf, "%s.mmio-alias", sphb->dtbusname);\n<33> memory_region_init_alias(&sphb->memwindow, namebuf, &sphb->memspace,\n<59> sprintf(namebuf, "%s.io", sphb->dtbusname);\n<61> memory_region_init(&sphb->iospace, namebuf, SPAPR_PCI_IO_WIN_SIZE);\n<69> sprintf(namebuf, "%s.io-alias", sphb->dtbusname);\n<71> memory_region_init_io(&sphb->iowindow, &spapr_io_ops, sphb,\n<87> if (msi_supported) {\n<89> sprintf(namebuf, "%s.msi", sphb->dtbusname);\n<91> memory_region_init_io(&sphb->msiwindow, &spapr_msi_ops, sphb,\n<105> sphb->busname ? sphb->busname : sphb->dtbusname,\n<125> pci_setup_iommu(bus, spapr_pci_dma_context_fn, sphb);\n<129> QLIST_INSERT_HEAD(&spapr->phbs, sphb, list);
<1> static void SCInterpretPS ( FILE * ps , SplineChar * sc ) {\n<7> while ( isspace ( ch = getc ( ps ) ) ) ;\n<8> ungetc ( ch , ps ) ;\n<9> memset ( & wrapper , 0 , sizeof ( wrapper ) ) ;\n<10> wrapper . advance_width = UNDEFINED_WIDTH ;\n<11> if ( ch != '<' ) {\n<12> pushio ( & wrapper , ps , NULL , 0 ) ;\n<13> if ( nextpstoken ( & wrapper , & dval , tokbuf , sizeof ( tokbuf ) ) != pt_opencurly ) LogError ( _ ( "We don't understand this font\n" ) ) ;\n<16> ( void ) getc ( ps ) ;\n<17> pushfogio ( & wrapper , ps ) ;\n<19> memset ( & ec , '\0' , sizeof ( ec ) ) ;\n<22> _InterpretPS ( & wrapper , & ec , NULL ) ;\n<23> sc -> width = ec . width ;\n<25> SCAppendEntityLayers ( sc , ec . splines ) ;\n<27> sc -> layers [ ly_fore ] . refs = revrefs ( ec . refs ) ;\n<28> free ( wrapper . top ) ;
<1> static int flic_decode_frame_15_16BPP(AVCodecContext *avctx,\n<77> pixels = s->frame.data[0];\n<111> switch (chunk_type) {\n<239> s->frame.linesize[0] * s->avctx->height);\n<275> pixels[pixel_ptr++] = palette_idx1;\n<297> pixels[pixel_ptr++] = palette_idx1;
<1> static int usb_host_handle_iso_data(USBHostDevice *s, USBPacket *p, int in)\n<57> } else if (aurb[i].urb.iso_frame_desc[j].actual_length > p->len) {\n<59> printf("husb: received iso data is larger then packet\n");\n<67> len = aurb[i].urb.iso_frame_desc[j].actual_length;\n<73> j * aurb[i].urb.iso_frame_desc[0].length,\n<83> offset = (j == 0) ? 0 : get_iso_buffer_used(s, p->devep);\n<89> if (len > max_packet_size) {\n<91> printf("husb: send iso data is larger then max packet size\n");\n<101> memcpy(aurb[i].urb.buffer + offset, p->data, len);\n<103> aurb[i].urb.iso_frame_desc[j].length = len;\n<105> offset += len;\n<151> for (i = 0; i < s->iso_urb_count; i++) {\n<157> if (ret < 0) {\n<159> printf("husb error submitting iso urb %d: %d\n", i, errno);\n<161> if (!in || len == 0) {\n<197> return len;
<1> static int selinux_inode_copy_up_xattr ( const char * name ) {\n<2> if ( strcmp ( name , XATTR_NAME_SELINUX ) == 0 ) return 1 ;\n<3> return - EOPNOTSUPP ;
<1> static void dump_map_entry(OutputFormat output_format, MapEntry *e,\n<71> if (!next) {\n<73> printf("]\n");
<1> static void do_subtitle_out(AVFormatContext *s,\n<27> fprintf(stderr, "Subtitle packets must have a pts\n");
<1> int wpa_generate_PTK ( u_char * bssid , u_char * sta , u_char * pmk , u_char * snonce , u_char * anonce , u_int16 bits , u_char * kck ) {\n<4> u_char buff [ 100 ] ;\n<5> size_t offset = sizeof ( "Pairwise key expansion" ) ;\n<6> memset ( buff , 0 , 100 ) ;\n<7> memcpy ( buff , "Pairwise key expansion" , offset ) ;\n<8> if ( memcmp ( sta , bssid , ETH_ADDR_LEN ) < 0 ) {\n<9> memcpy ( buff + offset , sta , ETH_ADDR_LEN ) ;\n<10> memcpy ( buff + offset + ETH_ADDR_LEN , bssid , ETH_ADDR_LEN ) ;\n<13> memcpy ( buff + offset , bssid , ETH_ADDR_LEN ) ;\n<14> memcpy ( buff + offset + ETH_ADDR_LEN , sta , ETH_ADDR_LEN ) ;\n<16> offset += ETH_ADDR_LEN * 2 ;\n<17> if ( memcmp ( snonce , anonce , WPA_NONCE_LEN ) < 0 ) {\n<18> memcpy ( buff + offset , snonce , WPA_NONCE_LEN ) ;\n<19> memcpy ( buff + offset + WPA_NONCE_LEN , anonce , WPA_NONCE_LEN ) ;\n<22> memcpy ( buff + offset , anonce , WPA_NONCE_LEN ) ;\n<23> memcpy ( buff + offset + WPA_NONCE_LEN , snonce , WPA_NONCE_LEN ) ;\n<25> offset += WPA_NONCE_LEN * 2 ;\n<26> memset ( kck , 0 , WPA_PTK_LEN ) ;\n<31> HMAC ( EVP_sha1 ( ) , pmk , WPA_KEY_LEN , buff , 100 , kck + i * 20 , & len ) ;
<1> static void qdev_prop_set_globals_for_type(DeviceState *dev,\n<3> const char *typename)\n<11> for (l = global_props; l; l = l->next) {\n<13> GlobalProperty *prop = l->data;\n<19> if (strcmp(typename, prop->driver) != 0) {\n<25> prop->used = true;\n<27> object_property_parse(OBJECT(dev), prop->value, prop->property, &err);\n<29> if (err != NULL) {\n<31> error_prepend(&err, "can't apply global %s.%s=%s: ",
<1> static int alloc_addbyter ( int output , FILE * data ) {\n<2> struct asprintf * infop = ( struct asprintf * ) data ;\n<4> if ( ! infop -> buffer ) {\n<5> infop -> buffer = malloc ( 32 ) ;\n<6> if ( ! infop -> buffer ) {\n<16> if ( newsize > infop -> alloc ) newptr = realloc ( infop -> buffer , newsize ) ;\n<17> if ( ! newptr ) {\n<22> infop -> alloc = newsize ;
<1> static void test_prepare_ext ( ) {\n<21> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<34> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;
<1> static void decode_band_structure(GetBitContext *gbc, int blk, int eac3,\n<11> int subbnd, bnd, n_subbands, n_bands=0;\n<13> uint8_t bnd_sz[22];\n<57> if (num_bands || band_sizes ) {\n<59> n_bands = n_subbands;\n<61> bnd_sz[0] = ecpl ? 6 : 12;\n<69> n_bands--;\n<71> bnd_sz[bnd] += subbnd_size;\n<75> bnd_sz[++bnd] = subbnd_size;\n<91> if (band_sizes)\n<93> memcpy(band_sizes, bnd_sz, n_bands);
<187> s->residues[i] = *decoded++ >> dshift;\n<191> y    = FF_ARRAY_ELEMS(s->residues) - filter_order;\n<207> v += s->adsp.scalarproduct_int16(&s->residues[i], s->filter,\n<215> s->residues[filter_order + i] = v >> dshift;\n<223> if (x > 0)\n<225> memcpy(s->residues, &s->residues[y], 2 * filter_order);
<1> int tls1_change_cipher_state ( SSL * s , int which ) {\n<22> c = s -> s3 -> tmp . new_sym_enc ;\n<27> printf ( "\talg= %ld/%ld, comp= %p\n" , s -> s3 -> tmp . new_cipher -> algorithm_mkey , s -> s3 -> tmp . new_cipher -> algorithm_auth , comp ) ;\n<28> printf ( "\tevp_cipher == %p ==? &d_cbc_ede_cipher3\n" , c ) ;\n<29> printf ( "\tevp_cipher: nid, blksz= %d, %d, keylen=%d, ivlen=%d\n" , c -> nid , c -> block_size , c -> key_len , c -> iv_len ) ;\n<30> printf ( "\tkey_block: len= %d, data= " , s -> s3 -> tmp . key_block_length ) ;\n<34> i < s -> s3 -> tmp . key_block_length ;\n<35> i ++ ) printf ( "%02x" , s -> s3 -> tmp . key_block [ i ] ) ;\n<36> printf ( "\n" ) ;
<1> void hb_blob_destroy ( hb_blob_t * blob ) {\n<2> if ( ! hb_object_destroy ( blob ) ) return ;\n<3> _hb_blob_destroy_user_data ( blob ) ;\n<4> free ( blob ) ;
<1> void evhttp_parse_query ( const char * uri , struct evkeyvalq * headers ) {\n<6> if ( strchr ( uri , '?' ) == NULL ) return ;\n<7> if ( ( line = strdup ( uri ) ) == NULL ) event_err ( 1 , "%s: strdup" , __func__ ) ;\n<8> argument = line ;\n<9> strsep ( & argument , "?" ) ;\n<10> p = argument ;\n<11> while ( p != NULL && * p != '\0' ) {\n<15> key = strsep ( & value , "=" ) ;\n<16> if ( value == NULL ) goto error ;\n<17> if ( ( decoded_value = malloc ( strlen ( value ) + 1 ) ) == NULL ) event_err ( 1 , "%s: malloc" , __func__ ) ;\n<18> evhttp_decode_uri_internal ( value , strlen ( value ) , decoded_value , 1 ) ;\n<19> event_debug ( ( "Query Param: %s -> %s\n" , key , decoded_value ) ) ;\n<20> evhttp_add_header_internal ( headers , key , decoded_value ) ;\n<21> free ( decoded_value ) ;\n<23> error : free ( line ) ;
<1> ASN1_TYPE * ossl_asn1_get_asn1type ( VALUE obj ) {\n<41> if ( ! ( ret = OPENSSL_malloc ( sizeof ( ASN1_TYPE ) ) ) ) {\n<45> memset ( ret , 0 , sizeof ( ASN1_TYPE ) ) ;\n<46> ASN1_TYPE_set ( ret , tag , ptr ) ;
<1> static void open_output_file ( struct stream_state * stream , struct VpxEncoderConfig * global ) {\n<2> const char * fn = stream -> config . out_fn ;\n<4> if ( cfg -> g_pass == VPX_RC_FIRST_PASS ) return ;\n<5> stream -> file = strcmp ( fn , "-" ) ? fopen ( fn , "wb" ) : set_binary_mode ( stdout ) ;\n<6> if ( ! stream -> file ) fatal ( "Failed to open output file" ) ;
<1> static void test_view_insert_fields ( ) {\n<7> const char * query = "INSERT INTO `v1` ( `K1C4` ,`K2C4` ,`K3C4` ,`K4N4` ,`F1C4` ,`F2I4` ,`F3N5` ,`F7F8` ,`F6N4` ,`F5C8` ,`F9D8` ) VALUES( ? , ? , ? , ? , ? , ? , ? , ? , ? , ? , ? )" ;\n<16> memset ( my_bind , 0 , sizeof ( my_bind ) ) ;\n<28> stmt = mysql_stmt_init ( mysql ) ;\n<29> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<30> check_execute ( stmt , rc ) ;\n<31> rc = mysql_stmt_bind_param ( stmt , my_bind ) ;\n<36> query = "select * from t1" ;\n<37> stmt = mysql_stmt_init ( mysql ) ;\n<38> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<39> check_execute ( stmt , rc ) ;
<1> static inline void encode_mb_hq ( MpegEncContext * s , MpegEncContext * backup , MpegEncContext * best , int type , PutBitContext pb [ 2 ] , PutBitContext pb2 [ 2 ] , PutBitContext tex_pb [ 2 ] , int * dmin , int * next_block , int motion_x , int motion_y ) {\n<3> uint8_t * dest_backup [ 3 ] ;\n<4> copy_context_before_encode ( s , backup , type ) ;\n<11> if ( * next_block ) {\n<12> memcpy ( dest_backup , s -> dest , sizeof ( s -> dest ) ) ;\n<13> s -> dest [ 0 ] = s -> rd_scratchpad ;\n<14> s -> dest [ 1 ] = s -> rd_scratchpad + 16 * s -> linesize ;\n<15> s -> dest [ 2 ] = s -> rd_scratchpad + 16 * s -> linesize + 8 ;\n<18> encode_mb ( s , motion_x , motion_y ) ;\n<25> ff_MPV_decode_mb ( s , s -> block ) ;\n<27> score += sse_mb ( s ) << FF_LAMBDA_SHIFT ;\n<29> if ( * next_block ) {\n<30> memcpy ( s -> dest , dest_backup , sizeof ( s -> dest ) ) ;\n<35> copy_context_after_encode ( best , s , type ) ;
<1> int nntp_post ( const char * msg ) {\n<13> if ( ! fp ) {\n<18> if ( nntp_query ( nntp_data , buf , sizeof ( buf ) ) < 0 ) {\n<22> if ( buf [ 0 ] != '3' ) {\n<27> buf [ 0 ] = '.' ;\n<28> buf [ 1 ] = '\0' ;\n<29> while ( fgets ( buf + 1 , sizeof ( buf ) - 2 , fp ) ) {\n<30> size_t len = strlen ( buf ) ;\n<31> if ( buf [ len - 1 ] == '\n' ) {\n<32> buf [ len - 1 ] = '\r' ;\n<35> buf [ len ] = '\0' ;\n<37> if ( mutt_socket_send_d ( nntp_data -> nserv -> conn , buf [ 1 ] == '.' ? buf : buf + 1 , MUTT_SOCK_LOG_HDR ) < 0 ) {\n<38> mutt_file_fclose ( & fp ) ;\n<42> mutt_file_fclose ( & fp ) ;\n<43> if ( ( buf [ strlen ( buf ) - 1 ] != '\n' && mutt_socket_send_d ( nntp_data -> nserv -> conn , "\r\n" , MUTT_SOCK_LOG_HDR ) < 0 ) || mutt_socket_send_d ( nntp_data -> nserv -> conn , ".\r\n" , MUTT_SOCK_LOG_HDR ) < 0 || mutt_socket_readln ( buf , sizeof ( buf ) , nntp_data -> nserv -> conn ) < 0 ) {\n<44> return nntp_connect_error ( nntp_data -> nserv ) ;\n<46> if ( buf [ 0 ] != '2' ) {\n<47> mutt_error ( _ ( "Can't post article: %s" ) , buf ) ;
<1> static int coreaudio_init_out (HWVoiceOut *hw, struct audsettings *as)\n<21> err = pthread_mutex_init(&core->mutex, NULL);\n<23> if (err) {\n<25> dolog("Could not create mutex\nReason: %s\n", strerror (err));
<1> static void decorrelation(PSContext *ps, INTFLOAT (*out)[32][2], const INTFLOAT (*s)[32][2], int is34)\n<31> int n0 = 0, nL = 32;\n<37> memset(power, 0, 34 * sizeof(*power));\n<41> if (is34 != ps->is34bands_old) {\n<43> memset(ps->peak_decay_nrg,         0, sizeof(ps->peak_decay_nrg));\n<45> memset(ps->power_smooth,           0, sizeof(ps->power_smooth));\n<47> memset(ps->peak_decay_diff_smooth, 0, sizeof(ps->peak_decay_diff_smooth));\n<49> memset(ps->delay,                  0, sizeof(ps->delay));\n<51> memset(ps->ap_delay,               0, sizeof(ps->ap_delay));\n<61> ps->dsp.add_squares(power[i], s[k], nL - n0);\n<125> for (n = n0; n < nL; n++) {\n<167> for (k = 0; k < NR_ALLPASS_BANDS[is34]; k++) {\n<203> memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));\n<205> memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));\n<207> for (m = 0; m < PS_AP_LINKS; m++) {\n<209> memcpy(ap_delay[k][m],   ap_delay[k][m]+numQMFSlots,           5*sizeof(ap_delay[k][m][0]));\n<213> ps->dsp.decorrelate(out[k], delay[k] + PS_MAX_DELAY - 2, ap_delay[k],\n<219> transient_gain[b], g_decay_slope, nL - n0);\n<223> for (; k < SHORT_DELAY_BAND[is34]; k++) {\n<227> memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));\n<229> memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));\n<233> ps->dsp.mul_pair_single(out[k], delay[k] + PS_MAX_DELAY - 14,\n<235> transient_gain[i], nL - n0);\n<239> for (; k < NR_BANDS[is34]; k++) {\n<243> memcpy(delay[k], delay[k]+nL, PS_MAX_DELAY*sizeof(delay[k][0]));\n<245> memcpy(delay[k]+PS_MAX_DELAY, s[k], numQMFSlots*sizeof(delay[k][0]));\n<249> ps->dsp.mul_pair_single(out[k], delay[k] + PS_MAX_DELAY - 1,\n<251> transient_gain[i], nL - n0);
<1> static inline int decode_alpha_block(const SHQContext *s, GetBitContext *gb, uint8_t last_alpha[16], uint8_t *dest, int linesize)\n<11> memset(block, 0, sizeof(block));\n<59> for (y = 0; y < 8; y++) {\n<63> last_alpha[x] -= block[y * 16 + x];\n<67> memcpy(dest, last_alpha, 16);\n<69> dest += linesize;
<1> static void unixWarningHandler ( const char * module , const char * fmt , va_list ap ) {\n<2> if ( module != NULL ) fprintf ( stderr , "%s: " , module ) ;\n<3> fprintf ( stderr , "Warning, " ) ;\n<4> vfprintf ( stderr , fmt , ap ) ;\n<5> fprintf ( stderr , ".\n" ) ;
<1> static int isoent_make_sorted_files ( struct archive_write * a , struct isoent * isoent , struct idr * idr ) {\n<4> children = malloc ( isoent -> children . cnt * sizeof ( struct isoent * ) ) ;\n<5> if ( children == NULL ) {
<1> static int mxf_read_partition_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n<19> if (!tmp_part)\n<23> mxf->partitions = tmp_part;\n<27> if (mxf->parsing_backward) {\n<33> memmove(&mxf->partitions[mxf->last_forward_partition+1],\n<37> (mxf->partitions_count - mxf->last_forward_partition)*sizeof(*mxf->partitions));\n<39> partition = mxf->current_partition = &mxf->partitions[mxf->last_forward_partition];\n<45> partition = mxf->current_partition = &mxf->partitions[mxf->partitions_count];\n<51> memset(partition, 0, sizeof(*partition));\n<91> partition->closed = partition->type == Footer || !(uid[14] & 1);\n<163> mxf->run_in + partition->previous_partition >= klv_offset) {\n<237> if (partition->kag_size <= 0 || partition->kag_size > (1 << 20)) {\n<239> av_log(mxf->fc, AV_LOG_WARNING, "invalid KAGSize %i - guessing ", partition->kag_size);\n<253> av_log(mxf->fc, AV_LOG_WARNING, "%i\n", partition->kag_size);
<1> static void s390_init(ram_addr_t ram_size,\n<7> const char *kernel_cmdline,\n<33> if (!kvm_enabled()) {\n<35> fprintf(stderr, "The S390 target only works with KVM enabled\n");\n<107> if (lduw_phys(KERN_IMAGE_START) != 0x0dd0) {\n<109> fprintf(stderr, "Specified image is not an s390 boot image\n");\n<192> if (kernel_cmdline) {\n<194> cpu_physical_memory_rw(KERN_PARM_AREA, (uint8_t *)kernel_cmdline,\n<196> strlen(kernel_cmdline), 1);\n<204> for(i = 0; i < nb_nics; i++) {\n<206> NICInfo *nd = &nd_table[i];\n<212> if (!nd->model) {\n<214> nd->model = qemu_strdup("virtio");\n<220> if (strcmp(nd->model, "virtio")) {\n<222> fprintf(stderr, "S390 only supports VirtIO nics\n");\n<224> exit(1);\n<232> qdev_set_nic_properties(dev, nd);
<1> static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,\n<12> memset(block, 0, 64 * sizeof(DCTELEM));
<1> int SFHasInstructions ( SplineFont * sf ) {\n<6> i < sf -> glyphcnt ;\n<7> ++ i ) if ( sf -> glyphs [ i ] != NULL ) {\n<8> if ( strcmp ( sf -> glyphs [ i ] -> name , ".notdef" ) == 0 ) continue ;\n<9> if ( sf -> glyphs [ i ] -> ttf_instrs != NULL ) return ( true ) ;
<1> static void identify_locking_dependencies ( ArchiveHandle * AH , TocEntry * te ) {\n<5> if ( te -> nDeps == 0 ) return ;\n<6> if ( ! ( strcmp ( te -> desc , "CONSTRAINT" ) == 0 || strcmp ( te -> desc , "CHECK CONSTRAINT" ) == 0 || strcmp ( te -> desc , "FK CONSTRAINT" ) == 0 || strcmp ( te -> desc , "RULE" ) == 0 || strcmp ( te -> desc , "TRIGGER" ) == 0 ) ) return ;\n<7> lockids = ( DumpId * ) pg_malloc ( te -> nDeps * sizeof ( DumpId ) ) ;\n<8> nlockids = 0 ;\n<9> for ( i = 0 ;\n<10> i < te -> nDeps ;\n<13> if ( depid <= AH -> maxDumpId && AH -> tocsByDumpId [ depid ] != NULL && ( ( strcmp ( AH -> tocsByDumpId [ depid ] -> desc , "TABLE DATA" ) == 0 ) || strcmp ( AH -> tocsByDumpId [ depid ] -> desc , "TABLE" ) == 0 ) ) lockids [ nlockids ++ ] = depid ;\n<15> if ( nlockids == 0 ) {\n<16> free ( lockids ) ;
<1> static void flat_print_str ( WriterContext * wctx , const char * key , const char * value ) {\n<4> printf ( "%s" , wctx -> section_pbuf [ wctx -> level ] . str ) ;\n<6> printf ( "%s=" , flat_escape_key_str ( & buf , key , flat -> sep ) ) ;\n<8> printf ( "\"%s\"\n" , flat_escape_value_str ( & buf , value ) ) ;
<1> VirtIODevice * virtio_net_init ( DeviceState * dev , NICConf * conf , virtio_net_conf * net ) {\n<12> if ( net -> tx && strcmp ( net -> tx , "timer" ) && strcmp ( net -> tx , "bh" ) ) {\n<13> error_report ( "virtio-net: " "Unknown option tx=%s, valid options: \"timer\" \"bh\"" , net -> tx ) ;\n<14> error_report ( "Defaulting to \"bh\"" ) ;\n<16> if ( net -> tx && ! strcmp ( net -> tx , "timer" ) ) {\n<17> n -> tx_vq = virtio_add_queue ( & n -> vdev , 256 , virtio_net_handle_tx_timer ) ;\n<18> n -> tx_timer = qemu_new_timer_ns ( vm_clock , virtio_net_tx_timer , n ) ;\n<19> n -> tx_timeout = net -> txtimer ;\n<22> n -> tx_vq = virtio_add_queue ( & n -> vdev , 256 , virtio_net_handle_tx_bh ) ;\n<23> n -> tx_bh = qemu_bh_new ( virtio_net_tx_bh , n ) ;\n<26> qemu_macaddr_default_if_unset ( & conf -> macaddr ) ;\n<27> memcpy ( & n -> mac [ 0 ] , & conf -> macaddr , sizeof ( n -> mac ) ) ;
<1> static uint32_t openpic_iack ( OpenPICState * opp , IRQDest * dst , int cpu ) {\n<8> if ( irq == - 1 ) {\n<11> src = & opp -> src [ irq ] ;\n<12> if ( ! ( src -> ivpr & IVPR_ACTIVITY_MASK ) || ! ( IVPR_PRIORITY ( src -> ivpr ) > dst -> ctpr ) ) {\n<13> fprintf ( stderr , "%s: bad raised IRQ %d ctpr %d ivpr 0x%08x\n" , __func__ , irq , dst -> ctpr , src -> ivpr ) ;\n<14> openpic_update_irq ( opp , irq ) ;\n<22> src -> ivpr &= ~ IVPR_ACTIVITY_MASK ;\n<31> src -> ivpr |= IVPR_ACTIVITY_MASK ;
<1> void test_clone(void)\n<11> stack1 = malloc(STACK_SIZE);\n<13> pid1 = chk_error(clone(thread1_func, stack1 + STACK_SIZE,\n<19> stack2 = malloc(STACK_SIZE);\n<21> pid2 = chk_error(clone(thread2_func, stack2 + STACK_SIZE,
<1> char * rfbProcessFileTransferReadBuffer ( rfbClientPtr cl , uint32_t length ) {\n<5> if ( length > 0 ) {\n<6> buffer = malloc ( length + 1 ) ;\n<7> if ( buffer != NULL ) {\n<11> if ( buffer != NULL ) free ( buffer ) ;
<1> static int vmdk_write(BlockDriverState *bs, int64_t sector_num,\n<61> if (ret == 0) {
<1> int web_server_set_alias ( const char * alias_name , const char * alias_content , size_t alias_content_length , time_t last_modified ) {\n<8> assert ( alias_content != NULL ) ;\n<11> alias . ct = NULL ;\n<13> if ( * alias_name != '/' ) if ( membuffer_assign_str ( & alias . name , "/" ) != 0 ) break ;\n<15> if ( ret_code != 0 ) break ;\n<16> if ( ( alias . ct = ( int * ) malloc ( sizeof ( int ) ) ) == NULL ) break ;\n<17> * alias . ct = 1 ;\n<18> membuffer_attach ( & alias . doc , ( char * ) alias_content , alias_content_length ) ;\n<19> alias . last_modified = last_modified ;\n<20> ithread_mutex_lock ( & gWebMutex ) ;\n<21> gAliasDoc = alias ;\n<22> ithread_mutex_unlock ( & gWebMutex ) ;\n<23> return 0 ;\n<26> membuffer_destroy ( & alias . name ) ;\n<27> membuffer_destroy ( & alias . doc ) ;\n<28> free ( alias . ct ) ;\n<29> return UPNP_E_OUTOF_MEMORY ;
<1> static int16_t findOffset ( const char * const * list , const char * key ) {\n<3> while ( * list != NULL ) {\n<4> if ( strcmp ( key , * list ) == 0 ) {\n<5> return ( int16_t ) ( list - anchor ) ;\n<7> list ++ ;
<1> static int parse_video_var ( AVFormatContext * avctx , AVStream * st , const char * name , int size ) {\n<3> if ( ! strcmp ( name , "__DIR_COUNT" ) ) {\n<4> st -> nb_frames = st -> duration = var_read_int ( pb , size ) ;\n<6> else if ( ! strcmp ( name , "COMPRESSION" ) ) {\n<7> char * str = var_read_string ( pb , size ) ;\n<8> if ( ! str ) return AVERROR_INVALIDDATA ;\n<9> if ( ! strcmp ( str , "1" ) ) {\n<10> st -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ;\n<12> else if ( ! strcmp ( str , "2" ) ) {\n<13> st -> codecpar -> format = AV_PIX_FMT_ABGR ;\n<14> st -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ;\n<16> else if ( ! strcmp ( str , "3" ) ) {\n<17> st -> codecpar -> codec_id = AV_CODEC_ID_SGIRLE ;\n<19> else if ( ! strcmp ( str , "10" ) ) {\n<20> st -> codecpar -> codec_id = AV_CODEC_ID_MJPEG ;\n<22> else if ( ! strcmp ( str , "MVC2" ) ) {\n<23> st -> codecpar -> codec_id = AV_CODEC_ID_MVC2 ;\n<26> avpriv_request_sample ( avctx , "Video compression %s" , str ) ;\n<28> av_free ( str ) ;\n<30> else if ( ! strcmp ( name , "FPS" ) ) {\n<31> AVRational fps = var_read_float ( pb , size ) ;\n<32> avpriv_set_pts_info ( st , 64 , fps . den , fps . num ) ;\n<33> st -> avg_frame_rate = fps ;\n<35> else if ( ! strcmp ( name , "HEIGHT" ) ) {\n<36> st -> codecpar -> height = var_read_int ( pb , size ) ;\n<38> else if ( ! strcmp ( name , "PIXEL_ASPECT" ) ) {\n<39> st -> sample_aspect_ratio = var_read_float ( pb , size ) ;\n<40> av_reduce ( & st -> sample_aspect_ratio . num , & st -> sample_aspect_ratio . den , st -> sample_aspect_ratio . num , st -> sample_aspect_ratio . den , INT_MAX ) ;\n<42> else if ( ! strcmp ( name , "WIDTH" ) ) {\n<43> st -> codecpar -> width = var_read_int ( pb , size ) ;\n<45> else if ( ! strcmp ( name , "ORIENTATION" ) ) {\n<46> if ( var_read_int ( pb , size ) == 1101 ) {\n<51> else if ( ! strcmp ( name , "Q_SPATIAL" ) || ! strcmp ( name , "Q_TEMPORAL" ) ) {\n<52> var_read_metadata ( avctx , name , size ) ;\n<54> else if ( ! strcmp ( name , "INTERLACING" ) || ! strcmp ( name , "PACKING" ) ) {\n<55> avio_skip ( pb , size ) ;\n<57> else return AVERROR_INVALIDDATA ;\n<58> return 0 ;
<1> static int qcow_snapshot_create(BlockDriverState *bs,\n<7> BDRVQcowState *s = bs->opaque;\n<9> QCowSnapshot *snapshots1, sn1, *sn = &sn1;\n<17> memset(sn, 0, sizeof(*sn));\n<41> if (!sn->id_str)\n<47> if (!sn->name)\n<105> if (!snapshots1)\n<109> memcpy(snapshots1, s->snapshots, s->nb_snapshots * sizeof(QCowSnapshot));\n<112> s->snapshots = snapshots1;\n<132> qemu_free(sn->name);
<1> static void process_ls_ref ( struct remote_ls_ctx * ls ) {\n<2> if ( ! strcmp ( ls -> path , ls -> dentry_name ) && ( ls -> dentry_flags & IS_DIR ) ) {\n<3> fprintf ( stderr , " %s\n" , ls -> dentry_name ) ;\n<4> return ;\n<6> if ( ! ( ls -> dentry_flags & IS_DIR ) ) one_remote_ref ( ls -> dentry_name ) ;
<1> int qcow2_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)\n<5> BDRVQcowState *s = bs->opaque;\n<17> if (snapshot_index < 0) {\n<33> (s->nb_snapshots - snapshot_index - 1) * sizeof(sn));
<1> static void dumpDatabases ( PGconn * conn ) {\n<7> i < PQntuples ( res ) ;\n<10> char * dbname = PQgetvalue ( res , i , 0 ) ;\n<12> if ( verbose ) fprintf ( stderr , _ ( "%s: dumping database \"%s\"...\n" ) , progname , dbname ) ;\n<13> initPQExpBuffer ( & connectbuf ) ;\n<14> appendPsqlMetaConnect ( & connectbuf , dbname ) ;\n<15> fprintf ( OPF , "%s\n" , connectbuf . data ) ;\n<16> termPQExpBuffer ( & connectbuf ) ;\n<20> ret = runPgDump ( dbname ) ;\n<21> if ( ret != 0 ) {\n<22> fprintf ( stderr , _ ( "%s: pg_dump failed on database \"%s\", exiting\n" ) , progname , dbname ) ;\n<26> OPF = fopen ( filename , PG_BINARY_A ) ;\n<27> if ( ! OPF ) {\n<28> fprintf ( stderr , _ ( "%s: could not re-open the output file \"%s\": %s\n" ) , progname , filename , strerror ( errno ) ) ;
<1> static uint32_t vmdk_read_cid(BlockDriverState *bs, int parent)\n<17> if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n<27> cid_str = "parentCID";\n<33> cid_str = "CID";\n<41> p_name = strstr(desc, cid_str);\n<43> if (p_name != NULL) {\n<45> p_name += cid_str_size;\n<47> sscanf(p_name, "%x", &cid);\n<53> return cid;
<1> static void wait_for_serial(const char *side)\n<5> char *serialpath = g_strdup_printf("%s/%s", tmpfs, side);\n<9> const char *arch = qtest_get_arch();\n<11> int started = (strcmp(side, "src_serial") == 0 &&\n<13> strcmp(arch, "ppc64") == 0) ? 0 : 1;\n<19> int readvalue = fgetc(serialfile);\n<23> if (!started) {\n<55> switch (readvalue) {\n<79> started = (strcmp(side, "src_serial") == 0 &&\n<81> strcmp(arch, "ppc64") == 0) ? 0 : 1;\n<93> fprintf(stderr, "Unexpected %d on %s serial\n", readvalue, side);
<1> static int ftp_send_command(FTPContext *s, const char *command,\n<5> ff_dlog(s, "%s", command);\n<8> if ((err = ffurl_write(s->conn_control, command, strlen(command))) < 0)\n<14> return ftp_status(s, response, response_codes);
<1> extern List as_mysql_get_clusters ( mysql_conn_t * mysql_conn , uid_t uid , slurmdb_cluster_cond_t * cluster_cond ) {\n<39> if ( ! ( result = mysql_db_query_ret ( mysql_conn , query , 0 ) ) ) {\n<45> memset ( & assoc_cond , 0 , sizeof ( slurmdb_assoc_cond_t ) ) ;\n<94> assoc_list = as_mysql_get_assocs ( mysql_conn , uid , & assoc_cond ) ;\n<95> FREE_NULL_LIST ( assoc_cond . cluster_list ) ;\n<96> FREE_NULL_LIST ( assoc_cond . acct_list ) ;\n<97> FREE_NULL_LIST ( assoc_cond . user_list ) ;
<1> static void cleanup_and_exit ( int exit_code ) {\n<7> switch ( exit_code ) {\n<8> case 1 : printf ( "not ok\n" ) ;\n<10> case 0 : printf ( "ok\n" ) ;\n<12> case 62 : printf ( "skipped\n" ) ;\n<14> default : printf ( "unknown exit code: %d\n" , exit_code ) ;\n<19> exit ( exit_code ) ;
<1> void vhost_dev_stop(struct vhost_dev *hdev, VirtIODevice *vdev)\n<27> if (r < 0) {\n<29> fprintf(stderr, "vhost guest notifier cleanup failed: %d\n", r);\n<31> fflush(stderr);\n<35> assert (r >= 0);
<81> if ((ret = alloc_picture(h, pic)) < 0)\n<133> for (i = 0; i < h->slice_context_count; i++)\n<151> memset(h->slice_table, -1,\n<153> (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));
<1> int _TIFFmemcmp ( const void * p1 , const void * p2 , tmsize_t c ) {\n<2> return ( memcmp ( p1 , p2 , ( size_t ) c ) ) ;
<1> static int spapr_nvram_init(VIOsPAPRDevice *dev)\n<23> if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {\n<25> fprintf(stderr, "spapr-nvram must be between %d and %d bytes in size\n",
<1> static void do_audio_out(AVFormatContext *s, OutputStream *ost,\n<21> uint8_t *buf = decoded_frame->data[0];\n<23> int size     = decoded_frame->nb_samples * dec->channels * isize;\n<197> if (byte_delta < 0) {\n<217> av_fast_malloc(&async_buf, &allocated_async_buf_size,\n<243> generate_silence(async_buf, dec->sample_fmt, byte_delta);\n<245> memcpy(async_buf + byte_delta, buf, size);\n<249> size += byte_delta;
<1> TSReturnCode TSMimeHdrFieldValueStringInsert ( TSMBuffer bufp , TSMLoc hdr , TSMLoc field , int idx , const char * value , int length ) {\n<9> if ( length == - 1 ) {\n<10> length = strlen ( value ) ;\n<12> TSMimeFieldValueInsert ( bufp , field , value , length , idx ) ;
<1> void rfbClientSendString ( rfbClientPtr cl , const char * reason ) {\n<3> int len = strlen ( reason ) ;\n<4> rfbLog ( "rfbClientSendString(\"%s\")\n" , reason ) ;\n<5> buf = ( char * ) malloc ( 4 + len ) ;\n<6> ( ( uint32_t * ) buf ) [ 0 ] = Swap32IfLE ( len ) ;\n<7> memcpy ( buf + 4 , reason , len ) ;\n<8> if ( rfbWriteExact ( cl , buf , 4 + len ) < 0 ) rfbLogPerror ( "rfbClientSendString: write" ) ;\n<9> free ( buf ) ;
<1> static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n<3> char part[3][512], int part_size, int *print_prefix, int type[2])\n<9> part[0][0] = part[1][0] = part[2][0] = 0;\n<43> vsnprintf(part[2], part_size, fmt, vl);\n<47> *print_prefix = strlen(part[2]) && part[2][strlen(part[2]) - 1] == '\n';
<1> int evbuffer_expand ( struct evbuffer * buf , size_t datlen ) {\n<6> if ( buf -> totallen - buf -> off >= datlen ) {\n<15> while ( length < need ) {\n<20> length = need ;\n<22> if ( buf -> orig_buffer != buf -> buffer ) evbuffer_align ( buf ) ;\n<23> if ( ( newbuf = realloc ( buf -> buffer , length ) ) == NULL ) return ( - 1 ) ;\n<24> buf -> orig_buffer = buf -> buffer = newbuf ;\n<25> buf -> totallen = length ;\n<27> return ( 0 ) ;
<1> static int decode_thread(void *arg)\n<5> VideoState *is = arg;\n<15> AVFormatParameters params, *ap = &params;\n<27> memset(st_index, -1, sizeof(st_index));\n<29> is->video_stream = -1;\n<31> is->audio_stream = -1;\n<33> is->subtitle_stream = -1;\n<43> memset(ap, 0, sizeof(*ap));\n<63> err = av_open_input_file(&ic, is->filename, is->iformat, 0, ap);\n<87> if (err < 0) {\n<89> fprintf(stderr, "%s: could not find codec parameters\n", is->filename);\n<127> if (ret < 0) {\n<129> fprintf(stderr, "%s: could not seek to position %0.3f\n",\n<131> is->filename, (double)timestamp / AV_TIME_BASE);\n<171> (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n<181> av_dump_format(ic, 0, is->filename, 0);\n<189> if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {\n<191> stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);\n<199> if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n<201> ret= stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);\n<205> is->refresh_tid = SDL_CreateThread(refresh_thread, is);\n<217> if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {\n<219> stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);\n<225> if (is->video_stream < 0 && is->audio_stream < 0) {\n<227> fprintf(stderr, "%s: could not open codecs\n", is->filename);\n<287> ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n<289> if (ret < 0) {\n<291> fprintf(stderr, "%s: error while seeking\n", is->ic->filename);\n<459> stream_component_close(is, is->audio_stream);\n<463> stream_component_close(is, is->video_stream);\n<467> stream_component_close(is, is->subtitle_stream);\n<471> av_close_input_file(is->ic);\n<489> event.user.data1 = is;
<1> av_cold static int auto_matrix(SwrContext *s)\n<23> out_ch_layout = clean_layout(s, s->out_ch_layout);\n<59> if(!sane_layout(out_ch_layout)){\n<71> memset(s->matrix, 0, sizeof(s->matrix));
<1> static void init_loop_filter ( Vp3DecodeContext * s ) {\n<8> memset ( s -> bounding_values_array , 0 , 256 * sizeof ( int ) ) ;
<1> static int usb_net_handle_datain(USBNetState *s, USBPacket *p)\n<19> if (!s->in_len) {\n<29> if (ret > p->len)\n<31> ret = p->len;\n<33> memcpy(p->data, &s->in_buf[s->in_ptr], ret);\n<35> s->in_ptr += ret;\n<39> (is_rndis(s) || (s->in_len & (64 - 1)) || !ret)) {\n<77> return ret;
<1> int DSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int siglen , DSA * dsa ) {\n<4> unsigned char * der = NULL ;\n<9> if ( d2i_DSA_SIG ( & s , & p , siglen ) == NULL ) goto err ;\n<10> derlen = i2d_DSA_SIG ( s , & der ) ;\n<11> if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) goto err ;\n<12> ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ;\n<13> err : if ( derlen > 0 ) {\n<14> OPENSSL_cleanse ( der , derlen ) ;
<1> int register_key_type ( struct key_type * ktype ) {\n<4> memset ( & ktype -> lock_class , 0 , sizeof ( ktype -> lock_class ) ) ;\n<7> list_for_each_entry ( p , & key_types_list , link ) {\n<8> if ( strcmp ( p -> name , ktype -> name ) == 0 ) goto out ;\n<10> list_add ( & ktype -> link , & key_types_list ) ;\n<11> pr_notice ( "Key type %s registered\n" , ktype -> name ) ;\n<12> ret = 0 ;
<1> static void convolute_with_sparse ( float * out , const AMRFixed * pulses , const float * shape , int length ) {\n<3> memset ( out , 0 , length * sizeof ( float ) ) ;\n<8> j ++ ) out [ j ] += pulses -> y [ i ] * shape [ j - pulses -> x [ i ] ] ;
<1> const TPMDriverOps *tpm_get_backend_driver(const char *type)\n<9> for (i = 0; i < TPM_MAX_DRIVERS && be_drivers[i] != NULL; i++) {\n<11> if (!strcmp(TpmType_lookup[be_drivers[i]->type], type)) {\n<13> return be_drivers[i];
<1> static void dump_json_image_info_list(ImageInfoList *list)\n<23> printf("%s\n", qstring_get_str(str));
<1> static CharDriverState *net_vhost_parse_chardev(\n<13> if (chr == NULL) {\n<25> memset(&props, 0, sizeof(props));\n<27> if (qemu_opt_foreach(chr->opts, net_vhost_chardev_opts, &props, errp)) {\n<35> if (!props.is_socket || !props.is_unix) {
<1> char * curlx_strdup ( const char * str ) {\n<4> if ( ! str ) return ( char * ) NULL ;\n<5> len = strlen ( str ) ;\n<6> if ( len >= ( ( size_t ) - 1 ) / sizeof ( char ) ) return ( char * ) NULL ;\n<7> newstr = malloc ( ( len + 1 ) * sizeof ( char ) ) ;\n<8> if ( ! newstr ) return ( char * ) NULL ;\n<9> memcpy ( newstr , str , ( len + 1 ) * sizeof ( char ) ) ;\n<10> return newstr ;
<1> int compare_files2 ( File fd1 , const char * filename2 ) {\n<12> if ( init_dynamic_string ( & fd1_result , 0 , fd1_length , 0 ) || init_dynamic_string ( & fd2_result , 0 , fd2_length , 0 ) ) die ( "Out of memory when allocating data for result" ) ;\n<13> fd1_result . length = fd1_length ;\n<19> if ( global_subst && ( fd1_length != fd2_length || memcmp ( fd1_result . str , fd2_result . str , fd1_length ) ) ) {\n<20> uint global_subst_from_len = strlen ( global_subst_from ) ;\n<21> uint global_subst_to_len = strlen ( global_subst_to ) ;\n<22> while ( replace ( & fd1_result , global_subst_from , global_subst_from_len , global_subst_to , global_subst_to_len ) == 0 ) ;\n<24> if ( fd1_result . length != fd2_result . length ) error = RESULT_LENGTH_MISMATCH ;\n<25> else if ( ( memcmp ( fd1_result . str , fd2_result . str , fd1_result . length ) ) ) error = RESULT_CONTENT_MISMATCH ;\n<27> dynstr_free ( & fd1_result ) ;\n<28> dynstr_free ( & fd2_result ) ;
<1> static int get_str_sep ( char * buf , int buf_size , const char * * pp , int sep ) {\n<4> p = * pp ;\n<5> p1 = strchr ( p , sep ) ;\n<6> if ( ! p1 ) return - 1 ;\n<7> len = p1 - p ;\n<9> if ( buf_size > 0 ) {\n<10> if ( len > buf_size - 1 ) len = buf_size - 1 ;\n<11> memcpy ( buf , p , len ) ;
<1> static int caca_write_header(AVFormatContext *s)\n<5> CACAContext *c = s->priv_data;\n<25> if (c->list_dither) {\n<27> if (!strcmp(c->list_dither, "colors")) {\n<29> list_dither_color(c);\n<31> } else if (!strcmp(c->list_dither, "charsets")) {\n<33> list_dither_charset(c);\n<35> } else if (!strcmp(c->list_dither, "algorithms")) {\n<37> list_dither_algorithm(c);\n<39> } else if (!strcmp(c->list_dither, "antialiases")) {\n<41> list_dither_antialias(c);\n<51> c->list_dither);\n<53> return AVERROR(EINVAL);\n<57> return AVERROR_EXIT;
<1> static void gst_asf_demux_reset ( GstASFDemux * demux , gboolean chain_reset ) {\n<2> GST_LOG_OBJECT ( demux , "resetting" ) ;\n<36> gst_asf_demux_free_stream ( demux , & demux -> old_stream [ demux -> old_num_streams - 1 ] ) ;\n<39> memset ( demux -> old_stream , 0 , sizeof ( demux -> old_stream ) ) ;\n<41> if ( chain_reset ) {\n<42> memcpy ( demux -> old_stream , demux -> stream , sizeof ( demux -> stream ) ) ;\n<47> gst_asf_demux_free_stream ( demux , & demux -> stream [ demux -> num_streams - 1 ] ) ;\n<50> memset ( demux -> stream , 0 , sizeof ( demux -> stream ) ) ;\n<73> GST_LOG_OBJECT ( demux , "Restarting" ) ;
<1> int av_tempfile(const char *prefix, char **filename, int log_offset, void *log_ctx) {\n<15> *filename = av_strdup(ptr);\n<19> free(ptr);
<1> static void sun4c_hw_init(const struct hwdef *hwdef, ram_addr_t RAM_size,\n<49> if (!env) {\n<51> fprintf(stderr, "qemu: Unable to find Sparc CPU definition\n");\n<73> if ((uint64_t)RAM_size > hwdef->max_mem) {\n<79> (unsigned int)(RAM_size / (1024 * 1024)),\n<81> (unsigned int)(hwdef->max_mem / (1024 * 1024)));\n<111> ret = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL);\n<115> ret = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX);\n<117> if (ret < 0 || ret > PROM_SIZE_MAX) {\n<119> fprintf(stderr, "qemu: could not load prom '%s'\n",\n<159> if (graphic_depth != 8 && graphic_depth != 24) {\n<161> fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth);\n<167> tcx_init(ds, hwdef->tcx_base, phys_ram_base + RAM_size, RAM_size,\n<173> if (nd_table[0].model == NULL\n<175> || strcmp(nd_table[0].model, "lance") == 0) {\n<177> lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset);\n<179> } else if (strcmp(nd_table[0].model, "?") == 0) {\n<181> fprintf(stderr, "qemu: Supported NICs: lance\n");\n<183> exit (1);\n<187> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);\n<189> exit (1);\n<245> if (drive_get_max_bus(IF_SCSI) > 0) {\n<247> fprintf(stderr, "qemu: too many SCSI bus\n");
<1> int ff_rtsp_setup_output_streams(AVFormatContext *s, const char *addr)\n<61> if (avf_sdp_create(ctx_array, 1, sdp, SDP_MAX_SIZE)) {\n<69> av_log(s, AV_LOG_VERBOSE, "SDP:\n%s\n", sdp);\n<71> ff_rtsp_send_cmd_with_content(s, "ANNOUNCE", rt->control_uri,\n<75> reply, NULL, sdp, strlen(sdp));
<1> int qemuMonitorJSONGetBlockExtent ( qemuMonitorPtr mon , const char * dev_name , unsigned long long * extent ) {\n<34> if ( STRPREFIX ( thisdev , QEMU_DRIVE_HOST_PREFIX ) ) thisdev += strlen ( QEMU_DRIVE_HOST_PREFIX ) ;\n<35> if ( STRNEQ ( thisdev , dev_name ) ) continue ;
<1> void _TIFFfree ( tdata_t p ) {\n<2> free ( p ) ;
<1> static void load_linux(PCMachineState *pcms,\n<27> const char *kernel_cmdline = machine->kernel_cmdline;\n<33> cmdline_size = (strlen(kernel_cmdline)+16) & ~15;\n<39> f = fopen(kernel_filename, "rb");\n<47> fprintf(stderr, "qemu: could not load kernel '%s': %s\n",\n<49> kernel_filename, strerror(errno));
<1> static void dumpnames ( struct alltabs * at , SplineFont * sf , enum fontformat format ) {\n<9> memset ( & nt , 0 , sizeof ( nt ) ) ;\n<10> nt . encoding_name = at -> map -> enc ;\n<11> nt . format = format ;\n<12> nt . applemode = at -> applemode ;\n<13> nt . strings = tmpfile ( ) ;\n<14> if ( ( format >= ff_ttf && format <= ff_otfdfont ) && ( at -> gi . flags & ttf_flag_symbol ) ) nt . format = ff_ttfsym ;\n<15> memset ( & dummy , 0 , sizeof ( dummy ) ) ;\n<25> DefaultTTFEnglishNames ( & dummy , sf ) ;\n<28> ++ i ) if ( dummy . names [ i ] != NULL ) AddEncodedName ( & nt , dummy . names [ i ] , 0x409 , i ) ;\n<34> ++ i ) if ( cur -> names [ i ] != NULL ) AddEncodedName ( & nt , cur -> names [ i ] , cur -> lang , i ) ;\n<36> if ( at -> feat_name != NULL ) {\n<42> mn = mn -> next ) AddMacName ( & nt , mn , at -> feat_name [ i ] . strid ) ;\n<50> mn = mn -> next ) AddMacName ( & nt , mn , on -> strid ) ;\n<57> otfn = otfn -> next ) AddEncodedName ( & nt , otfn -> name , otfn -> lang , at -> fontstyle_name_strid ) ;\n<64> otfn = otfn -> next ) AddEncodedName ( & nt , otfn -> name , otfn -> lang , fn -> nid ) ;\n<66> qsort ( nt . entries , nt . cur , sizeof ( NameEntry ) , compare_entry ) ;\n<69> putshort ( at -> name , nt . cur ) ;\n<70> putshort ( at -> name , ( 3 + nt . cur * 6 ) * sizeof ( int16 ) ) ;\n<72> i < nt . cur ;\n<81> if ( ! ttfcopyfile ( at -> name , nt . strings , ( 3 + nt . cur * 6 ) * sizeof ( int16 ) , "name-data" ) ) at -> error = true ;\n<88> ++ i ) if ( useng == NULL || dummy . names [ i ] != useng -> names [ i ] ) free ( dummy . names [ i ] ) ;\n<89> free ( nt . entries ) ;\n<90> free ( at -> feat_name ) ;
<1> static void TestHeapFunctions ( ) {\n<26> u_setDataDirectory ( icuDataDir ) ;\n<53> free ( icuDataDir ) ;
<1> int qemuMonitorTextGetMemoryStats ( qemuMonitorPtr mon , virDomainMemoryStatPtr stats , unsigned int nr_stats ) {\n<2> char * reply = NULL ;\n<5> if ( qemuMonitorHMPCommand ( mon , "info balloon" , & reply ) < 0 ) {\n<9> if ( ( offset = strstr ( reply , BALLOON_PREFIX ) ) != NULL ) {\n<10> offset += strlen ( BALLOON_PREFIX ) ;\n<11> ret = qemuMonitorParseBalloonInfo ( offset , stats , nr_stats ) ;\n<13> VIR_FREE ( reply ) ;
<1> void appendShellString ( PQExpBuffer buf , const char * str ) {\n<7> if ( * p == '\n' || * p == '\r' ) {\n<8> fprintf ( stderr , _ ( "shell command argument contains a newline or carriage return: \"%s\"\n" ) , str ) ;
<1> static void AbortTTF ( struct alltabs * at , SplineFont * sf ) {\n<53> if ( sf -> subfontcnt != 0 ) {\n<54> free ( sf -> glyphs ) ;\n<58> free ( at -> fds ) ;\n<59> free ( at -> gi . bygid ) ;
<1> static void cert_policy_destroy ( x509_cert_policy_t * this ) {\n<3> free ( this -> cps_uri ) ;\n<4> free ( this -> unotice_text ) ;\n<5> free ( this ) ;
<1> void destroy_address_node ( address_node * my_node ) {\n<2> if ( NULL == my_node ) return ;\n<3> NTP_REQUIRE ( NULL != my_node -> address ) ;\n<4> free ( my_node -> address ) ;\n<5> free ( my_node ) ;
<1> xsltSecurityPrefsPtr xsltNewSecurityPrefs ( void ) {\n<5> if ( ret == NULL ) {\n<9> memset ( ret , 0 , sizeof ( xsltSecurityPrefs ) ) ;\n<10> return ( ret ) ;
<1> static int parse_icy(HTTPContext *s, const char *tag, const char *p)\n<3> int len = 4 + strlen(p) + strlen(tag);\n<4> int is_first = !s->icy_metadata_headers;\n<6> if (s->icy_metadata_headers)\n<7> len += strlen(s->icy_metadata_headers);\n<8> if ((ret = av_reallocp(&s->icy_metadata_headers, len)) < 0)\n<10> av_strlcatf(s->icy_metadata_headers, len, "%s: %s\n", tag, p);
<1> static uint8_t *read_huffman_tables(FourXContext *f, uint8_t * const buf){\n<21> memset(frequency, 0, sizeof(frequency));\n<23> memset(up, -1, sizeof(up));\n<79> if(frequency[i] == 0) continue;\n<81> if(frequency[i] < min_freq[1]){\n<83> if(frequency[i] < min_freq[0]){\n<87> min_freq[0]= frequency[i];smallest[0]= i;\n<91> min_freq[1]= frequency[i];smallest[1]= i;\n<129> for(node= j; up[node] != -1; node= up[node]){
<1> static int zmbv_decode_intra ( ZmbvContext * c ) {\n<2> uint8_t * src = c -> decomp_buf ;\n<3> if ( c -> fmt == ZMBV_FMT_8BPP ) {\n<4> memcpy ( c -> pal , src , 768 ) ;\n<5> src += 768 ;\n<7> memcpy ( c -> cur , src , c -> width * c -> height * ( c -> bpp / 8 ) ) ;
<1> static void dissect_rsvp_common ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree , gboolean e2ei ) {\n<23> if ( ( message_type == RSVP_MSG_ACK ) || ( message_type == RSVP_MSG_SREFRESH ) || ( message_type == RSVP_MSG_HELLO ) ) return ;\n<25> memset ( & request_key , 0 , sizeof ( request_key ) ) ;\n<54> request_val = ( struct rsvp_request_val * ) g_hash_table_lookup ( rsvp_request_hash , & request_key ) ;\n<56> new_request_key = ( struct rsvp_request_key * ) wmem_memdup ( wmem_file_scope ( ) , & request_key , sizeof ( struct rsvp_request_key ) ) ;
<1> static int grow ( struct evport_data * epdp , int factor ) {\n<4> int newsize = factor * oldsize ;\n<6> check_evportop ( epdp ) ;\n<7> tmp = realloc ( epdp -> ed_fds , sizeof ( struct fd_info ) * newsize ) ;\n<8> if ( NULL == tmp ) return - 1 ;\n<9> epdp -> ed_fds = tmp ;\n<10> memset ( ( char * ) ( epdp -> ed_fds + oldsize ) , 0 , ( newsize - oldsize ) * sizeof ( struct fd_info ) ) ;
<1> static void vmsvga_fifo_run ( struct vmsvga_state_s * s ) {\n<10> switch ( cmd = vmsvga_fifo_read ( s ) ) {\n<109> if ( len < 0 ) {\n<115> printf ( "%s: Unknown command 0x%02x in SVGA command FIFO\n" , __func__ , cmd ) ;
<1> static void local_mapped_file_attr(FsContext *ctx, const char *path,\n<9> char buf[ATTR_MAX];\n<21> if (!fp) {\n<27> memset(buf, 0, ATTR_MAX);\n<29> while (fgets(buf, ATTR_MAX, fp)) {\n<31> if (!strncmp(buf, "virtfs.uid", 10)) {\n<35> } else if (!strncmp(buf, "virtfs.gid", 10)) {\n<39> } else if (!strncmp(buf, "virtfs.mode", 11)) {\n<43> } else if (!strncmp(buf, "virtfs.rdev", 11)) {\n<49> memset(buf, 0, ATTR_MAX);\n<53> fclose(fp);
<1> REGRESSION_TEST ( SDK_API_TSCache ) ( RegressionTest * test , int , int * pstatus ) {\n<7> if ( ! is_ready ) {\n<15> char key_name [ ] = "key_for_regression_test" ;\n<16> TSCacheKey key = TSCacheKeyCreate ( ) ;\n<19> TSCacheKeyDigestSet ( key , key_name , strlen ( key_name ) ) ;\n<20> TSCacheKeyDigestSet ( key_cmp , key_name , strlen ( key_name ) ) ;\n<40> cache_vconn -> key = key ;\n<42> TSCacheWrite ( contp , key ) ;
<1> void ppc_prep_init ( int ram_size , int vga_ram_size , int boot_device , DisplayState * ds , const char * * fd_filename , int snapshot , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename ) {\n<8> if ( linux_boot ) {\n<9> ret = load_image ( kernel_filename , phys_ram_base + KERNEL_LOAD_ADDR ) ;\n<10> if ( ret < 0 ) {\n<11> fprintf ( stderr , "qemu: could not load kernel '%s'\n" , kernel_filename ) ;\n<26> printf ( "load BIOS at %p\n" , phys_ram_base + 0x000f0000 ) ;\n<27> ret = load_image ( buf , phys_ram_base + 0x000f0000 ) ;\n<28> if ( ret != 0x10000 ) {\n<29> fprintf ( stderr , "qemu: could not load PPC bios '%s' (%d)\n%m\n" , buf , ret ) ;
<1> static inline void save_to_qmem ( unsigned char * qmem_cmc , unsigned short * qmem_type , int qmem_len , int * qmem_lastfilled , unsigned char * cmc_to_add , unsigned short type_to_add ) {\n<5> memcpy ( qmem_cmc + fill * 4 , cmc_to_add , 4 ) ;
<1> static int parse_vdiname(BDRVSheepdogState *s, const char *filename,\n<27> if (*p == ':') {\n<37> p = q;\n<43> if (nr_sep >= 2) {\n<47> p = strchr(p, ':');\n<49> p++;\n<51> p = strchr(p, ':');\n<53> *p++ = '\0';\n<63> vdi_spec = p;\n<67> p = strchr(vdi_spec, ':');\n<71> *p++ = '#';\n<77> uri = g_strdup_printf("sheepdog://%s/%s", host_spec, vdi_spec);
<1> static int execute_code(AVCodecContext * avctx, int c)\n<137> if (ret < 0) {\n<149> memcpy(s->frame->data[1], ff_cga_palette, 16 * 4);\n<169> if (s->y < avctx->height - s->font_height)\n<171> memset(s->frame->data[0] + (s->y + s->font_height)*s->frame->linesize[0],\n<173> DEFAULT_BG_COLOR, (avctx->height - s->y - s->font_height)*s->frame->linesize[0]);\n<181> if (s->y > 0)\n<183> memset(s->frame->data[0], DEFAULT_BG_COLOR, s->y * s->frame->linesize[0]);
<1> int jas_stream_display ( jas_stream_t * stream , FILE * fp , int n ) {\n<2> unsigned char buf [ 16 ] ;\n<12> i < n ;\n<14> if ( n > 16 && i > 0 ) {\n<15> display = ( i >= cnt ) ? 1 : 0 ;\n<17> if ( display ) {\n<18> fprintf ( fp , "%08x:" , i ) ;\n<20> m = JAS_MIN ( n - i , 16 ) ;\n<28> buf [ j ] = c ;\n<30> if ( display ) {\n<32> j < m ;\n<34> fprintf ( fp , " %02x" , buf [ j ] ) ;\n<36> fputc ( ' ' , fp ) ;\n<38> j < 16 ;\n<40> fprintf ( fp , " " ) ;\n<45> if ( isprint ( buf [ j ] ) ) {\n<46> fputc ( buf [ j ] , fp ) ;\n<49> fputc ( ' ' , fp ) ;\n<52> fprintf ( fp , "\n" ) ;
<1> int ff_h264_decode_mb_cabac ( H264Context * h ) {\n<104> if ( ( int ) ( h -> cabac . bytestream_end - ptr ) < mb_size ) return - 1 ;\n<111> memset ( h -> non_zero_count [ mb_xy ] , 16 , 48 ) ;
<1> static my_bool get_one_option ( int optid , const struct my_option * opt __attribute__ ( ( unused ) ) , char * argument ) {\n<21> if ( strlen ( argument ) >= FN_REFLEN ) {\n<22> die ( EX_USAGE , "Input filename too long: %s" , argument ) ;\n<53> if ( ! strchr ( argument , '.' ) ) {\n<54> fprintf ( stderr , "Illegal use of option --ignore-table=<database>.<table>\n" ) ;\n<57> if ( my_hash_insert ( & ignore_table , ( uchar * ) my_strdup ( argument , MYF ( 0 ) ) ) ) exit ( EX_EOM ) ;\n<69> opt_compatible_mode = find_set ( & compatible_mode_typelib , argument , strlen ( argument ) , & err_ptr , & err_len ) ;\n<71> strmake ( buff , err_ptr , min ( sizeof ( buff ) - 1 , err_len ) ) ;\n<72> fprintf ( stderr , "Invalid mode to --compatible: %s\n" , buff ) ;\n<76> size_t size_for_sql_mode = 0 ;\n<80> ptr ++ ) size_for_sql_mode += strlen ( * ptr ) ;\n<81> size_for_sql_mode += sizeof ( compatible_mode_names ) - 1 ;\n<97> case ( int ) OPT_MYSQL_PROTOCOL : opt_protocol = find_type_or_exit ( argument , & sql_protocol_typelib , opt -> name ) ;
<1> int av_opt_set(void *obj, const char *name, const char *val, int search_flags)\n<31> switch (o->type) {\n<51> if (!val || !strcmp(val, "none")) {\n<53> *(int *)dst = *((int *)dst + 1) = 0;\n<55> return 0;\n<59> ret = av_parse_video_size(dst, ((int *)dst) + 1, val);\n<61> if (ret < 0)\n<65> return ret;\n<87> if (!val || !strcmp(val, "none")) {\n<89> ret = AV_PIX_FMT_NONE;\n<93> ret = av_get_pix_fmt(val);\n<95> if (ret == AV_PIX_FMT_NONE) {\n<113> *(enum AVPixelFormat *)dst = ret;\n<115> return 0;\n<119> if (!val || !strcmp(val, "none")) {\n<121> ret = AV_SAMPLE_FMT_NONE;\n<125> ret = av_get_sample_fmt(val);\n<127> if (ret == AV_SAMPLE_FMT_NONE) {\n<145> *(enum AVSampleFormat *)dst = ret;\n<147> return 0;\n<191> if (!val || !strcmp(val, "none")) {\n<193> *(int64_t *)dst = 0;\n<203> int64_t cl = av_get_channel_layout(val);\n<207> if (!cl) {\n<215> *(int64_t *)dst = cl;\n<217> return ret;\n<227> av_log(obj, AV_LOG_ERROR, "Invalid option type.\n");\n<229> return AVERROR(EINVAL);
<1> static char *doubles2str(double *dp, int count, const char *sep)\n<9> int component_len = 15 + strlen(sep);\n<11> if (!sep) sep = ", ";\n<13> ap = av_malloc(component_len * count);\n<19> ap0   = ap;\n<23> for (i = 0; i < count; i++) {\n<25> unsigned l = snprintf(ap, component_len, "%f%s", dp[i], sep);\n<35> ap0[strlen(ap0) - strlen(sep)] = '\0';\n<37> return ap0;
<1> static guint qname_labels_count ( const guchar * name , guint name_len ) {\n<4> if ( name_len > 1 ) {\n<5> for ( i = 0 ;\n<6> i < strlen ( name ) ;\n<7> i ++ ) {\n<8> if ( name [ i ] == '.' ) labels ++ ;
<1> static int tscc2_decode_mb ( TSCC2Context * c , int * q , int vlc_set , uint8_t * dst , int stride , int plane ) {\n<7> val = get_bits ( gb , 8 ) ;\n<9> i < 8 ;\n<10> i ++ , dst += stride ) memset ( dst , val , 16 ) ;\n<42> c -> block [ 0 ] = dc ;\n<44> if ( nc == - 1 ) return AVERROR_INVALIDDATA ;\n<46> memset ( c -> block + 1 , 0 , 15 * sizeof ( * c -> block ) ) ;\n<56> c -> block [ tscc2_zigzag [ bpos ++ ] ] = val ;\n<58> tscc2_idct4_put ( c -> block , q , dst + k * 4 , stride ) ;
<1> void vnc_display_open(const char *id, Error **errp)\n<69> if (!opts) {\n<77> if (!vnc || strcmp(vnc, "none") == 0) {\n<79> return;\n<85> sopts = qemu_opts_create(&socket_optslist, NULL, 0, &error_abort);\n<87> wsopts = qemu_opts_create(&socket_optslist, NULL, 0, &error_abort);\n<91> h = strrchr(vnc, ':');\n<93> if (h) {\n<237> share = qemu_opt_get(opts, "share");\n<239> if (share) {\n<241> if (strcmp(share, "ignore") == 0) {\n<243> vs->share_policy = VNC_SHARE_POLICY_IGNORE;\n<245> } else if (strcmp(share, "allow-exclusive") == 0) {\n<247> vs->share_policy = VNC_SHARE_POLICY_ALLOW_EXCLUSIVE;\n<249> } else if (strcmp(share, "force-shared") == 0) {\n<251> vs->share_policy = VNC_SHARE_POLICY_FORCE_SHARED;\n<255> error_setg(errp, "unknown vnc share= option");\n<267> vs->connections_limit = qemu_opt_get_number(opts, "connections", 32);\n<271> websocket = qemu_opt_get(opts, "websocket");\n<273> if (websocket) {\n<569> qemu_opts_del(sopts);\n<571> qemu_opts_del(wsopts);\n<573> vs->enabled = false;
<1> static const char *read_ts(const char *buf, int *ts_start, int *ts_end,\n<3> int *x1, int *y1, int *x2, int *y2)\n<11> for (i=0; i<2; i++) {\n<15> int c = sscanf(buf, "%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d"\n<23> buf += strcspn(buf, "\n") + 1;\n<25> if (c >= 8) {\n<27> *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;\n<29> *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
<1> static void usage ( void ) {\n<8> printf ( "Usage: %s [OPTIONS]\n" , my_progname ) ;
<1> static int unpack_superblocks(Vp3DecodeContext *s, GetBitContext *gb)\n<25> if (s->keyframe) {\n<27> memset(s->superblock_coding, SB_FULLY_CODED, s->superblock_count);\n<37> bit = get_bits1(gb);\n<39> while (current_superblock < s->superblock_count) {\n<45> if (current_run == 34)\n<47> current_run += get_bits(gb, 12);\n<51> if (current_superblock + current_run > s->superblock_count) {\n<61> memset(s->superblock_coding + current_superblock, bit, current_run);\n<65> current_superblock += current_run;\n<69> num_partial_superblocks += current_run;\n<73> if (s->theora && current_run == MAXIMUM_LONG_BIT_RUN)\n<75> bit = get_bits1(gb);\n<79> bit ^= 1;\n<89> if (num_partial_superblocks < s->superblock_count) {\n<99> while (superblocks_decoded < s->superblock_count - num_partial_superblocks) {\n<183> memset(s->macroblock_coding, MODE_COPY, s->macroblock_count);\n<225> if (current_run-- == 0) {\n<259> s->all_fragments[current_fragment].coding_method =
<1> static inline int decode_picture_parameter_set(H264Context *h, int bit_length){\n<19> pps = &h->pps_buffer[pps_id];\n<109> if(pps->ref_count[0] > 32 || pps->ref_count[1] > 32){\n<141> memset(pps->scaling_matrix4, 16, 6*16*sizeof(uint8_t));\n<143> memset(pps->scaling_matrix8, 16, 2*64*sizeof(uint8_t));\n<151> decode_scaling_matrices(h, &h->sps_buffer[pps->sps_id], pps, 0, pps->scaling_matrix4, pps->scaling_matrix8);
<1> int test_gf2m_mod_solve_quad ( BIO * bp , BN_CTX * ctx ) {\n<42> if ( ! BN_is_zero ( e ) ) {\n<43> fprintf ( stderr , "GF(2^m) modular solve quadratic test failed!\n" ) ;
<1> static void acl_insert_user ( const char * user , const char * host , const char * password , uint password_len , enum SSL_type ssl_type , const char * ssl_cipher , const char * x509_issuer , const char * x509_subject , USER_RESOURCES * mqh , ulong privileges ) {\n<5> update_hostname ( & acl_user . host , * host ? strdup_root ( & mem , host ) : 0 ) ;\n<9> acl_user . hostname_length = ( uint ) strlen ( host ) ;\n<14> set_user_salt ( & acl_user , password , password_len ) ;\n<15> VOID ( push_dynamic ( & acl_users , ( uchar * ) & acl_user ) ) ;
<1> static int find_debugfs(char *debugfs)\n<5> char type[100];\n<13> if (fp == NULL) {\n<21> while (fscanf(fp, "%*s %" STR(PATH_MAX) "s %99s %*s %*d %*d\n",\n<25> if (strcmp(type, "debugfs") == 0) {\n<37> if (strcmp(type, "debugfs") != 0) {\n<39> return 0;\n<43> return 1;
<1> static int commit_bitstream_and_slice_buffer ( AVCodecContext * avctx , DXVA2_DecodeBufferDesc * bs , DXVA2_DecodeBufferDesc * sc ) {\n<23> static const unsigned start_code_size = sizeof ( start_code ) ;\n<30> size = slice -> SliceBytesInBuffer ;\n<31> if ( start_code_size + size > end - current ) {\n<35> slice -> BSNALunitDataLocation = current - dxva_data ;\n<42> memcpy ( current , start_code , start_code_size ) ;\n<43> current += start_code_size ;\n<44> memcpy ( current , & ctx_pic -> bitstream [ position ] , size ) ;\n<45> current += size ;\n<47> padding = FFMIN ( 128 - ( ( current - dxva_data ) & 127 ) , end - current ) ;\n<48> if ( slice && padding > 0 ) {\n<49> memset ( current , 0 , padding ) ;\n<50> current += padding ;\n<51> slice -> SliceBytesInBuffer += padding ;\n<54> if ( i < ctx_pic -> slice_count ) return - 1 ;\n<55> memset ( bs , 0 , sizeof ( * bs ) ) ;\n<67> assert ( ( bs -> DataSize & 127 ) == 0 ) ;
<1> static void draw_mandelbrot(AVFilterContext *ctx, uint32_t *color, int linesize, int64_t pts)\n<17> memset(color, 0, sizeof(*color)*mb->w);\n<27> if(y1<mb->h){\n<29> memset(color+linesize*y1, 0, sizeof(*color)*mb->w);\n<55> if(color[x + y*linesize] & 0xFF000000)\n<59> if(interpol(mb, color, x, y, linesize)){\n<77> use_zyklus= (x==0 || mb->inner!=BLACK ||color[x-1 + y*linesize] == 0xFF000000);\n<235> color[x + y*linesize]= c;
<1> static void * kq_init ( struct event_base * base ) {\n<4> if ( evutil_getenv ( "EVENT_NOKQUEUE" ) ) return ( NULL ) ;\n<5> if ( ! ( kqueueop = calloc ( 1 , sizeof ( struct kqop ) ) ) ) return ( NULL ) ;\n<6> if ( ( kq = kqueue ( ) ) == - 1 ) {\n<8> free ( kqueueop ) ;\n<11> kqueueop -> kq = kq ;\n<12> kqueueop -> pid = getpid ( ) ;\n<13> kqueueop -> changes = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n<14> if ( kqueueop -> changes == NULL ) {\n<15> free ( kqueueop ) ;\n<18> kqueueop -> events = malloc ( NEVENT * sizeof ( struct kevent ) ) ;\n<19> if ( kqueueop -> events == NULL ) {\n<20> free ( kqueueop -> changes ) ;\n<21> free ( kqueueop ) ;\n<24> kqueueop -> nevents = NEVENT ;\n<30> memset ( & kqueueop -> changes [ 0 ] , 0 , sizeof kqueueop -> changes [ 0 ] ) ;\n<34> if ( kevent ( kq , kqueueop -> changes , 1 , kqueueop -> events , NEVENT , NULL ) != 1 || kqueueop -> events [ 0 ] . ident != - 1 || kqueueop -> events [ 0 ] . flags != EV_ERROR ) {\n<38> free ( kqueueop -> events ) ;\n<39> free ( kqueueop ) ;\n<43> return ( kqueueop ) ;
<1> static void _slurm_rpc_allocate_pack ( slurm_msg_t * msg ) {\n<133> hostset_ranged_string ( jobid_hostset , buf_size , tmp_str ) ;\n<134> if ( tmp_str [ 0 ] == '[' ) {\n<135> tmp_offset = strchr ( tmp_str , ']' ) ;\n<137> tmp_offset = tmp_str + 1 ;\n<153> xfree ( tmp_str ) ;
<1> void gx_device_init_on_stack ( gx_device * dev , const gx_device * proto , gs_memory_t * mem ) {\n<2> memcpy ( dev , proto , proto -> params_size ) ;\n<5> dev -> pad = proto -> pad ;\n<6> dev -> log2_align_mod = proto -> log2_align_mod ;\n<7> dev -> is_planar = proto -> is_planar ;\n<8> rc_init ( dev , NULL , 0 ) ;
<1> static int pci_rocker_init(PCIDevice *dev)\n<7> const MACAddr zero = { .a = { 0, 0, 0, 0, 0, 0 } };\n<9> const MACAddr dflt = { .a = { 0x52, 0x54, 0x00, 0x12, 0x35, 0x01 } };\n<33> r->world_dflt = rocker_world_type_by_name(r, r->world_name);\n<35> if (!r->world_dflt) {\n<83> err = rocker_msix_init(r);\n<105> if (rocker_find(r->name)) {\n<133> if (strlen(r->name) > MAX_ROCKER_NAME_LEN) {\n<139> MAX_ROCKER_NAME_LEN);\n<141> return -EINVAL;\n<147> if (memcmp(&r->fp_start_macaddr, &zero, sizeof(zero)) == 0) {\n<149> memcpy(&r->fp_start_macaddr, &dflt, sizeof(dflt));\n<151> r->fp_start_macaddr.a[4] += (sw_index++);\n<157> if (!r->switch_id) {\n<167> if (r->fp_ports > ROCKER_FP_PORTS_MAX) {\n<199> for (i = 0; i < rocker_pci_ring_count(r); i++) {\n<201> DescRing *ring = desc_ring_alloc(r, i);\n<233> for (i = 0; i < r->fp_ports; i++) {\n<237> fp_port_alloc(r, r->name, &r->fp_start_macaddr,\n<251> QLIST_INSERT_HEAD(&rockers, r, next);\n<255> return 0;
<1> int qemu_config_parse(FILE *fp, QemuOptsList **lists, const char *fname)\n<5> char line[1024], group[64], id[64], arg[64], value[1024];\n<19> while (fgets(line, sizeof(line), fp) != NULL) {\n<21> loc_set_file(fname, ++lno);\n<23> if (line[0] == '\n') {\n<31> if (line[0] == '#') {\n<39> if (sscanf(line, "[%63s \"%63[^\"]\"]", group, id) == 2) {\n<43> list = find_list(lists, group);\n<45> if (list == NULL)\n<49> opts = qemu_opts_create(list, id, 1);\n<55> if (sscanf(line, "[%63[^]]]", group) == 1) {\n<59> list = find_list(lists, group);\n<61> if (list == NULL)\n<65> opts = qemu_opts_create(list, NULL, 0);\n<71> if (sscanf(line, " %63s = \"%1023[^\"]\"", arg, value) == 2) {\n<75> if (opts == NULL) {\n<83> if (qemu_opt_set(opts, arg, value) != 0) {\n<93> error_report("parse error");\n<99> if (ferror(fp)) {
<1> static void test_warnings ( ) {\n<8> if ( ! opt_silent ) fprintf ( stdout , "\n total warnings: %d" , mysql_warning_count ( mysql ) ) ;
<1> static void test_tco_second_timeout_shutdown(void)\n<37> g_assert(!strcmp(qdict_get_str(ad, "action"), "shutdown"));
<1> static int decode_subframe ( WmallDecodeCtx * s ) {\n<87> i ++ ) if ( s -> is_channel_coded [ i ] ) {\n<94> memset ( s -> channel_residues [ i ] , 0 , sizeof ( * * s -> channel_residues ) * subframe_len ) ;
<1> enum nss_status _nss_nis_getaliasbyname_r ( const char * name , struct aliasent * alias , char * buffer , size_t buflen , int * errnop ) {\n<2> if ( name == NULL ) {\n<7> if ( __builtin_expect ( yp_get_default_domain ( & domain ) , 0 ) ) return NSS_STATUS_UNAVAIL ;\n<8> size_t namlen = strlen ( name ) ;\n<10> int use_alloca = __libc_use_alloca ( namlen + 1 ) ;\n<11> if ( use_alloca ) name2 = __alloca ( namlen + 1 ) ;\n<13> name2 = malloc ( namlen + 1 ) ;\n<14> if ( name2 == NULL ) {\n<21> i < namlen ;\n<22> ++ i ) name2 [ i ] = _tolower ( name [ i ] ) ;\n<23> name2 [ i ] = '\0' ;\n<26> int yperr = yp_match ( domain , "mail.aliases" , name2 , namlen , & result , & len ) ;\n<27> if ( ! use_alloca ) free ( name2 ) ;\n<33> if ( __builtin_expect ( ( size_t ) ( len + 1 ) > buflen , 0 ) ) {\n<34> free ( result ) ;\n<38> char * p = strncpy ( buffer , result , len ) ;\n<40> while ( isspace ( * p ) ) ++ p ;\n<41> free ( result ) ;\n<43> int parse_res = _nss_nis_parse_aliasent ( name , p , alias , buffer , buflen , errnop ) ;
<1> static int qcow_create2(const char *filename, int64_t total_size,\n<3> const char *backing_file, const char *backing_format,\n<21> QCowCreateState s1, *s = &s1;\n<29> memset(s, 0, sizeof(*s));\n<35> if (fd < 0)\n<39> memset(&header, 0, sizeof(header));\n<51> if (backing_file) {\n<53> if (backing_format) {\n<57> backing_format_len = strlen(backing_format);\n<59> ext_bf.len = backing_format_len;\n<69> backing_filename_len = strlen(backing_file);\n<71> header.backing_file_size = cpu_to_be32(backing_filename_len);\n<83> if (s->cluster_bits < MIN_CLUSTER_BITS ||\n<85> s->cluster_bits > MAX_CLUSTER_BITS)\n<89> fprintf(stderr, "Cluster size must be a power of two between "\n<93> 1 << MIN_CLUSTER_BITS,\n<95> 1 << (MAX_CLUSTER_BITS - 10));\n<101> s->cluster_size = 1 << s->cluster_bits;\n<105> header.cluster_bits = cpu_to_be32(s->cluster_bits);\n<119> l2_bits = s->cluster_bits - 3;\n<121> shift = s->cluster_bits + l2_bits;\n<125> offset = align_offset(header_size, s->cluster_size);\n<129> header.l1_table_offset = cpu_to_be64(s->l1_table_offset);\n<133> offset += align_offset(l1_size * sizeof(uint64_t), s->cluster_size);\n<137> s->refcount_table = qemu_mallocz(s->cluster_size);\n<147> offset += s->cluster_size;\n<155> tmp = offset >> s->cluster_bits;\n<157> ref_clusters = (tmp >> (s->cluster_bits - REFCOUNT_SHIFT)) + 1;\n<163> offset += s->cluster_size;\n<169> s->refcount_block = qemu_mallocz(ref_clusters * s->cluster_size);\n<175> qcow2_create_refcount_update(s, 0, header_size);\n<191> ret = qemu_write_full(fd, &header, sizeof(header));\n<203> if (backing_format_len) {\n<211> memset(zero, 0, sizeof(zero));\n<227> ret = qemu_write_full(fd, backing_format, backing_format_len);\n<239> ret = qemu_write_full(fd, zero, padding);\n<253> ret = qemu_write_full(fd, backing_file, backing_filename_len);
<1> static void qemu_kvm_init_cpu_signals(CPUState *env)\n<13> memset(&sigact, 0, sizeof(sigact));\n<17> sigaction(SIG_IPI, &sigact, NULL);\n<67> if (r) {\n<69> fprintf(stderr, "kvm_set_signal_mask: %s\n", strerror(-r));
<1> av_cold int ff_rate_control_init(MpegEncContext *s)\n<167> p = s->avctx->stats_in;\n<169> for (i = -1; p; i++)\n<171> p = strchr(p + 1, ';');\n<211> p = s->avctx->stats_in;\n<213> for (i = 0; i < rcc->num_entries - s->max_b_frames; i++) {\n<225> next = strchr(p, ';');\n<231> next++;\n<235> e = sscanf(p, " in:%d ", &picture_number);\n<239> assert(picture_number >= 0);\n<241> assert(picture_number < rcc->num_entries);\n<259> if (e != 14) {\n<273> p = next;
<1> void dtls1_get_ccs_header ( unsigned char * data , struct ccs_header_st * ccs_hdr ) {\n<2> memset ( ccs_hdr , 0x00 , sizeof ( struct ccs_header_st ) ) ;
<1> void proto_get_frame_protocols ( const wmem_list_t * layers , gboolean * is_ip , gboolean * is_tcp , gboolean * is_udp , gboolean * is_sctp , gboolean * is_ssl , gboolean * is_rtp , gboolean * is_lte_rlc ) {\n<5> while ( protos != NULL ) {\n<7> proto_name = proto_get_protocol_filter_name ( proto_id ) ;\n<8> if ( is_ip && ( ( ! strcmp ( proto_name , "ip" ) ) || ( ! strcmp ( proto_name , "ipv6" ) ) ) ) {\n<9> * is_ip = TRUE ;\n<11> else if ( is_tcp && ! strcmp ( proto_name , "tcp" ) ) {\n<12> * is_tcp = TRUE ;\n<14> else if ( is_udp && ! strcmp ( proto_name , "udp" ) ) {\n<15> * is_udp = TRUE ;\n<17> else if ( is_sctp && ! strcmp ( proto_name , "sctp" ) ) {\n<18> * is_sctp = TRUE ;\n<20> else if ( is_ssl && ! strcmp ( proto_name , "ssl" ) ) {\n<21> * is_ssl = TRUE ;\n<23> else if ( is_rtp && ! strcmp ( proto_name , "rtp" ) ) {\n<24> * is_rtp = TRUE ;\n<26> else if ( is_lte_rlc && ! strcmp ( proto_name , "rlc-lte" ) ) {\n<27> * is_lte_rlc = TRUE ;
<1> static int qemu_chr_open_pipe(QemuOpts *opts, CharDriverState **_chr)\n<13> if (filename == NULL) {\n<15> fprintf(stderr, "chardev: pipe: no filename given\n");
<1> static void qcms_modular_transform_release ( struct qcms_modular_transform * transform ) {\n<3> while ( transform != NULL ) {\n<5> if ( transform -> input_clut_table_r + transform -> input_clut_table_length == transform -> input_clut_table_g && transform -> input_clut_table_g + transform -> input_clut_table_length == transform -> input_clut_table_b ) {\n<6> if ( transform -> input_clut_table_r ) free ( transform -> input_clut_table_r ) ;\n<9> if ( transform -> input_clut_table_r ) free ( transform -> input_clut_table_r ) ;\n<10> if ( transform -> input_clut_table_g ) free ( transform -> input_clut_table_g ) ;\n<11> if ( transform -> input_clut_table_b ) free ( transform -> input_clut_table_b ) ;\n<13> if ( transform -> r_clut + 1 == transform -> g_clut && transform -> g_clut + 1 == transform -> b_clut ) {\n<14> if ( transform -> r_clut ) free ( transform -> r_clut ) ;\n<17> if ( transform -> r_clut ) free ( transform -> r_clut ) ;\n<18> if ( transform -> g_clut ) free ( transform -> g_clut ) ;\n<19> if ( transform -> b_clut ) free ( transform -> b_clut ) ;\n<21> if ( transform -> output_clut_table_r + transform -> output_clut_table_length == transform -> output_clut_table_g && transform -> output_clut_table_g + transform -> output_clut_table_length == transform -> output_clut_table_b ) {\n<22> if ( transform -> output_clut_table_r ) free ( transform -> output_clut_table_r ) ;\n<25> if ( transform -> output_clut_table_r ) free ( transform -> output_clut_table_r ) ;\n<26> if ( transform -> output_clut_table_g ) free ( transform -> output_clut_table_g ) ;\n<27> if ( transform -> output_clut_table_b ) free ( transform -> output_clut_table_b ) ;\n<29> if ( transform -> output_gamma_lut_r ) free ( transform -> output_gamma_lut_r ) ;\n<30> if ( transform -> output_gamma_lut_g ) free ( transform -> output_gamma_lut_g ) ;\n<31> if ( transform -> output_gamma_lut_b ) free ( transform -> output_gamma_lut_b ) ;\n<32> free ( transform ) ;
<1> int vc1_parse_frame_header_adv(VC1Context *v, GetBitContext* gb)\n<391> status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v);\n<547> memset(v->mv_type_mb_plane, 0, v->s.mb_stride * v->s.mb_height);\n<551> status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v);\n<617> vop_dquant_decoding(v);\n<841> vop_dquant_decoding(v);
<1> static int ehci_init_transfer(EHCIPacket *p)\n<23> if (cpage > 4) {\n<25> fprintf(stderr, "cpage out of range (%d)\n", cpage);
<1> void helper_do_semihosting(CPUMIPSState *env)\n<5> target_ulong *gpr = env->active_tc.gpr;\n<7> const UHIOp op = gpr[25];\n<13> switch (op) {\n<23> GET_TARGET_STRING(p, gpr[4]);\n<25> if (!strcmp("/dev/stdin", p)) {\n<27> gpr[2] = 0;\n<29> } else if (!strcmp("/dev/stdout", p)) {\n<31> gpr[2] = 1;\n<33> } else if (!strcmp("/dev/stderr", p)) {\n<35> gpr[2] = 2;\n<39> gpr[2] = open(p, get_open_flags(gpr[5]), gpr[6]);\n<41> gpr[3] = errno_mips(errno);\n<45> FREE_TARGET_STRING(p, gpr[4]);\n<109> memset(&sbuf, 0, sizeof(sbuf));\n<111> gpr[2] = fstat(gpr[4], &sbuf);\n<121> gpr[2] = copy_stat_to_target(env, &sbuf, gpr[5]);\n<137> if (gpr[4] >= semihosting_get_argc()) {\n<145> gpr[2] = strlen(semihosting_get_arg(gpr[4]));\n<165> GET_TARGET_STRING(p, gpr[4]);\n<167> p2 = strstr(p, "%d");\n<169> if (p2) {\n<171> int char_num = p2 - p;\n<173> char *buf = g_malloc(char_num + 1);\n<175> strncpy(buf, p, char_num);\n<177> buf[char_num] = '\0';\n<179> gpr[2] = printf("%s%d%s", buf, (int)gpr[5], p2 + 2);\n<181> g_free(buf);\n<185> gpr[2] = printf("%s", p);\n<189> FREE_TARGET_STRING(p, gpr[4]);\n<195> GET_TARGET_STRING(p, gpr[4]);\n<197> GET_TARGET_STRING(p2, gpr[5]);\n<199> printf("assertion '");\n<201> printf("\"%s\"", p);\n<203> printf("': file \"%s\", line %d\n", p2, (int)gpr[6]);\n<205> FREE_TARGET_STRING(p2, gpr[5]);\n<207> FREE_TARGET_STRING(p, gpr[4]);\n<251> fprintf(stderr, "Unknown UHI operation %d\n", op);
<1> int ff_hevc_parse_sps(HEVCSPS *sps, GetBitContext *gb, unsigned int *sps_id,\n<405> ow = &sps->output_window;\n<415> av_log(avctx, AV_LOG_WARNING, "Invalid cropping offsets: %u/%u/%u/%u\n",\n<428> memset(ow, 0, sizeof(*ow));
<1> static int vmd_decode(VmdVideoContext *s, AVFrame *frame)\n<115> s->avctx->height * frame->linesize[0]);\n<197> dp = &frame->data[0][frame_y * frame->linesize[0] + frame_x];\n<199> pp = &s->prev_frame->data[0][frame_y * s->prev_frame->linesize[0] + frame_x];\n<213> if (len & 0x80) {\n<223> bytestream2_get_bufferu(&gb, &dp[ofs], len);\n<231> if (ofs + len + 1 > frame_width || !s->prev_frame->data[0])\n<235> memcpy(&dp[ofs], &pp[ofs], len + 1);\n<255> dp += frame->linesize[0];\n<257> pp += s->prev_frame->linesize[0];\n<291> if (len & 0x80) {\n<313> bytestream2_get_buffer(&gb, &dp[ofs], len);\n<323> if (ofs + len + 1 > frame_width || !s->prev_frame->data[0])\n<327> memcpy(&dp[ofs], &pp[ofs], len + 1);\n<347> dp += frame->linesize[0];\n<349> pp += s->prev_frame->linesize[0];
<1> int test_gf2m_mod_sqrt ( BIO * bp , BN_CTX * ctx ) {\n<38> if ( ! BN_is_zero ( f ) ) {\n<39> fprintf ( stderr , "GF(2^m) modular square root test failed!\n" ) ;
<1> static int qemu_signal_init(void)\n<79> if (sigfd == -1) {\n<81> fprintf(stderr, "failed to create signalfd\n");
<1> static int do_cgroup_get ( const char * cgroup_path , const char * sub_filename , char * value , size_t len ) {\n<8> if ( ! filename ) return - 1 ;\n<9> ret = lxc_read_from_file ( filename , value , len ) ;\n<11> free ( filename ) ;
<1> static int kvm_init(MachineState *ms)\n<27> }, *nc = num_cpus;\n<79> if (s->fd == -1) {\n<81> fprintf(stderr, "Could not access KVM kernel module: %m\n");\n<93> if (ret < KVM_API_VERSION) {\n<101> fprintf(stderr, "kvm version too old\n");\n<109> if (ret > KVM_API_VERSION) {\n<113> fprintf(stderr, "kvm version not supported\n");\n<157> if (nc->num > soft_vcpus_limit) {\n<169> if (nc->num > hard_vcpus_limit) {\n<171> fprintf(stderr, "Number of %s cpus requested (%d) exceeds "\n<183> nc++;\n<189> kvm_type = qemu_opt_get(qemu_get_machine_opts(), "kvm-type");\n<195> } else if (kvm_type) {\n<199> fprintf(stderr, "Invalid argument kvm-type=%s\n", kvm_type);\n<215> if (ret < 0) {\n<217> fprintf(stderr, "ioctl(KVM_CREATE_VM) failed: %d %s\n", -ret,\n<219> strerror(-ret));\n<241> if (!missing_cap) {\n<249> if (missing_cap) {
<1> static void check_for_reg_data_type_usage ( ClusterInfo * cluster ) {\n<16> DbInfo * active_db = & cluster -> dbarr . dbs [ dbnum ] ;\n<17> PGconn * conn = connectToServer ( cluster , active_db -> db_name ) ;\n<24> rowno < ntups ;\n<27> if ( script == NULL && ( script = fopen_priv ( output_path , "w" ) ) == NULL ) pg_fatal ( "Could not open file \"%s\": %s\n" , output_path , getErrorText ( ) ) ;\n<28> if ( ! db_used ) {\n<29> fprintf ( script , "Database: %s\n" , active_db -> db_name ) ;\n<32> fprintf ( script , " %s.%s.%s\n" , PQgetvalue ( res , rowno , i_nspname ) , PQgetvalue ( res , rowno , i_relname ) , PQgetvalue ( res , rowno , i_attname ) ) ;\n<37> if ( script ) fclose ( script ) ;
<1> static int qemuAgentIOProcessData ( qemuAgentPtr mon , char * data , size_t len , qemuAgentMessagePtr msg ) {\n<2> int used = 0 ;\n<9> char * nl = strstr ( data + used , LINE_ENDING ) ;\n<11> int got = nl - ( data + used ) ;\n<12> for ( i = 0 ;\n<13> i < strlen ( LINE_ENDING ) ;\n<14> i ++ ) data [ used + got + i ] = '\0' ;\n<15> if ( qemuAgentIOProcessLine ( mon , data + used , msg ) < 0 ) return - 1 ;\n<16> used += got + strlen ( LINE_ENDING ) ;
<1> static CURLcode glob_range ( URLGlob * glob , char * * patternp , size_t * posp , unsigned long * amount , int globindex ) {\n<4> char * pattern = * patternp ;\n<8> if ( ISALPHA ( * pattern ) ) {\n<13> rc = sscanf ( pattern , "%c-%c" , & min_c , & max_c ) ;\n<14> if ( ( rc == 2 ) && ( pattern [ 3 ] == ':' ) ) {\n<18> lstep = strtoul ( & pattern [ 4 ] , & endp , 10 ) ;\n<23> if ( step > ( max_c - min_c ) ) step = - 1 ;\n<26> else pattern += 4 ;\n<27> * posp += ( pattern - * patternp ) ;\n<28> if ( ( rc != 2 ) || ( min_c >= max_c ) || ( ( max_c - min_c ) > ( 'z' - 'a' ) ) || ( step <= 0 ) ) return GLOBERROR ( "bad range" , * posp , CURLE_URL_MALFORMAT ) ;\n<30> pat -> content . CharRange . ptr_c = pat -> content . CharRange . min_c = min_c ;\n<31> pat -> content . CharRange . max_c = max_c ;\n<83> * patternp = pattern ;
<1> static const char * comp_http_hdr ( HTTPHdr * h1 , HTTPHdr * h2 ) {\n<13> rval = h1 -> print ( h1_pbuf , h1_len , & p_index , & p_dumpoffset ) ;\n<20> rval = h2 -> print ( h2_pbuf , h2_len , & p_index , & p_dumpoffset ) ;\n<21> if ( rval != 1 ) {\n<26> rval = memcmp ( h1_pbuf , h2_pbuf , h1_len ) ;\n<27> ats_free ( h1_pbuf ) ;\n<28> ats_free ( h2_pbuf ) ;\n<29> if ( rval != 0 ) {
<1> void mime_scanner_append ( MIMEScanner * scanner , const char * data , int data_size ) {\n<3> if ( data_size > free_size ) {\n<7> while ( free_size < data_size ) {\n<12> scanner -> m_line = ( char * ) ats_malloc ( scanner -> m_line_size ) ;\n<15> scanner -> m_line = ( char * ) ats_realloc ( scanner -> m_line , scanner -> m_line_size ) ;\n<18> memcpy ( & ( scanner -> m_line [ scanner -> m_line_length ] ) , data , data_size ) ;\n<19> scanner -> m_line_length += data_size ;
<299> avio_read(pb, st->codec->extradata, st->codec->extradata_size);\n<311> if (st->codec->extradata_size && (st->codec->bits_per_coded_sample <= 8)) {\n<325> memcpy(st->codec->palctrl->palette, st->codec->extradata,\n<327> FFMIN(st->codec->extradata_size, AVPALETTE_SIZE));\n<351> av_freep(&st->codec->extradata);
<1> static void qemu_fill_buffer(QEMUFile *f)\n<11> assert(!qemu_file_is_writable(f));\n<15> pending = f->buf_size - f->buf_index;\n<17> if (pending > 0) {\n<19> memmove(f->buf, f->buf + f->buf_index, pending);\n<25> f->buf_size = pending;\n<29> len = f->ops->get_buffer(f->opaque, f->buf + pending, f->pos,\n<31> IO_BUF_SIZE - pending);\n<41> qemu_file_set_error(f, -EIO);\n<45> qemu_file_set_error(f, len);
<1> static int getarg ( const char * str , int code , arg_v * argp ) {\n<3> switch ( code & ~ OPT ) {\n<8> case NTP_UINT : if ( '&' == str [ 0 ] ) {\n<9> if ( ! atouint ( & str [ 1 ] , & ul ) ) {\n<10> fprintf ( stderr , "***Association index `%s' invalid/undecodable\n" , str ) ;\n<15> if ( 0 == numassoc ) {\n<16> fprintf ( stderr , "***No associations found, `%s' unknown\n" , str ) ;\n<24> if ( ! atouint ( str , & argp -> uval ) ) {\n<25> fprintf ( stderr , "***Illegal unsigned value %s\n" , str ) ;\n<29> case NTP_INT : if ( ! atoint ( str , & argp -> ival ) ) {\n<30> fprintf ( stderr , "***Illegal integer value %s\n" , str ) ;\n<34> case IP_VERSION : if ( ! strcmp ( "-6" , str ) ) {\n<35> argp -> ival = 6 ;\n<37> else if ( ! strcmp ( "-4" , str ) ) {\n<38> argp -> ival = 4 ;\n<41> fprintf ( stderr , "***Version must be either 4 or 6\n" ) ;\n<42> return 0 ;\n<46> return 1 ;
<1> void cpu_reset(CPUARMState *env)\n<5> memset(env, 0, offsetof(CPUARMState, breakpoints));\n<7> cpu_reset_model_id(env, id);\n<16> if (IS_M(env))
<1> static void e1000e_parse_rxbufsize ( E1000ECore * core ) {\n<3> memset ( core -> rxbuf_sizes , 0 , sizeof ( core -> rxbuf_sizes ) ) ;\n<23> e1000e_calc_per_desc_buf_size ( core ) ;
<1> static void codebook_trellis_rate(AACEncContext *s, SingleChannelElement *sce,\n<211> start = 0;\n<213> for (i = stack_len - 1; i >= 0; i--) {\n<217> count = stackrun[i];\n<219> memset(sce->zeroes + win*16 + start, !stackcb[i], count);\n<223> for (j = 0; j < count; j++) {\n<227> start++;
<1> int kvm_arch_init_vcpu ( CPUState * cs ) {\n<12> uint32_t signature [ 3 ] ;\n<16> memset ( & cpuid_data , 0 , sizeof ( cpuid_data ) ) ;\n<28> if ( hyperv_enabled ( cpu ) ) {\n<31> if ( ! cpu -> hyperv_vendor_id ) {\n<32> memcpy ( signature , "Microsoft Hv" , 12 ) ;\n<35> size_t len = strlen ( cpu -> hyperv_vendor_id ) ;\n<36> if ( len > 12 ) {\n<38> len = 12 ;\n<40> memset ( signature , 0 , 12 ) ;\n<41> memcpy ( signature , cpu -> hyperv_vendor_id , len ) ;\n<44> c -> ebx = signature [ 0 ] ;\n<45> c -> ecx = signature [ 1 ] ;\n<46> c -> edx = signature [ 2 ] ;\n<49> memcpy ( signature , "Hv#1\0\0\0\0\0\0\0\0" , 12 ) ;\n<50> c -> eax = signature [ 0 ] ;\n<83> if ( cpu -> expose_kvm ) {\n<84> memcpy ( signature , "KVMKVMKVM\0\0\0" , 12 ) ;\n<88> c -> ebx = signature [ 0 ] ;\n<89> c -> ecx = signature [ 1 ] ;\n<90> c -> edx = signature [ 2 ] ;\n<96> cpu_x86_cpuid ( env , 0 , 0 , & limit , & unused , & unused , & unused ) ;\n<98> i <= limit ;\n<99> i ++ ) {\n<100> if ( cpuid_i == KVM_MAX_CPUID_ENTRIES ) {\n<101> fprintf ( stderr , "unsupported level value: 0x%x\n" , limit ) ;\n<113> j < times ;\n<115> if ( cpuid_i == KVM_MAX_CPUID_ENTRIES ) {\n<116> fprintf ( stderr , "cpuid_data is full, no space for " "cpuid(eax:2):eax & 0xf = 0x%x\n" , times ) ;\n<128> j ++ ) {\n<129> if ( i == 0xd && j == 64 ) {\n<135> cpu_x86_cpuid ( env , i , j , & c -> eax , & c -> ebx , & c -> ecx , & c -> edx ) ;\n<142> if ( i == 0xd && c -> eax == 0 ) {\n<145> if ( cpuid_i == KVM_MAX_CPUID_ENTRIES ) {\n<146> fprintf ( stderr , "cpuid_data is full, no space for " "cpuid(eax:0x%x,ecx:0x%x)\n" , i , j ) ;\n<160> j <= times ;\n<162> if ( cpuid_i == KVM_MAX_CPUID_ENTRIES ) {\n<163> fprintf ( stderr , "cpuid_data is full, no space for " "cpuid(eax:0x14,ecx:0x%x)\n" , j ) ;\n<168> c -> index = j ;\n<170> cpu_x86_cpuid ( env , i , j , & c -> eax , & c -> ebx , & c -> ecx , & c -> edx ) ;\n<197> cpu_x86_cpuid ( env , 0x80000000 , 0 , & limit , & unused , & unused , & unused ) ;\n<199> i <= limit ;\n<201> if ( cpuid_i == KVM_MAX_CPUID_ENTRIES ) {\n<202> fprintf ( stderr , "unsupported xlevel value: 0x%x\n" , limit ) ;\n<211> cpu_x86_cpuid ( env , 0xC0000000 , 0 , & limit , & unused , & unused , & unused ) ;\n<213> i <= limit ;\n<215> if ( cpuid_i == KVM_MAX_CPUID_ENTRIES ) {\n<216> fprintf ( stderr , "unsupported xlevel2 value: 0x%x\n" , limit ) ;\n<231> if ( ret < 0 ) {\n<232> fprintf ( stderr , "kvm_get_mce_cap_supported: %s" , strerror ( - ret ) ) ;\n<249> if ( ret < 0 ) {\n<250> fprintf ( stderr , "KVM_X86_SETUP_MCE: %s" , strerror ( - ret ) ) ;\n<285> r = kvm_vcpu_ioctl ( cs , KVM_SET_CPUID2 , & cpuid_data ) ;
<1> gs_main_instance * gs_main_alloc_instance ( gs_memory_t * mem ) {\n<5> if ( minst == NULL ) return NULL ;\n<6> memcpy ( minst , & gs_main_instance_init_values , sizeof ( gs_main_instance_init_values ) ) ;\n<8> mem -> gs_lib_ctx -> top_of_system = minst ;\n<9> return minst ;
<1> static int dirac_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *pkt)\n<23> if (s->all_frames[i].avframe->data[0] && !s->all_frames[i].avframe->reference) {\n<27> memset(s->all_frames[i].interpolated, 0, sizeof(s->all_frames[i].interpolated));
<1> int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n<4> BDRVQcowState *s = bs->opaque;\n<10> if (min_size <= s->l1_size)\n<27> new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n<28> memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n<33> g_free(new_l1_table);
<1> static int32_t findUnassigned ( UCMStates * states , uint16_t * unicodeCodeUnits , _MBCSToUFallback * toUFallbacks , int32_t countToUFallbacks , int32_t state , int32_t offset , uint32_t b ) {\n<15> else if ( savings > 0 ) {\n<16> printf ( " all-unassigned sequences from prefix 0x%02lx state %ld use %ld bytes\n" , ( unsigned long ) ( ( b << 8 ) | i ) , ( long ) state , ( long ) savings ) ;
<1> void net_slirp_smb(const char *exported_dir)\n<9> if (legacy_smb_export) {\n<11> fprintf(stderr, "-smb given twice\n");
<1> TSReturnCode TSCacheKeyHostNameSet ( TSCacheKey key , const char * hostname , int host_len ) {\n<5> if ( ( ( CacheInfo * ) key ) -> magic != CACHE_INFO_MAGIC_ALIVE ) {\n<8> CacheInfo * i = ( CacheInfo * ) key ;\n<9> i -> hostname = ( char * ) ats_malloc ( host_len ) ;\n<10> memcpy ( i -> hostname , hostname , host_len ) ;\n<11> i -> len = host_len ;
<1> const vpx_codec_cx_pkt_t * vpx_codec_get_cx_data ( vpx_codec_ctx_t * ctx , vpx_codec_iter_t * iter ) {\n<12> if ( dst_buf && pkt -> data . raw . buf != dst_buf && pkt -> data . raw . sz + priv -> enc . cx_data_pad_before + priv -> enc . cx_data_pad_after <= priv -> enc . cx_data_dst_buf . sz ) {\n<14> memcpy ( dst_buf + priv -> enc . cx_data_pad_before , pkt -> data . raw . buf , pkt -> data . raw . sz ) ;
<1> void *fw_cfg_modify_file(FWCfgState *s, const char *filename,\n<23> for (i = 0; i < index; i++) {\n<25> if (strcmp(filename, s->files->f[i].name) == 0) {\n<27> ptr = fw_cfg_modify_bytes_read(s, FW_CFG_FILE_FIRST + i,\n<31> s->files->f[i].size   = cpu_to_be32(len);\n<33> return ptr;\n<41> fw_cfg_add_file_callback(s, filename, NULL, NULL, NULL, data, len, true);
<1> static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)\n<11> unsigned char queue[QUEUE_SIZE];\n<39> memset(queue, 0x20, QUEUE_SIZE);\n<117> *d = queue[chainofs++ & QUEUE_MASK];
<1> static struct remote_lock * lock_remote ( const char * path , long timeout ) {\n<15> url = xstrfmt ( "%s%s" , repo -> url , path ) ;\n<16> ep = strchr ( url + strlen ( repo -> url ) + 1 , '/' ) ;\n<17> while ( ep ) {\n<18> char saved_character = ep [ 1 ] ;\n<22> curl_setup_http_get ( slot -> curl , url , DAV_MKCOL ) ;\n<23> if ( start_active_slot ( slot ) ) {\n<25> if ( results . curl_result != CURLE_OK && results . http_code != 405 ) {\n<26> fprintf ( stderr , "Unable to create branch path %s\n" , url ) ;\n<27> free ( url ) ;\n<32> fprintf ( stderr , "Unable to start MKCOL request\n" ) ;\n<33> free ( url ) ;\n<36> ep [ 1 ] = saved_character ;\n<37> ep = strchr ( ep + 1 , '/' ) ;\n<40> strbuf_addf ( & out_buffer . buf , LOCK_REQUEST , escaped ) ;\n<41> free ( escaped ) ;\n<47> curl_setup_http ( slot -> curl , url , DAV_LOCK , & out_buffer , fwrite_buffer ) ;\n<50> lock = xcalloc ( 1 , sizeof ( * lock ) ) ;\n<51> lock -> timeout = - 1 ;\n<52> if ( start_active_slot ( slot ) ) {\n<54> if ( results . curl_result == CURLE_OK ) {\n<57> ctx . name = xcalloc ( 10 , 1 ) ;\n<58> ctx . len = 0 ;\n<59> ctx . cdata = NULL ;\n<60> ctx . userFunc = handle_new_lock_ctx ;\n<61> ctx . userData = lock ;\n<66> free ( ctx . name ) ;\n<67> if ( result != XML_STATUS_OK ) {\n<68> fprintf ( stderr , "XML error: %s\n" , XML_ErrorString ( XML_GetErrorCode ( parser ) ) ) ;\n<69> lock -> timeout = - 1 ;\n<75> fprintf ( stderr , "Unable to start LOCK request\n" ) ;\n<80> if ( lock -> token == NULL || lock -> timeout <= 0 ) {\n<81> free ( lock -> token ) ;\n<82> free ( lock -> owner ) ;\n<83> free ( url ) ;\n<84> free ( lock ) ;\n<93> return lock ;
<1> static afs_int32 newEntry ( struct rx_call * call , char aname [ ] , afs_int32 flag , afs_int32 oid , afs_int32 * aid , afs_int32 * cid ) {\n<6> stolower ( aname ) ;\n<15> code = WhoIsThisWithName ( call , tt , cid , cname ) ;\n<18> if ( code == 2 ) {\n<19> if ( ! restricted && ( strcmp ( aname , cname ) == 0 ) ) {\n<20> if ( oid != 0 ) ABORT_WITH ( tt , PRPERM ) ;\n<21> admin = 1 ;\n<22> oid = SYSADMINID ;\n<23> * cid = SYSADMINID ;\n<27> code = CreateEntry ( tt , aname , aid , 0 , flag , oid , * cid ) ;
<1> static void short_usage_sub ( FILE * f ) {\n<2> fprintf ( f , "Usage: %s [OPTIONS] database [tables]\n" , my_progname_short ) ;\n<3> fprintf ( f , "OR %s [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]\n" , my_progname_short ) ;\n<4> fprintf ( f , "OR %s [OPTIONS] --all-databases [OPTIONS]\n" , my_progname_short ) ;
<1> void qemu_aio_coroutine_enter(AioContext *ctx, Coroutine *co)\n<7> fprintf(stderr, "Co-routine re-entered recursively\n");
<1> kern_return_t GetBSDPath( io_iterator_t mediaIterator, char *bsdPath, CFIndex maxPathSize )\n<9> *bsdPath = '\0';\n<21> if ( bsdPathAsCFString ) {\n<25> strcpy( bsdPath, _PATH_DEV );\n<27> strcat( bsdPath, "r" );\n<29> devPathLength = strlen( bsdPath );\n<31> if ( CFStringGetCString( bsdPathAsCFString, bsdPath + devPathLength, maxPathSize - devPathLength, kCFStringEncodingASCII ) ) {
<1> static void do_video_stats(OutputStream *ost, int frame_size)\n<15> if (!vstats_file) {\n<19> if (!vstats_file) {\n<33> if (enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n<35> frame_number = ost->frame_number;\n<37> fprintf(vstats_file, "frame= %5d q= %2.1f ", frame_number, enc->coded_frame->quality / (float)FF_QP2LAMBDA);\n<39> if (enc->flags&CODEC_FLAG_PSNR)\n<41> fprintf(vstats_file, "PSNR= %6.2f ", psnr(enc->coded_frame->error[0] / (enc->width * enc->height * 255.0 * 255.0)));\n<45> fprintf(vstats_file,"f_size= %6d ", frame_size);\n<57> bitrate     = (frame_size * 8) / av_q2d(enc->time_base) / 1000.0;\n<59> avg_bitrate = (double)(video_size * 8) / ti1 / 1000.0;\n<61> fprintf(vstats_file, "s_size= %8.0fkB time= %0.3f br= %7.1fkbits/s avg_br= %7.1fkbits/s ",\n<63> (double)video_size / 1024, ti1, bitrate, avg_bitrate);\n<65> fprintf(vstats_file, "type= %c\n", av_get_picture_type_char(enc->coded_frame->pict_type));
<1> int fill_schema_schema_privileges ( THD * thd , TABLE_LIST * tables , COND * cond ) {\n<8> bool no_global_access = check_access ( thd , SELECT_ACL , "mysql" , 0 , 1 , 1 , 0 ) ;\n<14> counter < acl_dbs . elements ;\n<15> counter ++ ) {\n<18> if ( ! ( user = acl_db -> user ) ) user = "" ;\n<20> if ( no_global_access && ( strcmp ( thd -> security_ctx -> priv_user , user ) || my_strcasecmp ( system_charset_info , curr_host , host ) ) ) continue ;\n<21> want_access = acl_db -> access ;\n<22> if ( want_access ) {\n<26> strxmov ( buff , "'" , user , "'@'" , host , "'" , NullS ) ;
<1> matroska_add_stream (MatroskaDemuxContext *matroska)\n<671> if ((res = ebml_read_ascii(matroska, &id, &text)) < 0)\n<711> if ((res = ebml_read_utf8(matroska, &id, &text)) < 0)\n<729> if ((res = ebml_read_utf8(matroska, &id, &text)) < 0)\n<747> if ((res = ebml_read_utf8(matroska, &id, &text)) < 0)\n<751> if ((end = strchr(text, '-')))\n<753> *end = '\0';\n<755> if (strlen(text) == 3)\n<757> strcpy(track->language, text);\n<759> av_free(text);
<1> static int mov_read_smi(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n<31> if (!st->codec->extradata)\n<37> memcpy(st->codec->extradata, "SVQ3", 4); // fake\n<39> avio_read(pb, st->codec->extradata + 0x5a, atom.size);
<1> static int tftp_session_allocate(Slirp *slirp, struct sockaddr_storage *srcsas,\n<19> if (!tftp_session_in_use(spt))\n<27> if ((int)(curtime - spt->timestamp) > 5000) {\n<29> tftp_session_terminate(spt);\n<45> memset(spt, 0, sizeof(*spt));\n<59> tftp_session_update(spt);
<1> static unsigned int pfkey_sockaddr_fill ( const xfrm_address_t * xaddr , __be16 port , struct sockaddr * sa , unsigned short family ) {\n<2> switch ( family ) {\n<4> struct sockaddr_in * sin = ( struct sockaddr_in * ) sa ;\n<8> memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ;
<1> static int wma_decode_superframe(AVCodecContext *avctx, void *data,\n<11> WMACodecContext *s = avctx->priv_data;\n<41> init_get_bits(&s->gb, buf, buf_size*8);\n<117> init_get_bits(&s->gb, s->last_superframe, MAX_CODED_SUPERFRAME_SIZE*8);\n<129> if (wma_decode_frame(s, samples) < 0)\n<161> if (wma_decode_frame(s, samples) < 0)\n<179> len = buf_size - pos;\n<181> if (len > MAX_CODED_SUPERFRAME_SIZE || len < 0) {\n<191> memcpy(s->last_superframe, buf + pos, len);
<1> int32_t scsi_send_command(SCSIDevice *s, uint32_t tag, uint8_t *buf, int lun)\n<29> DPRINTF("Command: 0x%02x", buf[0]);\n<35> lba = buf[3] | (buf[2] << 8) | ((buf[1] & 0x1f) << 16);\n<47> lba = buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24);\n<49> len = buf[8] | (buf[7] << 8);\n<57> lba = buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24);\n<59> len = buf[13] | (buf[12] << 8) | (buf[11] << 16) | (buf[10] << 24);\n<67> lba = buf[5] | (buf[4] << 8) | (buf[3] << 16) | (buf[2] << 24);\n<69> len = buf[9] | (buf[8] << 8) | (buf[7] << 16) | (buf[6] << 24);\n<101> if (lun || buf[1] >> 5) {\n<111> switch (s->command) {\n<123> if (len < 4)\n<127> memset(buf, 0, 4);\n<149> memset(s->buf, 0, 36);\n<151> if (bdrv_get_type_hint(s->bdrv) == BDRV_TYPE_CDROM) {\n<157> memcpy(&s->buf[16], "QEMU CD-ROM    ", 16);\n<163> memcpy(&s->buf[16], "QEMU HARDDISK  ", 16);\n<167> memcpy(&s->buf[8], "QEMU   ", 8);\n<169> memcpy(&s->buf[32], QEMU_VERSION, 4);\n<221> p = s->buf;\n<223> memset(p, 0, 4);\n<235> p += 4;\n<343> memset(s->buf, 0, 8);\n<419> switch(format) {\n<433> memset(s->buf, 0, 12);\n<479> memset(s->buf, 0, 8);\n<515> if (len < 16)\n<519> memset(s->buf, 0, 16);\n<533> scsi_command_complete(s, SENSE_ILLEGAL_REQUEST);\n<541> scsi_command_complete(s, SENSE_NO_SENSE);
<1> static int selinux_inode_setsecurity ( struct inode * inode , const char * name , const void * value , size_t size , int flags ) {\n<5> if ( strcmp ( name , XATTR_SELINUX_SUFFIX ) ) return - EOPNOTSUPP ;\n<6> if ( ! value || ! size ) return - EACCES ;
<1> static void test_persistent ( void ) {\n<5> memset ( rbuf , 0 , sizeof ( rbuf ) ) ;\n<8> i ++ ) wbuf [ i ] = i ;\n<16> if ( roff == woff ) test_ok = memcmp ( rbuf , wbuf , sizeof ( wbuf ) ) == 0 ;
<1> static char * cgroup_rename_nsgroup ( const char * mountpath , const char * oldname , pid_t pid , const char * name ) {\n<5> dir = alloca ( strlen ( oldname ) + 1 ) ;\n<6> strcpy ( dir , oldname ) ;\n<7> len = strlen ( oldname ) + strlen ( mountpath ) + 22 ;\n<8> fulloldpath = alloca ( len ) ;\n<9> ret = snprintf ( fulloldpath , len , "%s/%s/%ld" , mountpath , oldname , ( unsigned long ) pid ) ;\n<10> if ( ret < 0 || ret >= len ) return NULL ;\n<11> len = strlen ( dir ) + strlen ( name ) + 2 ;\n<12> newname = malloc ( len ) ;\n<13> if ( ! newname ) {\n<17> ret = snprintf ( newname , len , "%s/%s" , dir , name ) ;\n<18> if ( ret < 0 || ret >= len ) {\n<19> free ( newname ) ;\n<22> newlen = strlen ( mountpath ) + len + 2 ;\n<23> fullnewpath = alloca ( newlen ) ;\n<24> ret = snprintf ( fullnewpath , newlen , "%s/%s" , mountpath , newname ) ;\n<25> if ( ret < 0 || ret >= newlen ) {\n<26> free ( newname ) ;\n<30> if ( rmdir ( fullnewpath ) != 0 ) {\n<32> free ( newname ) ;\n<36> if ( rename ( fulloldpath , fullnewpath ) ) {\n<38> free ( newname ) ;
<1> static int dv_decode_video_segment(AVCodecContext *avctx, void *arg)\n<47> memset(sblock, 0, 5*DV_MAX_BPM*sizeof(*sblock));
<1> static void y4m_convert_mono_420jpeg ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) {\n<4> _dst += _y4m -> pic_w * _y4m -> pic_h ;\n<6> memset ( _dst , 128 , c_sz * 2 ) ;
<1> static int switch_db_collation ( FILE * sql_file , const char * db_name , const char * delimiter , const char * current_db_cl_name , const char * required_db_cl_name , int * db_cl_altered ) {\n<2> if ( strcmp ( current_db_cl_name , required_db_cl_name ) != 0 ) {\n<3> char quoted_db_buf [ NAME_LEN * 2 + 3 ] ;\n<4> char * quoted_db_name = quote_name ( db_name , quoted_db_buf , FALSE ) ;\n<5> CHARSET_INFO * db_cl = get_charset_by_name ( required_db_cl_name , MYF ( 0 ) ) ;\n<6> if ( ! db_cl ) return 1 ;\n<7> fprintf ( sql_file , "ALTER DATABASE %s CHARACTER SET %s COLLATE %s %s\n" , ( const char * ) quoted_db_name , ( const char * ) db_cl -> csname , ( const char * ) db_cl -> name , ( const char * ) delimiter ) ;\n<11> * db_cl_altered = 0 ;\n<12> return 0 ;
<1> av_cold static int lavfi_read_header(AVFormatContext *avctx)\n<71> if (!graph_buf) {\n<79> memcpy(graph_buf, file_buf, file_bufsize);\n<83> av_file_unmap(file_buf, file_bufsize);\n<85> lavfi->graph_str = graph_buf;\n<155> for (i = 0, inout = output_links; inout; i++, inout = inout->next) {\n<159> if (!strcmp(inout->name, "out"))\n<161> stream_idx = 0;\n<163> else if (sscanf(inout->name, "out%d\n", &stream_idx) != 1) {\n<167> "Invalid outpad name '%s'\n", inout->name);\n<169> FAIL(AVERROR(EINVAL));\n<175> if ((unsigned)stream_idx >= n) {\n<219> lavfi->sink_stream_map[i] = stream_idx;\n<283> ret = avfilter_graph_create_filter(&sink, buffersink,\n<315> ret = avfilter_graph_create_filter(&sink, abuffersink,
<1> size_t compile_tree ( struct filter_op * * fop ) {\n<5> if ( tree_root == NULL ) return 0 ;\n<6> fprintf ( stdout , " Unfolding the meta-tree " ) ;\n<7> fflush ( stdout ) ;\n<9> fprintf ( stdout , " done.\n\n" ) ;\n<11> TAILQ_FOREACH ( ue , & unfolded_tree , next ) {\n<12> if ( ue -> label == 0 ) {\n<13> SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ;\n<14> memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ;
<1> static void rv34_output_i16x16 ( RV34DecContext * r , int8_t * intra_types , int cbp ) {\n<9> memset ( block16 , 0 , 16 * sizeof ( * block16 ) ) ;\n<10> has_ac = rv34_decode_block ( block16 , gb , r -> cur_vlcs , 3 , 0 , q_dc , q_dc , q_ac ) ;
<1> static int read_block_types(AVCodecContext *avctx, GetBitContext *gb, Bundle *b)\n<7> int last = 0;\n<13> CHECK_READ_VAL(gb, b, t);\n<25> if (get_bits1(gb)) {\n<27> v = get_bits(gb, 4);\n<29> memset(b->cur_dec, v, t);\n<31> b->cur_dec += t;\n<39> if (v < 12) {\n<41> last = v;\n<47> int run = bink_rlelens[v - 12];\n<51> memset(b->cur_dec, last, run);\n<53> b->cur_dec += run;\n<57> } while (b->cur_dec < dec_end);
<1> static void DefaultFreeFunc ( void * opaque , void * address ) {\n<3> free ( address ) ;
<1> int kvm_arm_sync_mpstate_to_kvm(ARMCPU *cpu)\n<17> if (ret) {\n<19> fprintf(stderr, "%s: failed to set MP_STATE %d/%s\n",\n<21> __func__, ret, strerror(-ret));
<22> buf += 4 ;\n<23> if ( header_size == 8 ) buf += 4 ;\n<25> if ( avctx -> pix_fmt != pix_fmt && f -> data [ 0 ] ) {\n<78> y < avctx -> height ;\n<79> y ++ ) memcpy ( & f -> data [ 0 ] [ ( avctx -> height - y - 1 ) * f -> linesize [ 0 ] ] , & buf [ y * avctx -> width * 3 ] , 3 * avctx -> width ) ;
<1> void vnc_client_write(void *opaque)\n<39> if (!ret)\n<45> memmove(vs->output.buffer, vs->output.buffer + ret, (vs->output.offset - ret));
<1> int index_from_key(const char *key)\n<9> for (i = 0; QKeyCode_lookup[i] != NULL; i++) {\n<11> if (!strcmp(key, QKeyCode_lookup[i])) {
<1> static int str_read_packet(AVFormatContext *s,\n<25> if (avio_read(pb, sector, RAW_CD_SECTOR_SIZE) != RAW_CD_SECTOR_SIZE)\n<39> switch (sector[0x12] & CDXA_TYPE_MASK) {\n<51> int current_sector = AV_RL16(&sector[0x1C]);\n<53> int sector_count   = AV_RL16(&sector[0x1E]);\n<55> int frame_size = AV_RL32(&sector[0x24]);\n<63> && sector_count*VIDEO_DATA_CHUNK_SIZE >=frame_size)){\n<97> st->codec->width      = AV_RL16(&sector[0x28]);\n<99> st->codec->height     = AV_RL16(&sector[0x2A]);\n<107> pkt = &str->channels[channel].tmp_pkt;\n<111> if(pkt->size != sector_count*VIDEO_DATA_CHUNK_SIZE){\n<119> if (av_new_packet(pkt, sector_count*VIDEO_DATA_CHUNK_SIZE))\n<136> memcpy(pkt->data + current_sector*VIDEO_DATA_CHUNK_SIZE,\n<236> if (av_new_packet(pkt, 2304))\n<240> memcpy(pkt->data,sector+24,2304);
<1> void dtls1_get_message_header ( unsigned char * data , struct hm_header_st * msg_hdr ) {\n<2> memset ( msg_hdr , 0x00 , sizeof ( struct hm_header_st ) ) ;\n<4> n2l3 ( data , msg_hdr -> msg_len ) ;\n<5> n2s ( data , msg_hdr -> seq ) ;\n<6> n2l3 ( data , msg_hdr -> frag_off ) ;\n<7> n2l3 ( data , msg_hdr -> frag_len ) ;
<1> static inline int mpeg4_decode_block(MpegEncContext * s, DCTELEM * block,\n<33> dc_pred_dir= (s->pred_dir_table[s->mb_x + s->mb_y*s->mb_width]<<n)&32;\n<37> level = mpeg4_decode_dc(s, n, &dc_pred_dir);\n<153> if(SHOW_UBITS(re, &s->gb, 1)==0){\n<155> fprintf(stderr, "1. marker bit missing in 3. esc\n");\n<167> if(SHOW_UBITS(re, &s->gb, 1)==0){\n<169> fprintf(stderr, "2. marker bit missing in 3. esc\n");\n<181> if(level*s->qscale>1024 || level*s->qscale<-1024){\n<183> fprintf(stderr, "|level| overflow in 3. esc, qp=%d\n", s->qscale);\n<199> if(abs_level <= rl->max_level[last][run]){\n<201> fprintf(stderr, "illegal 3. esc, vlc encoding possible\n");\n<207> if(abs_level <= rl->max_level[last][run]*2){\n<209> fprintf(stderr, "illegal 3. esc, esc 1 encoding possible\n");\n<215> if(run1 >= 0 && abs_level <= rl->max_level[last][run1]){\n<217> fprintf(stderr, "illegal 3. esc, esc 2 encoding possible\n");\n<307> if(i&(~63)){\n<309> fprintf(stderr, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);
<1> static void clipper_init(MachineState *machine)\n<35> memset(cpus, 0, sizeof(cpus));\n<55> pci_bus = typhoon_init(ram_size, &isa_bus, &rtc_irq, cpus,
<1> static void sd_reset(SDState *sd, BlockDriverState *bdrv)\n<47> sd_set_sdstatus(sd);\n<63> memset(sd->function_group, 0, sizeof(int) * 6);
<1> static void tlb_flush_nocheck(CPUState *cpu)\n<5> CPUArchState *env = cpu->env_ptr;\n<15> if (!tcg_enabled()) {\n<23> assert_cpu_is_self(cpu);\n<33> memset(env->tlb_table, -1, sizeof(env->tlb_table));\n<35> memset(env->tlb_v_table, -1, sizeof(env->tlb_v_table));\n<37> memset(cpu->tb_jmp_cache, 0, sizeof(cpu->tb_jmp_cache));
<1> static int alloc_buffer(AVCodecContext *s, InputStream *ist, FrameBuffer **pbuf)\n<37> if ((ret = av_image_alloc(buf->base, buf->linesize, w, h,\n<57> memset(buf->base[0], 128, ret);
<1> int net_init_slirp(QemuOpts *opts, const char *name, VLANState *vlan)\n<51> restrict_opt = qemu_opt_get(opts, "restrict");\n<53> if (restrict_opt) {\n<55> if (!strcmp(restrict_opt, "on") ||\n<57> !strcmp(restrict_opt, "yes") || !strcmp(restrict_opt, "y")) {\n<59> restricted = 1;\n<61> } else if (strcmp(restrict_opt, "off") &&\n<63> strcmp(restrict_opt, "no") && strcmp(restrict_opt, "n")) {\n<65> error_report("invalid option: 'restrict=%s'", restrict_opt);\n<67> return -1;\n<75> if (qemu_opt_get(opts, "ip")) {\n<77> const char *ip = qemu_opt_get(opts, "ip");\n<79> int l = strlen(ip) + strlen("/24") + 1;\n<83> vnet = g_malloc(l);\n<89> pstrcpy(vnet, l, ip);\n<97> if (qemu_opt_get(opts, "net")) {\n<111> qemu_opt_foreach(opts, net_init_slirp_configs, NULL, 0);\n<115> ret = net_slirp_init(vlan, "user", name, restricted, vnet, vhost,\n<123> while (slirp_configs) {\n<135> g_free(vnet);\n<139> return ret;
<1> int qemuMonitorTextGetBlockStatsParamsNumber ( qemuMonitorPtr mon , int * nparams ) {\n<2> char * info = NULL ;\n<6> if ( qemuMonitorHMPCommand ( mon , "info blockstats" , & info ) < 0 ) {\n<10> if ( strstr ( info , "\ninfo " ) ) {\n<11> qemuReportError ( VIR_ERR_OPERATION_INVALID , "%s" , _ ( "'info blockstats' not supported by this qemu" ) ) ;\n<14> p = info ;\n<15> eol = strchr ( p , '\n' ) ;\n<16> if ( ! eol ) eol = p + strlen ( p ) ;\n<17> p = strchr ( p , ' ' ) ;\n<18> while ( p && p < eol ) {\n<19> if ( STRPREFIX ( p , " rd_bytes=" ) || STRPREFIX ( p , " wr_bytes=" ) || STRPREFIX ( p , " rd_operations=" ) || STRPREFIX ( p , " wr_operations=" ) || STRPREFIX ( p , " rd_total_times_ns=" ) || STRPREFIX ( p , " wr_total_times_ns=" ) || STRPREFIX ( p , " flush_operations=" ) || STRPREFIX ( p , " flush_total_times_ns=" ) ) {\n<23> VIR_DEBUG ( "unknown block stat near %s" , p ) ;\n<25> p = strchr ( p + 1 , ' ' ) ;\n<27> * nparams = num ;\n<28> ret = 0 ;\n<29> cleanup : VIR_FREE ( info ) ;
<1> int ff_vp8_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<17> if ((ret = decode_frame_header(s, avpkt->data, avpkt->size)) < 0)\n<41> if (avctx->skip_frame >= skip_thresh) {\n<45> memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);\n<113> if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||\n<137> if ((ret = vp8_alloc_frame(s, curframe, referenced))) {\n<193> memset(s->top_nnz, 0, s->mb_width * sizeof(*s->top_nnz));\n<199> if (!s->mb_layout)\n<201> memset(s->macroblocks + s->mb_height * 2 - 1, 0,\n<203> (s->mb_width + 1) * sizeof(*s->macroblocks));\n<205> if (!s->mb_layout && s->keyframe)\n<207> memset(s->intra4x4_pred_mode_top, DC_PRED, s->mb_width * 4);\n<211> memset(s->ref_count, 0, sizeof(s->ref_count));\n<267> memcpy(&s->framep[0], &s->next_framep[0], sizeof(s->framep[0]) * 4);\n<299> memcpy(&s->next_framep[0], &s->framep[0], sizeof(s->framep[0]) * 4);
<1> static int mov_read_dref(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n<29> MOV_dref_t *dref = &sc->drefs[i];\n<95> if (!strncmp(dref->path, volume, volume_len)) {\n<97> len -= volume_len;\n<99> memmove(dref->path, dref->path+volume_len, len);\n<101> dref->path[len] = 0;\n<105> for (j = 0; j < len; j++)\n<107> if (dref->path[j] == ':')\n<109> dref->path[j] = '/';\n<111> av_log(c->fc, AV_LOG_DEBUG, "path %s\n", dref->path);
<1> static void selinux_inode_post_setxattr ( struct dentry * dentry , const char * name , const void * value , size_t size , int flags ) {\n<6> if ( strcmp ( name , XATTR_NAME_SELINUX ) ) {\n<7> return ;\n<9> rc = security_context_to_sid_force ( value , size , & newsid ) ;\n<10> if ( rc ) {
<1> void do_block ( enum block_cmd cmd , struct st_command * command ) {\n<2> char * p = command -> first_argument ;\n<18> expr_start = strchr ( p , '(' ) ;\n<19> if ( ! expr_start ++ ) die ( "missing '(' in %s" , cmd_name ) ;\n<58> var_init ( & v2 , 0 , 0 , 0 , 0 ) ;\n<62> case EQ_OP : if ( v . is_int ) v . int_val = ( v2 . is_int && v2 . int_val == v . int_val ) ;\n<63> else v . int_val = ! strcmp ( v . str_val , v2 . str_val ) ;\n<65> case NE_OP : if ( v . is_int ) v . int_val = ! ( v2 . is_int && v2 . int_val == v . int_val ) ;\n<66> else v . int_val = ( strcmp ( v . str_val , v2 . str_val ) != 0 ) ;\n<79> var_free ( & v2 ) ;\n<88> cur_block -> ok = ( v . int_val != 0 ) ;\n<91> p = v . str_val ;\n<103> var_free ( & v ) ;
<1> static int preallocate(BlockDriverState *bs)\n<83> if (meta.cluster_offset != 0) {\n<85> uint8_t buf[512];\n<87> memset(buf, 0, 512);\n<89> bdrv_write(bs->file, (meta.cluster_offset >> 9) + num - 1, buf, 1);
<1> static void test_bug9992 ( ) {\n<6> if ( ! opt_silent ) printf ( "Establishing a connection with option CLIENT_MULTI_STATEMENTS..\n" ) ;\n<8> if ( ! mysql_real_connect ( mysql1 , opt_host , opt_user , opt_password , opt_db ? opt_db : "test" , opt_port , opt_unix_socket , CLIENT_MULTI_STATEMENTS ) ) {\n<9> fprintf ( stderr , "Failed to connect to the database\n" ) ;\n<16> if ( rc ) {\n<17> fprintf ( stderr , "[%d] %s\n" , mysql_errno ( mysql1 ) , mysql_error ( mysql1 ) ) ;\n<20> if ( ! opt_silent ) printf ( "Testing mysql_store_result/mysql_next_result..\n" ) ;\n<26> if ( ! opt_silent ) fprintf ( stdout , "Got error, as expected:\n [%d] %s\n" , mysql_errno ( mysql1 ) , mysql_error ( mysql1 ) ) ;
<1> enum nss_status _nss_nis_setaliasent ( void ) {\n<4> if ( oldkey != NULL ) {\n<5> free ( oldkey ) ;
<1> int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n<33> if (used_memslots > hdev->vhost_ops->vhost_backend_memslots_limit(hdev)) {\n<35> fprintf(stderr, "vhost backend memory slots limit is less"
<1> static int register_interfaces ( extcap_parameters * extcap_conf , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n<10> const char * adb_check_port_templace = "%04x" "shell:cat /proc/%set/tcp" ;\n<19> char model_name [ MODEL_NAME_LENGTH_MAX ] ;\n<38> while ( pos < ( char * ) ( device_list + device_length ) ) {\n<40> pos = strchr ( pos , ' ' ) ;\n<41> i_pos = pos ;\n<42> result = ( int ) ( pos - prev_pos ) ;\n<43> pos = strchr ( pos , '\n' ) + 1 ;\n<44> if ( result >= ( int ) sizeof ( serial_number ) ) {\n<48> memcpy ( serial_number , prev_pos , result ) ;\n<49> serial_number [ result ] = '\0' ;\n<50> serial_number_length = strlen ( serial_number ) ;\n<51> model_name [ 0 ] = '\0' ;\n<52> model_pos = g_strstr_len ( i_pos , pos - i_pos , "model:" ) ;\n<55> if ( device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX ) {\n<56> memcpy ( model_name , model_pos + 6 , device_pos - model_pos - 6 - 1 ) ;\n<57> model_name [ device_pos - model_pos - 6 - 1 ] = '\0' ;\n<60> if ( model_name [ 0 ] == '\0' ) strcpy ( model_name , "unknown" ) ;\n<61> verbose_print ( "VERBOSE: Processing device: \"%s\" <%s>\n" , serial_number , model_name ) ;\n<64> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<76> response = adb_send_and_read ( sock , adb_tcpdump_help , helpful_packet , sizeof ( helpful_packet ) , & data_length ) ;\n<78> if ( response ) {\n<79> response [ data_length ] = '\0' ;\n<80> if ( strstr ( response , "tcpdump version" ) ) {\n<81> new_interface ( extcap_conf , INTERFACE_ANDROID_WIFI_TCPDUMP , model_name , serial_number , "Android WiFi" ) ;\n<90> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<115> new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_EVENTS , model_name , serial_number , "Android Logcat Events" ) ;\n<122> new_interface ( extcap_conf , INTERFACE_ANDROID_LOGCAT_TEXT_CRASH , model_name , serial_number , "Android Logcat Crash" ) ;\n<128> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<158> new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_HCIDUMP , model_name , serial_number , "Android Bluetooth Hcidump" ) ;\n<165> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<179> if ( ! response || data_length < 1 ) {\n<187> memset ( pid , 0 , sizeof ( pid ) ) ;\n<188> response [ data_length ] = '\0' ;\n<189> data_str = strchr ( response , '\n' ) ;\n<190> if ( data_str && sscanf ( data_str , "%*s %15s" , pid ) == 1 ) {\n<191> verbose_print ( "VERBOSE: Android Bluetooth application PID for %s is %s\n" , serial_number , pid ) ;\n<192> sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n<193> if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_1 ;\n<194> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<201> if ( result ) {\n<206> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n<214> if ( ! response ) {\n<218> response [ data_length ] = '\0' ;\n<219> data_str = strchr ( response , '\n' ) ;\n<220> if ( data_str && sscanf ( data_str , "%*s %15s" , pid ) == 1 && strlen ( pid ) > 10 && strcmp ( pid + 9 , "10EA" ) == 0 ) {\n<221> verbose_print ( "VERBOSE: Bluedroid External Parser Port for %s is %s\n" , serial_number , pid + 9 ) ;\n<224> disable_interface = 1 ;\n<225> verbose_print ( "VERBOSE: Bluedroid External Parser Port for %s is unknown\n" , serial_number ) ;\n<230> disable_interface = 1 ;\n<231> verbose_print ( "VERBOSE: Android Bluetooth application PID for %s is unknown\n" , serial_number ) ;\n<234> if ( ! disable_interface ) {\n<235> new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER , model_name , serial_number , "Android Bluetooth External Parser" ) ;\n<238> if ( api_level >= 21 ) {\n<242> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<259> if ( ! response || data_length < 1 ) {\n<267> memset ( pid , 0 , sizeof ( pid ) ) ;\n<268> response [ data_length ] = '\0' ;\n<269> data_str = strchr ( response , '\n' ) ;\n<270> if ( data_str && sscanf ( data_str , "%*s %15s" , pid ) == 1 ) {\n<271> verbose_print ( "VERBOSE: Android Bluetooth application PID for %s is %s\n" , serial_number , pid ) ;\n<272> sock = adb_connect ( adb_server_ip , adb_server_tcp_port ) ;\n<273> if ( sock == INVALID_SOCKET ) return EXIT_CODE_INVALID_SOCKET_2 ;\n<274> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<281> if ( result ) {\n<286> result = g_snprintf ( ( char * ) helpful_packet , PACKET_LENGTH , adb_check_port_templace , strlen ( adb_check_port_templace ) - 6 + strlen ( pid ) , pid ) ;\n<294> if ( ! response ) {\n<298> response [ data_length ] = '\0' ;\n<299> data_str = strchr ( response , '\n' ) ;\n<300> if ( data_str && sscanf ( data_str , "%*s %15s" , pid ) == 1 && strlen ( pid ) > 10 && strcmp ( pid + 9 , "22A8" ) == 0 ) {\n<301> verbose_print ( "VERBOSE: Btsnoop Net Port for %s is %s\n" , serial_number , pid + 9 ) ;\n<304> disable_interface = 1 ;\n<305> verbose_print ( "VERBOSE: Btsnoop Net Port for %s is unknown\n" , serial_number ) ;\n<310> disable_interface = 1 ;\n<311> verbose_print ( "VERBOSE: Android Bluetooth application PID for %s is unknown\n" , serial_number ) ;\n<314> if ( ! disable_interface ) {\n<315> new_interface ( extcap_conf , INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET , model_name , serial_number , "Android Bluetooth Btsnoop Net" ) ;
<1> const gchar * proto_custom_set ( proto_tree * tree , GSList * field_ids , gint occurrence , gchar * result , gchar * expr , const int size ) {\n<68> if ( offset_r && ( offset_r < ( size - 2 ) ) ) result [ offset_r ++ ] = ',' ;\n<69> if ( offset_e && ( offset_e < ( size - 2 ) ) ) expr [ offset_e ++ ] = ',' ;\n<70> switch ( hfinfo -> type ) {\n<72> result [ 0 ] = '\0' ;\n<74> else if ( result [ offset_r - 1 ] == ',' ) {\n<75> result [ offset_r - 1 ] = '\0' ;\n<78> case FT_PROTOCOL : g_strlcpy ( result , "Yes" , size ) ;\n<99> offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n<104> offset_r += protoo_strlcpy ( result + offset_r , "<none>" , size - offset_r ) ;\n<107> offset_r += protoo_strlcpy ( result + offset_r , "<MISSING>" , size - offset_r ) ;\n<112> offset_r += protoo_strlcpy ( result + offset_r , tmpbuf , size - offset_r ) ;\n<116> offset_r += protoo_strlcpy ( result + offset_r , tmpbuf , size - offset_r ) ;\n<124> offset_r += protoo_strlcpy ( result + offset_r , number64 ? tfstring -> true_string : tfstring -> false_string , size - offset_r ) ;\n<125> offset_e += protoo_strlcpy ( expr + offset_e , number64 ? "1" : "0" , size - offset_e ) ;\n<134> offset_r += protoo_strlcpy ( result + offset_r , tmp , size - offset_r ) ;\n<139> offset_r += protoo_strlcpy ( result + offset_r , number_out , size - offset_r ) ;\n<143> offset_r += protoo_strlcpy ( result + offset_r , number_out , size - offset_r ) ;\n<146> g_snprintf ( expr + offset_e , size - offset_e , "\"%s\"" , hf_str_val ) ;\n<150> g_strlcpy ( expr + offset_e , number_out , size - offset_e ) ;\n<152> offset_e = ( int ) strlen ( expr ) ;\n<161> offset_r += protoo_strlcpy ( result + offset_r , tmp , size - offset_r ) ;\n<166> offset_r += protoo_strlcpy ( result + offset_r , number_out , size - offset_r ) ;\n<170> offset_r += protoo_strlcpy ( result + offset_r , number_out , size - offset_r ) ;\n<173> g_snprintf ( expr + offset_e , size - offset_e , "\"%s\"" , hf_str_val ) ;\n<177> g_strlcpy ( expr + offset_e , number_out , size - offset_e ) ;\n<179> offset_e = ( int ) strlen ( expr ) ;\n<182> offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n<188> address_to_str_buf ( & addr , result + offset_r , size - offset_r ) ;\n<189> offset_r = ( int ) strlen ( result ) ;\n<193> address_to_str_buf ( & addr , result + offset_r , size - offset_r ) ;\n<194> offset_r = ( int ) strlen ( result ) ;\n<197> address_to_str_buf ( & addr , result + offset_r , size - offset_r ) ;\n<198> offset_r = ( int ) strlen ( result ) ;\n<201> address_to_str_buf ( & addr , result + offset_r , size - offset_r ) ;\n<202> offset_r = ( int ) strlen ( result ) ;\n<205> offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n<210> offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n<213> offset_e += protoo_strlcpy ( expr + offset_e , str , size - offset_e ) ;\n<218> offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n<221> offset_e += protoo_strlcpy ( expr + offset_e , str , size - offset_e ) ;\n<226> offset_r += protoo_strlcpy ( result + offset_r , str , size - offset_r ) ;\n<227> offset_e += protoo_strlcpy ( expr + offset_e , str , size - offset_e ) ;\n<231> offset_r = ( int ) strlen ( result ) ;\n<234> offset_r = ( int ) strlen ( result ) ;\n<237> offset_r += protoo_strlcpy ( result + offset_r , hfinfo_format_text ( hfinfo , bytes ) , size - offset_r ) ;\n<240> g_snprintf ( result + offset_r , size - offset_r , "%s: %s" , hfinfo -> name , str ) ;\n<242> offset_r = ( int ) strlen ( result ) ;\n<245> g_snprintf ( result + offset_r , size - offset_r , "%s: %s" , hfinfo -> name , str ) ;\n<246> offset_r = ( int ) strlen ( result ) ;\n<257> default : g_strlcpy ( expr , result , size ) ;
<1> static inline void decode4x4 ( GetBitContext * gb , uint8_t * dst , int linesize ) {\n<2> int i , j , v [ 2 ] ;\n<4> case 1 : v [ 0 ] = get_bits ( gb , 8 ) ;\n<6> j < 4 ;\n<7> j ++ ) memset ( dst + j * linesize , v [ 0 ] , 4 ) ;
<1> static inline void strip_header ( char * header_bag , char * lc_header_bag , const char * lc_header_name ) {\n<2> char * lc_header_start = strstr ( lc_header_bag , lc_header_name ) ;\n<3> char * header_start = header_bag + ( lc_header_start - lc_header_bag ) ;\n<4> if ( lc_header_start && ( lc_header_start == lc_header_bag || * ( lc_header_start - 1 ) == '\n' ) ) {\n<5> char * lc_eol = strchr ( lc_header_start , '\n' ) ;\n<6> char * eol = header_start + ( lc_eol - lc_header_start ) ;\n<7> if ( lc_eol ) {\n<8> size_t eollen = strlen ( lc_eol ) ;\n<9> memmove ( lc_header_start , lc_eol + 1 , eollen ) ;\n<10> memmove ( header_start , eol + 1 , eollen ) ;
<1> int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n<11> if (!kvmppc_get_pvinfo(env, &pvinfo)) {\n<13> memcpy(buf, pvinfo.hcall, buf_len);
<1> static void write_picture(AVFormatContext *s, int index, AVPicture *picture,\n<13> size = avpicture_get_size(pix_fmt, w, h);\n<15> buf = malloc(size);\n<17> if (!buf)\n<27> switch(pix_fmt) {\n<31> dest = buf;\n<37> w >>= 1;\n<43> src = picture->data[i];\n<45> for(j=0;j<h;j++) {\n<47> memcpy(dest, src, w);\n<49> dest += w;\n<51> src += picture->linesize[i];\n<61> size = (w * h) * 2;\n<63> buf = malloc(size);\n<65> dest = buf;\n<71> w >>= 1;\n<75> src = picture->data[i];\n<77> for(j=0;j<h;j++) {\n<79> memcpy(dest, src, w);\n<81> dest += w;\n<83> src += picture->linesize[i];\n<93> size = (w * h) * 3;\n<95> buf = malloc(size);\n<97> dest = buf;\n<101> src = picture->data[i];\n<103> for(j=0;j<h;j++) {\n<105> memcpy(dest, src, w);\n<107> dest += w;\n<109> src += picture->linesize[i];\n<119> size = (w * h) * 2;\n<121> buf = malloc(size);\n<123> dest = buf;\n<125> src = picture->data[0];\n<127> for(j=0;j<h;j++) {\n<129> memcpy(dest, src, w * 2);\n<131> dest += w * 2;\n<133> src += picture->linesize[0];\n<143> size = (w * h) * 3;\n<145> buf = malloc(size);\n<147> dest = buf;\n<149> src = picture->data[0];\n<151> for(j=0;j<h;j++) {\n<153> memcpy(dest, src, w * 3);\n<155> dest += w * 3;\n<157> src += picture->linesize[0];\n<169> s->format->write_packet(s, index, buf, size);\n<171> free(buf);
<1> void printTextRange ( UChar * str , int32_t start , int32_t end ) {\n<7> charBuf [ sizeof ( charBuf ) - 1 ] = 0 ;\n<8> printf ( "string[%2d..%2d] \"%s\"\n" , start , end - 1 , charBuf ) ;
<1> static int decode_slice_header(H264Context *h){\n<105> init_dequant_tables(h);\n<139> free_tables(h);\n<153> if(s->dsp.h264_idct_add == ff_h264_idct_add_c){ //FIXME little ugly\n<155> memcpy(h->zigzag_scan, zigzag_scan, 16*sizeof(uint8_t));\n<157> memcpy(h-> field_scan,  field_scan, 16*sizeof(uint8_t));\n<177> if(s->dsp.h264_idct8_add == ff_h264_idct8_add_c){\n<179> memcpy(h->zigzag_scan8x8,       zigzag_scan8x8,       64*sizeof(uint8_t));\n<181> memcpy(h->zigzag_scan8x8_cavlc, zigzag_scan8x8_cavlc, 64*sizeof(uint8_t));\n<183> memcpy(h->field_scan8x8,        field_scan8x8,        64*sizeof(uint8_t));\n<185> memcpy(h->field_scan8x8_cavlc,  field_scan8x8_cavlc,  64*sizeof(uint8_t));\n<211> h->zigzag_scan_q0          = zigzag_scan;\n<213> h->zigzag_scan8x8_q0       = zigzag_scan8x8;\n<215> h->zigzag_scan8x8_cavlc_q0 = zigzag_scan8x8_cavlc;\n<217> h->field_scan_q0           = field_scan;\n<219> h->field_scan8x8_q0        = field_scan8x8;\n<221> h->field_scan8x8_cavlc_q0  = field_scan8x8_cavlc;\n<225> h->zigzag_scan_q0          = h->zigzag_scan;\n<227> h->zigzag_scan8x8_q0       = h->zigzag_scan8x8;\n<229> h->zigzag_scan8x8_cavlc_q0 = h->zigzag_scan8x8_cavlc;\n<231> h->field_scan_q0           = h->field_scan;\n<233> h->field_scan8x8_q0        = h->field_scan8x8;\n<235> h->field_scan8x8_cavlc_q0  = h->field_scan8x8_cavlc;\n<241> alloc_tables(h);\n<277> if(frame_start(h) < 0)\n<385> init_poc(h);\n<447> fill_default_ref_list(h);\n<453> if(decode_ref_pic_list_reordering(h) < 0)\n<463> pred_weight_table(h);\n<467> implicit_weight_table(h);\n<477> decode_ref_pic_marking(h);\n<483> fill_mbaff_ref_list(h);
<1> extern int main ( int argc , char * argv [ ] ) {\n<6> argc = u_parseArgs ( argc , argv , UPRV_LENGTHOF ( options ) , options ) ;\n<7> if ( argc < 0 ) {\n<8> fprintf ( stderr , "error in command line argument \"%s\"\n" , argv [ - argc ] ) ;\n<10> if ( argc < 0 || options [ kOptHelpH ] . doesOccur || options [ kOptHelpQuestionMark ] . doesOccur ) {\n<11> fprintf ( stderr , "usage: %s [-options] filename1 filename2 ...\n" "\tread each binary input file and \n" "\tcreate a .c file with a byte array that contains the input file's data\n" "options:\n" "\t-h or -? or --help this usage text\n" "\t-d or --destdir destination directory, followed by the path\n" "\t-n or --name symbol prefix, followed by the prefix\n" "\t-e or --entrypoint entry point name, followed by the name (_dat will be appended)\n" "\t-r or --revision Specify a version\n" , argv [ 0 ] ) ;\n<21> if ( ! checkAssemblyHeaderName ( options [ kOptAssembly ] . value ) ) {\n<22> fprintf ( stderr , "Assembly type \"%s\" is unknown.\n" , options [ kOptAssembly ] . value ) ;\n<31> message = "generating C code for %s\n" ;\n<35> filename = getLongPathname ( argv [ argc ] ) ;\n<36> if ( verbose ) {\n<37> fprintf ( stdout , message , filename ) ;\n<40> case CALL_WRITECCODE : writeCCode ( filename , options [ kOptDestDir ] . value , options [ kOptName ] . doesOccur ? options [ kOptName ] . value : NULL , options [ kOptFilename ] . doesOccur ? options [ kOptFilename ] . value : NULL , NULL ) ;\n<42> case CALL_WRITEASSEMBLY : writeAssemblyCode ( filename , options [ kOptDestDir ] . value , options [ kOptEntryPoint ] . doesOccur ? options [ kOptEntryPoint ] . value : NULL , options [ kOptFilename ] . doesOccur ? options [ kOptFilename ] . value : NULL , NULL ) ;
<1> void set_var ( struct ctl_var * * kv , const char * data , u_long size , u_short def ) {\n<6> if ( NULL == data || ! size ) return ;\n<8> if ( k != NULL ) {\n<9> while ( ! ( EOV & k -> flags ) ) {\n<10> if ( NULL == k -> text ) {\n<11> td = emalloc ( size ) ;\n<12> memcpy ( td , data , size ) ;\n<13> k -> text = td ;\n<24> if ( * s == * t && ( ( * t == '=' ) || ! * t ) ) {\n<25> td = erealloc ( ( void * ) ( intptr_t ) k -> text , size ) ;\n<26> memcpy ( td , data , size ) ;\n<27> k -> text = td ;\n<35> td = add_var ( kv , size , def ) ;\n<36> memcpy ( td , data , size ) ;
<1> static int ac3_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<3> const uint8_t * buf = avpkt -> data ;\n<5> AC3DecodeContext * s = avctx -> priv_data ;\n<8> const float * output [ AC3_MAX_CHANNELS ] ;\n<9> if ( buf_size >= 2 && AV_RB16 ( buf ) == 0x770B ) {\n<13> else memcpy ( s -> input_buffer , buf , FFMIN ( buf_size , AC3_FRAME_BUFFER_SIZE ) ) ;\n<14> buf = s -> input_buffer ;\n<16> err = parse_frame_header ( s ) ;\n<68> set_downmix_coeffs ( s ) ;\n<87> if ( ch < s -> out_channels ) s -> outptr [ channel_map [ ch ] ] = ( float * ) frame -> data [ ch ] ;\n<89> output [ ch ] = s -> output [ ch ] ;\n<94> if ( ! err && decode_audio_block ( s , blk ) ) {\n<99> ch < s -> out_channels ;\n<100> ch ++ ) memcpy ( s -> outptr [ channel_map [ ch ] ] , output [ ch ] , 1024 ) ;\n<104> output [ ch ] = s -> outptr [ channel_map [ ch ] ] ;\n<105> s -> outptr [ channel_map [ ch ] ] += AC3_BLOCK_SIZE ;\n<109> ch < s -> out_channels ;\n<110> ch ++ ) memcpy ( s -> output [ ch ] , output [ ch ] , 1024 ) ;
<1> static int parse_object_segment(AVCodecContext *avctx,\n<29> id = bytestream_get_be16(&buf);\n<33> if (!object) {\n<43> object = &ctx->objects.object[ctx->objects.count++];\n<53> buf += 1;\n<59> sequence_desc = bytestream_get_byte(&buf);\n<67> if (buf_size > object->rle_remaining_len)\n<73> memcpy(object->rle + object->rle_data_len, buf, buf_size);\n<75> object->rle_data_len += buf_size;\n<77> object->rle_remaining_len -= buf_size;\n<97> rle_bitmap_len = bytestream_get_be24(&buf) - 2*2;\n<101> if (buf_size > rle_bitmap_len) {\n<117> width  = bytestream_get_be16(&buf);\n<119> height = bytestream_get_be16(&buf);\n<141> av_fast_padded_malloc(&object->rle, &object->rle_buffer_size, rle_bitmap_len);\n<145> if (!object->rle)\n<151> memcpy(object->rle, buf, buf_size);\n<153> object->rle_data_len = buf_size;\n<155> object->rle_remaining_len = rle_bitmap_len - buf_size;
<1> int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n<11> av_dlog(NULL, "%X %X %X %X\n", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n<29> if(!*buf_size && next == END_NOT_FOUND){\n<43> if(next == END_NOT_FOUND){\n<49> if(!new_buffer)\n<53> pc->buffer = new_buffer;\n<55> memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n<57> pc->index += *buf_size;\n<79> if(!new_buffer)\n<83> pc->buffer = new_buffer;\n<86> memcpy(&pc->buffer[pc->index], *buf, next + FF_INPUT_BUFFER_PADDING_SIZE );
<1> static void test_io(void)\n<29> iov_random(&iov, &niov);\n<41> iov_from_buf(iov, niov, 0, buf, sz);\n<45> siov = g_malloc(sizeof(*iov) * niov);\n<47> memcpy(siov, iov, sizeof(*iov) * niov);\n<87> for (j = i; j <= sz; ++j) {\n<95> r = iov_send(sv[1], iov, niov, k, s);\n<97> g_assert(memcmp(iov, siov, sizeof(*iov)*niov) == 0);\n<121> } while(k < j);\n<156> for (j = i; j <= sz; ++j) {\n<160> iov_memset(iov, niov, 0, 0xff, -1);\n<166> r = iov_recv(sv[0], iov, niov, k, s);\n<168> g_assert(memcmp(iov, siov, sizeof(*iov)*niov) == 0);\n<198> } while(k < j);\n<200> test_iov_bytes(iov, niov, i, j - i);
<1> int wpa_sess_get ( u_char * sta , struct wpa_sa * sa ) {\n<4> LIST_FOREACH ( e , & wpa_sess_root , next ) {\n<5> if ( ! memcmp ( & e -> sta , sta , ETH_ADDR_LEN ) ) {\n<6> memcpy ( sa , & e -> sa , sizeof ( struct wpa_sa ) ) ;\n<7> pthread_mutex_unlock ( & root_mutex ) ;\n<8> return E_SUCCESS ;\n<11> pthread_mutex_unlock ( & root_mutex ) ;\n<12> return - E_NOTFOUND ;
<1> int setup_listen_socket ( const sockaddr_t * sa ) {\n<30> if ( bind ( nfd , & sa -> sa , SALEN ( sa -> sa ) ) ) {\n<33> logger ( LOG_ERR , "Can't bind to %s/tcp: %s" , addrstr , sockstrerror ( sockerrno ) ) ;\n<34> free ( addrstr ) ;
<1> int ff_vc1_parse_frame_header(VC1Context *v, GetBitContext* gb)\n<65> if (read_bfraction(v, gb) < 0)\n<181> rotate_luts(v);\n<263> memset(v->mv_type_mb_plane, 0, v->s.mb_stride * v->s.mb_height);\n<267> status = bitplane_decoding(v->s.mbskip_table, &v->skip_is_raw, v);\n<291> vop_dquant_decoding(v);
<1> xsltDocumentPtr xsltNewStyleDocument ( xsltStylesheetPtr style , xmlDocPtr doc ) {\n<4> if ( cur == NULL ) {\n<8> memset ( cur , 0 , sizeof ( xsltDocument ) ) ;\n<12> style -> docList = cur ;\n<14> return ( cur ) ;
<1> static void moxiesim_init(MachineState *machine)\n<41> if (!cpu) {\n<43> fprintf(stderr, "Unable to find CPU definition\n");
<1> int ff_mjpeg_find_marker(MJpegDecodeContext *s,\n<17> av_fast_padded_malloc(&s->buffer, &s->buffer_size, buf_end - *buf_ptr);\n<19> if (!s->buffer)\n<27> if (start_code == SOS && !s->ls) {\n<69> *unescaped_buf_size = dst - s->buffer;\n<81> } else if (start_code == SOS && s->ls) {\n<159> *unescaped_buf_size = (bit_count + 7) >> 3;
<1> int kvmppc_remove_spapr_tce(void *table, int fd, uint32_t window_size)\n<23> fprintf(stderr, "KVM: Unexpected error removing KVM SPAPR TCE "\n<25> "table: %s", strerror(errno));
<1> static int zcvrs ( i_ctx_t * i_ctx_p ) {\n<8> if ( radix == 10 ) {\n<44> memcpy ( op -> value . bytes , dp , ( uint ) ( endp - dp ) ) ;\n<45> r_set_size ( op , endp - dp ) ;
<1> static int do_token_setup(USBDevice *s, USBPacket *p)\n<11> if (p->len != 8)\n<16> memcpy(s->setup_buf, p->data, 8);
<1> static int ebml_parse_elem ( MatroskaDemuxContext * matroska , EbmlSyntax * syntax , void * data ) {\n<12> if ( ( res = av_reallocp_array ( & list -> elem , list -> nb_elem + 1 , syntax -> list_elem_size ) ) < 0 ) {\n<16> data = ( char * ) list -> elem + list -> nb_elem * syntax -> list_elem_size ;\n<17> memset ( data , 0 , syntax -> list_elem_size ) ;\n<29> case EBML_UINT : res = ebml_read_uint ( pb , length , data ) ;\n<31> case EBML_FLOAT : res = ebml_read_float ( pb , length , data ) ;\n<33> case EBML_STR : case EBML_UTF8 : res = ebml_read_ascii ( pb , length , data ) ;\n<35> case EBML_BIN : res = ebml_read_binary ( pb , length , data ) ;\n<39> return ebml_parse_nest ( matroska , syntax -> def . n , data ) ;\n<40> case EBML_PASS : return ebml_parse_id ( matroska , syntax -> def . n , id , data ) ;
<1> static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,\n<43> if (!(line = av_malloc(len)))\n<47> snprintf(line,len,"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s",\n<55> pkt->size = strlen(line);
<1> void check_comment_sanity ( int * e ) {\n<2> if ( ! strcmp ( comment_author , "" ) ) error [ ( * e ) ++ ] . message = strdup ( "Author name was not entered" ) ;\n<3> if ( ! strcmp ( comment_data , "" ) ) error [ ( * e ) ++ ] . message = strdup ( "Comment data was not entered" ) ;
<1> static int dirac_decode_data_unit(AVCodecContext *avctx, const uint8_t *buf, int size)\n<123> if (buf[13] == 1) {     /* encoder implementation/version */\n<125> int ver[3];\n<131> if (sscanf(buf+14, "Schroedinger %d.%d.%d", ver, ver+1, ver+2) == 3)\n<133> if (ver[0] == 1 && ver[1] == 0 && ver[2] <= 7)
<1> static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)\n<7> DxaDecContext * const c = avctx->priv_data;\n<35> c->pal[i] = 0xFFU << 24 | bytestream2_get_be24(&gb);\n<45> if ((ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n<49> memcpy(frame->data[1], c->pal, AVPALETTE_SIZE);\n<55> outptr = frame->data[0];\n<57> srcptr = c->decomp_buf;\n<75> dsize = c->dsize;\n<81> if (uncompress(c->decomp_buf, &dsize, avpkt->data + bytestream2_tell(&gb),\n<91> memset(c->decomp_buf + dsize, 0, DECOMP_BUF_PADDING);\n<99> av_log(avctx, AV_LOG_DEBUG, "compr:%2d, dsize:%d\n", compr, (int)dsize);\n<111> if (c->prev->data[0])\n<113> memcpy(frame->data[0], c->prev->data[0], frame->linesize[0] * avctx->height);\n<117> memset(frame->data[0], 0, frame->linesize[0] * avctx->height);\n<135> for (j = 0; j < avctx->height; j++) {\n<137> memcpy(outptr, srcptr, avctx->width);\n<139> outptr += stride;\n<141> srcptr += avctx->width;\n<153> av_log(avctx, AV_LOG_ERROR, "Missing reference frame.\n");\n<167> if(tmpptr){\n<169> for(i = 0; i < avctx->width; i++)\n<171> outptr[i] = srcptr[i] ^ tmpptr[i];\n<177> memcpy(outptr, srcptr, avctx->width);\n<179> outptr += stride;\n<181> srcptr += avctx->width;\n<203> decode_13(avctx, c, frame->data[0], frame->linesize[0], srcptr, c->prev->data[0]);
<1> static const char * cmd_cookiev0_separator ( cmd_parms * cmd , void * _dcfg , const char * p1 ) {\n<3> if ( strlen ( p1 ) != 1 ) {\n<4> return apr_psprintf ( cmd -> pool , "ModSecurity: Invalid cookie v0 separator: %s" , p1 ) ;\n<6> dcfg -> cookiev0_separator = p1 ;\n<7> return NULL ;
<1> static int capture_android_logcat ( char * interface , char * fifo , const char * adb_server_ip , unsigned short * adb_server_tcp_port ) {\n<3> static char packet [ PACKET_LENGTH ] ;\n<6> size_t used_buffer_length = 0 ;\n<16> static const char * wireshark_protocol_logcat = "logcat" ;\n<17> static const char * wireshark_protocol_logcat_events = "logcat_events" ;\n<35> exported_pdu_header_protocol_events . length = GUINT16_TO_BE ( strlen ( wireshark_protocol_logcat_events ) + 2 ) ;\n<37> exported_pdu_header_protocol_normal . length = GUINT16_TO_BE ( strlen ( wireshark_protocol_logcat ) + 2 ) ;\n<40> if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_MAIN ) && strlen ( interface ) > strlen ( INTERFACE_ANDROID_LOGCAT_MAIN ) + 1 ) {\n<41> serial_number = interface + strlen ( INTERFACE_ANDROID_LOGCAT_MAIN ) + 1 ;\n<43> else if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_SYSTEM ) && strlen ( interface ) > strlen ( INTERFACE_ANDROID_LOGCAT_SYSTEM ) + 1 ) {\n<44> serial_number = interface + strlen ( INTERFACE_ANDROID_LOGCAT_SYSTEM ) + 1 ;\n<46> else if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_RADIO ) && strlen ( interface ) > strlen ( INTERFACE_ANDROID_LOGCAT_RADIO ) + 1 ) {\n<47> serial_number = interface + strlen ( INTERFACE_ANDROID_LOGCAT_RADIO ) + 1 ;\n<49> else if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_EVENTS ) && strlen ( interface ) > strlen ( INTERFACE_ANDROID_LOGCAT_EVENTS ) + 1 ) {\n<50> serial_number = interface + strlen ( INTERFACE_ANDROID_LOGCAT_EVENTS ) + 1 ;\n<52> if ( ! serial_number ) {\n<61> serial_number_length = strlen ( serial_number ) ;\n<62> result = g_snprintf ( packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<68> result = adb_send ( sock , packet ) ;\n<75> if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_MAIN ) ) adb_command = adb_log_main ;\n<76> else if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_SYSTEM ) ) adb_command = adb_log_system ;\n<77> else if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_RADIO ) ) adb_command = adb_log_radio ;\n<78> else if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_EVENTS ) ) adb_command = adb_log_events ;\n<84> result = adb_send ( sock , adb_command ) ;\n<85> if ( result ) {\n<90> if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_EVENTS ) ) {\n<91> protocol_name = wireshark_protocol_logcat_events ;\n<92> exported_pdu_header_protocol = & exported_pdu_header_protocol_events ;\n<95> protocol_name = wireshark_protocol_logcat ;\n<96> exported_pdu_header_protocol = & exported_pdu_header_protocol_normal ;\n<98> memcpy ( packet , exported_pdu_header_protocol , sizeof ( struct exported_pdu_header ) ) ;\n<99> exported_pdu_headers_size += sizeof ( struct exported_pdu_header ) ;\n<100> memcpy ( packet + exported_pdu_headers_size , protocol_name , GUINT16_FROM_BE ( exported_pdu_header_protocol -> length ) - 2 ) ;\n<101> exported_pdu_headers_size += GUINT16_FROM_BE ( exported_pdu_header_protocol -> length ) ;\n<102> packet [ exported_pdu_headers_size - 1 ] = 0 ;\n<103> packet [ exported_pdu_headers_size - 2 ] = 0 ;\n<104> memcpy ( packet + exported_pdu_headers_size , & exported_pdu_header_end , sizeof ( struct exported_pdu_header ) ) ;\n<105> exported_pdu_headers_size += sizeof ( struct exported_pdu_header ) + GUINT16_FROM_BE ( exported_pdu_header_end . length ) ;\n<106> SET_DATA ( payload_length , value_u16 , packet + exported_pdu_headers_size + 0 ) ;\n<107> SET_DATA ( try_header_size , value_u16 , packet + exported_pdu_headers_size + 2 ) ;\n<108> SET_DATA ( timestamp_secs , value_u32 , packet + exported_pdu_headers_size + 12 ) ;\n<109> SET_DATA ( timestamp_nsecs , value_u32 , packet + exported_pdu_headers_size + 16 ) ;\n<110> while ( endless_loop ) {\n<112> length = recv ( sock , packet + exported_pdu_headers_size + used_buffer_length , ( int ) ( PACKET_LENGTH - exported_pdu_headers_size - used_buffer_length ) , 0 ) ;\n<116> else if ( errno != 0 ) {\n<117> errmsg_print ( "ERROR capture: %s" , strerror ( errno ) ) ;\n<118> closesocket ( sock ) ;\n<121> if ( length <= 0 ) {\n<125> closesocket ( sock ) ;\n<137> result = g_snprintf ( ( char * ) helper_packet , PACKET_LENGTH , adb_transport_serial_templace , 15 + serial_number_length , serial_number ) ;\n<151> else if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_SYSTEM ) ) adb_command = adb_log_system ;\n<152> else if ( is_specified_interface ( interface , INTERFACE_ANDROID_LOGCAT_RADIO ) ) adb_command = adb_log_radio ;\n<159> result = adb_send ( sock , adb_command ) ;\n<171> while ( used_buffer_length >= exported_pdu_headers_size + header_size && ( size_t ) length <= used_buffer_length ) {\n<172> endless_loop = extcap_dumper_dump ( extcap_dumper , packet , length , length , * timestamp_secs , * timestamp_nsecs ) ;\n<173> memmove ( packet + exported_pdu_headers_size , packet + length , used_buffer_length - length ) ;\n<180> used_buffer_length -= exported_pdu_headers_size ;\n<182> closesocket ( sock ) ;
<1> OFCondition parseAssociate ( unsigned char * buf , unsigned long pduLength , PRV_ASSOCIATEPDU * assoc ) {\n<6> ( void ) memset ( assoc , 0 , sizeof ( * assoc ) ) ;\n<9> if ( pduLength < 2 + 2 + 16 + 16 + 32 ) return makeLengthError ( "associate PDU" , pduLength , 2 + 2 + 16 + 16 + 32 ) ;\n<12> EXTRACT_LONG_BIG ( buf , assoc -> length ) ;\n<14> EXTRACT_SHORT_BIG ( buf , assoc -> protocol ) ;\n<17> if ( ( assoc -> protocol & DUL_PROTOCOL ) == 0 ) {\n<25> assoc -> rsv2 [ 1 ] = * buf ++ ;\n<27> ( void ) strncpy ( assoc -> calledAPTitle , ( char * ) buf , 16 ) ;\n<29> trim_trailing_spaces ( assoc -> calledAPTitle ) ;\n<30> buf += 16 ;\n<32> ( void ) strncpy ( assoc -> callingAPTitle , ( char * ) buf , 16 ) ;\n<34> trim_trailing_spaces ( assoc -> callingAPTitle ) ;\n<35> buf += 16 ;\n<37> ( void ) memcpy ( assoc -> rsv3 , buf , 32 ) ;\n<38> buf += 32 ;\n<43> if ( assoc -> type == DUL_TYPEASSOCIATERQ ) s = "A-ASSOCIATE RQ" ;\n<44> else if ( assoc -> type == DUL_TYPEASSOCIATEAC ) s = "A-ASSOCIATE AC" ;\n<51> switch ( type ) {\n<52> case DUL_TYPEAPPLICATIONCONTEXT : cond = parseSubItem ( & assoc -> applicationContext , buf , & itemLength , pduLength ) ;\n<59> case DUL_TYPEPRESENTATIONCONTEXTRQ : case DUL_TYPEPRESENTATIONCONTEXTAC : context = ( PRV_PRESENTATIONCONTEXTITEM * ) malloc ( sizeof ( PRV_PRESENTATIONCONTEXTITEM ) ) ;\n<60> if ( context == NULL ) return EC_MemoryExhausted ;\n<61> ( void ) memset ( context , 0 , sizeof ( * context ) ) ;\n<62> cond = parsePresentationContext ( type , context , buf , & itemLength , pduLength ) ;\n<66> LST_Enqueue ( & assoc -> presentationContextList , ( LST_NODE * ) context ) ;\n<69> case DUL_TYPEUSERINFO : cond = parseUserInfo ( & assoc -> userInfo , buf , & itemLength , assoc -> type , pduLength ) ;
<1> static void stereo_processing(PSContext *ps, float (*l)[32][2], float (*r)[32][2], int is34)\n<45> if (ps->num_env_old) {\n<47> memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));\n<49> memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));\n<51> memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));\n<53> memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));\n<55> memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));\n<57> memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));\n<59> memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));\n<61> memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));\n<83> map_val_20_to_34(H11[0][0]);\n<85> map_val_20_to_34(H11[1][0]);\n<87> map_val_20_to_34(H12[0][0]);\n<89> map_val_20_to_34(H12[1][0]);\n<91> map_val_20_to_34(H21[0][0]);\n<93> map_val_20_to_34(H21[1][0]);\n<95> map_val_20_to_34(H22[0][0]);\n<97> map_val_20_to_34(H22[1][0]);\n<119> map_val_34_to_20(H11[0][0]);\n<121> map_val_34_to_20(H11[1][0]);\n<123> map_val_34_to_20(H12[0][0]);\n<125> map_val_34_to_20(H12[1][0]);\n<127> map_val_34_to_20(H21[0][0]);\n<129> map_val_34_to_20(H21[1][0]);\n<131> map_val_34_to_20(H22[0][0]);\n<133> map_val_34_to_20(H22[1][0]);
<1> int main ( int argc , char * * argv ) {\n<12> tmpJobID [ 0 ] = '\0' ;\n<14> switch ( ArgIndex ) {\n<17> case 'j' : strncpy ( tmpJobID , optarg , sizeof ( tmpJobID ) ) ;\n<18> if ( tmpJobID [ PBS_MAXCLTJOBID - 1 ] != '\0' ) {\n<19> fprintf ( stderr , "pbs_track: given job ID too large (> %d)\n" , PBS_MAXCLTJOBID ) ;
<1> static void test_bug15510 ( ) {\n<4> const char * query = "select 1 from dual where 1/0" ;\n<8> stmt = mysql_stmt_init ( mysql ) ;\n<9> rc = mysql_stmt_prepare ( stmt , query , strlen ( query ) ) ;\n<10> check_execute ( stmt , rc ) ;
<1> void kadmin_getstrings ( int argc , char * argv [ ] ) {\n<3> char * pname , * canon = NULL ;\n<7> if ( argc != 2 ) {\n<8> fprintf ( stderr , _ ( "usage: get_strings principal\n" ) ) ;\n<13> if ( retval ) {\n<17> retval = krb5_unparse_name ( context , princ , & canon ) ;\n<24> com_err ( "get_strings" , retval , _ ( "while getting attributes for principal \"%s\"" ) , canon ) ;\n<27> if ( count == 0 ) printf ( _ ( "(No string attributes.)\n" ) ) ;\n<29> i < count ;\n<30> i ++ ) printf ( "%s: %s\n" , strings [ i ] . key , strings [ i ] . value ) ;\n<33> free ( canon ) ;
<1> static void png_filter_row(PNGDSPContext *dsp, uint8_t *dst, int filter_type,\n<3> uint8_t *src, uint8_t *last, int size, int bpp)\n<11> switch (filter_type) {\n<15> memcpy(dst, src, size);
<17> AVFrame *picture = data;\n<204> if(!s->lossless){\n<206> picture->quality= FFMAX3(s->qscale[0], s->qscale[1], s->qscale[2]);\n<210> picture->qscale_table= s->qscale_table;\n<212> memset(picture->qscale_table, picture->quality, (s->width+15)/16);\n<216> av_log(avctx, AV_LOG_DEBUG, "QP: %d\n", picture->quality);\n<218> picture->quality*= FF_QP2LAMBDA;
<1> static void avi_metadata_creation_time ( AVDictionary * * metadata , char * date ) {\n<2> char month [ 4 ] , time [ 9 ] , buffer [ 64 ] ;\n<4> if ( sscanf ( date , "%*3s%*[ ]%3s%*[ ]%2d%*[ ]%8s%*[ ]%4d" , month , & day , time , & year ) == 4 ) {\n<5> for ( i = 0 ;\n<6> i < 12 ;\n<7> i ++ ) if ( ! av_strcasecmp ( month , months [ i ] ) ) {\n<8> snprintf ( buffer , sizeof ( buffer ) , "%.4d-%.2d-%.2d %s" , year , i + 1 , day , time ) ;\n<12> else if ( date [ 4 ] == '/' && date [ 7 ] == '/' ) {\n<14> av_dict_set ( metadata , "creation_time" , date , 0 ) ;
<1> static int qemu_gluster_parse_json(BlockdevOptionsGluster *gconf,\n<107> if (!ptr) {\n<121> if (!strcmp(ptr, "tcp")) {\n<123> ptr = "inet";       /* accept legacy "tcp" */
<1> void usage_exit ( ) {\n<2> fprintf ( stderr , "Usage: %s <width> <height> <infile> <outfile(s)> <output psnr?>\n" , exec_name ) ;
<1> static int svq1_decode_frame(AVCodecContext *avctx, void *data,\n<111> if (!pmv)\n<161> if (s->pict_type == AV_PICTURE_TYPE_I) {\n<195> memset(pmv, 0, ((width / 8) + 3) * sizeof(svq1_pmv));\n<203> result = svq1_decode_delta_block(s, &s->gb, &current[x],\n<258> av_free(pmv);
<1> static void pc_init1(MemoryRegion *system_memory,\n<67> if (xen_enabled() && xen_hvm_init() != 0) {\n<69> fprintf(stderr, "xen hardware virtual machine initialisation failed\n");
<1> int paio_init(void)\n<37> if (pipe(fds) == -1) {\n<39> fprintf(stderr, "failed to create pipe\n");
<1> static void test_do_set ( ) {\n<17> i < 3 ;\n<18> i ++ ) {\n<21> if ( ! opt_silent ) fprintf ( stdout , "do %i\n" , i ) ;\n<24> if ( ! opt_silent ) fprintf ( stdout , "set %i\n" , i ) ;
<1> void gcry_sexp_dump ( const gcry_sexp_t a ) {\n<11> p ++ ;\n<12> switch ( type ) {\n<21> memcpy ( & n , p , sizeof n ) ;\n<22> p += sizeof n ;\n<24> dump_string ( p , n , '\"' ) ;\n<26> p += n ;
<1> uint32_t do_arm_semihosting(CPUState *env)\n<27> nr = env->regs[0];\n<31> switch (nr) {\n<35> if (!(s = lock_user_string(ARG(0))))\n<41> if (ARG(1) >= 12)\n<45> if (strcmp(s, ":tt") == 0) {\n<47> if (ARG(1) < 4)\n<57> if (use_gdb_syscalls()) {\n<67> ret = set_swi_errno(ts, open(s, open_modeflags[ARG(1)], 0644));\n<121> if (!(s = lock_user_string(args)))\n<127> len = strlen(s);\n<131> gdb_do_syscall(arm_semi_cb, "write,2,%x,%x\n", args, len);\n<137> ret = write(STDERR_FILENO, s, len);\n<141> unlock_user(s, args, 0);\n<609> gdb_exit(env, 0);\n<615> fprintf(stderr, "qemu: Unsupported SemiHosting SWI 0x%02x\n", nr);\n<617> cpu_dump_state(env, stderr, fprintf, 0);
<1> static int noise(AVBitStreamFilterContext *bsfc, AVCodecContext *avctx, const char *args,\n<5> const uint8_t *buf, int buf_size, int keyframe){\n<15> if(amount <= 0)\n<21> *poutbuf= av_malloc(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n<27> memcpy(*poutbuf, buf, buf_size + FF_INPUT_BUFFER_PADDING_SIZE);
<1> static int ssn_handler ( TSCont contp , TSEvent event , void * edata ) {\n<5> if ( data == nullptr ) {\n<51> txnp = ( TSHttpTxn ) edata ;\n<52> if ( true ) {\n<53> char * temp = TSstrdup ( ERROR_BODY ) ;\n<54> TSHttpTxnErrorBodySet ( txnp , temp , strlen ( temp ) , nullptr ) ;\n<56> TSHttpTxnReenable ( txnp , TS_EVENT_HTTP_CONTINUE ) ;\n<58> case TS_EVENT_IMMEDIATE : case TS_EVENT_TIMEOUT : if ( data -> browser -> status == REQUEST_INPROGRESS ) {\n<62> char * temp = data -> browser -> response ;\n<63> temp = strstr ( temp , "\r\n\r\n" ) ;\n<64> if ( temp != nullptr ) {\n<65> temp += strlen ( "\r\n\r\n" ) ;\n<66> if ( ( temp [ 0 ] == '\0' ) || ( strncmp ( temp , "\r\n\r\n" , 4 ) == 0 ) ) {\n<70> if ( strncmp ( temp , ERROR_BODY , strlen ( ERROR_BODY ) ) == 0 ) {\n<71> SDK_RPRINT ( data -> test , "TSHttpTxnErrorBodySet" , "TestCase1" , TC_PASS , "ok" ) ;\n<72> data -> test_passed_txn_error_body_set ++ ;
<1> static int decode_iccp_chunk(PNGDecContext *s, int length, AVFrame *f)\n<45> if ((ret = decode_zbuf(&bp, s->gb.buffer, s->gb.buffer + length)) < 0)\n<57> sd = av_frame_new_side_data(f, AV_FRAME_DATA_ICC_PROFILE, bp.len);\n<59> if (!sd) {\n<61> av_free(data);\n<70> memcpy(sd->data, data, bp.len);\n<72> av_free(data);
<1> static int guest_get_network_stats(const char *name,\n<11> memset(&a_mid_ifrow, 0, sizeof(a_mid_ifrow));\n<17> if (NO_ERROR == GetIfEntry(&a_mid_ifrow)) {\n<19> stats->rx_bytes = a_mid_ifrow.dwInOctets;\n<21> stats->rx_packets = a_mid_ifrow.dwInUcastPkts;\n<23> stats->rx_errs = a_mid_ifrow.dwInErrors;\n<25> stats->rx_dropped = a_mid_ifrow.dwInDiscards;\n<27> stats->tx_bytes = a_mid_ifrow.dwOutOctets;\n<29> stats->tx_packets = a_mid_ifrow.dwOutUcastPkts;\n<31> stats->tx_errs = a_mid_ifrow.dwOutErrors;\n<33> stats->tx_dropped = a_mid_ifrow.dwOutDiscards;
<1> static int dissect_spoolss_printer_enum_values ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) {\n<9> dissect_spoolss_uint16uni ( tvb , start_offset + name_offset , pinfo , NULL , drep , & name , hf_enumprinterdataex_name ) ;\n<10> subtree = proto_tree_add_subtree_format ( tree , tvb , offset , 0 , ett_printer_enumdataex_value , & item , "Name: %s" , name ) ;\n<13> proto_tree_add_string ( subtree , hf_enumprinterdataex_name , tvb , start_offset + name_offset , ( ( int ) strlen ( name ) + 1 ) * 2 , name ) ;
<1> static void at1_subband_synthesis ( AT1Ctx * q , AT1SUCtx * su , float * pOut ) {\n<5> memcpy ( su -> last_qmf_delay , & su -> last_qmf_delay [ 256 ] , sizeof ( float ) * 23 ) ;\n<6> memcpy ( & su -> last_qmf_delay [ 23 ] , q -> bands [ 2 ] , sizeof ( float ) * 256 ) ;\n<7> ff_atrac_iqmf ( temp , su -> last_qmf_delay , 256 , pOut , su -> snd_qmf_delay , iqmf_temp ) ;
<1> static cmsBool Type_NamedColor_Write ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , void * Ptr , cmsUInt32Number nItems ) {\n<3> char prefix [ 33 ] ;\n<4> char suffix [ 33 ] ;\n<6> nColors = cmsNamedColorCount ( NamedColorList ) ;\n<9> if ( ! _cmsWriteUInt32Number ( io , NamedColorList -> ColorantCount ) ) return FALSE ;\n<10> strncpy ( prefix , ( const char * ) NamedColorList -> Prefix , 32 ) ;\n<11> strncpy ( suffix , ( const char * ) NamedColorList -> Suffix , 32 ) ;\n<13> if ( ! io -> Write ( io , 32 , prefix ) ) return FALSE ;\n<14> if ( ! io -> Write ( io , 32 , suffix ) ) return FALSE ;
<1> static int mpi_fromstr ( gcry_mpi_t val , const char * str ) {\n<9> str ++ ;\n<11> if ( * str == '0' && str [ 1 ] == 'x' ) str += 2 ;\n<12> nbits = 4 * strlen ( str ) ;\n<13> if ( ( nbits % 8 ) ) prepend_zero = 1 ;\n<32> else c1 = * str ++ ;\n<37> c2 = * str ++ ;
<1> static void start_children(FFServerStream *feed)\n<15> if (no_launch)\n<21> cmd_length = strlen(my_program_name);\n<33> if (cmd_length > PATH_LENGTH - 1) {\n<35> http_log("Could not start children. Command line: '%s' exceeds "\n<45> pathname = av_strdup (my_program_name);\n<91> if (feed->pid < 0) {\n<93> http_log("Unable to create children: %s\n", strerror(errno));
<1> static void simple_number(void)\n<39> qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));\n<45> if (test_cases[i].skip == 0) {\n<53> g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);
<1> static int search_request_new ( int type , const char * const name , int flags , evdns_callback_type user_callback , void * user_arg ) {\n<6> req = request_new ( type , name , flags , user_callback , user_arg ) ;\n<7> if ( ! req ) return 1 ;\n<11> char * const new_name = search_make_new ( global_search_state , 0 , name ) ;\n<12> if ( ! new_name ) return 1 ;\n<13> req = request_new ( type , new_name , flags , user_callback , user_arg ) ;\n<14> free ( new_name ) ;\n<15> if ( ! req ) return 1 ;\n<18> req -> search_origname = strdup ( name ) ;\n<22> request_submit ( req ) ;
<1> static void fix_dependencies ( ArchiveHandle * AH ) {\n<16> te != AH -> toc ;\n<17> te = te -> next ) {\n<18> if ( strcmp ( te -> desc , "BLOB COMMENTS" ) == 0 && te -> nDeps == 0 ) {\n<20> for ( te2 = AH -> toc -> next ;\n<21> te2 != AH -> toc ;\n<22> te2 = te2 -> next ) {\n<23> if ( strcmp ( te2 -> desc , "BLOBS" ) == 0 ) {\n<24> te -> dependencies = ( DumpId * ) pg_malloc ( sizeof ( DumpId ) ) ;\n<25> te -> dependencies [ 0 ] = te2 -> dumpId ;\n<26> te -> nDeps ++ ;\n<27> te -> depCount ++ ;\n<36> te != AH -> toc ;\n<47> te != AH -> toc ;\n<53> te != AH -> toc ;\n<66> te != AH -> toc ;\n<70> identify_locking_dependencies ( AH , te ) ;
<6> if ( stack [ i ] . type == ps_string || stack [ i ] . type == ps_instr || stack [ i ] . type == ps_lit ) free ( stack [ i ] . u . str ) ;
<1> static int file_read ( void * buf , size_t size , FILE * file ) {\n<3> int retry_count = 0 ;\n<7> const size_t n = fread ( ( uint8_t * ) buf + len , 1 , size - len , file ) ;\n<8> len += n ;\n<9> file_error = ferror ( file ) ;\n<11> if ( errno == EINTR || errno == EAGAIN ) {\n<16> fprintf ( stderr , "Error reading file: %u of %u bytes read, %d: %s\n" , ( uint32_t ) len , ( uint32_t ) size , errno , strerror ( errno ) ) ;\n<21> while ( ! feof ( file ) && len < size && ++ retry_count < kMaxRetries ) ;\n<22> if ( ! feof ( file ) && len != size ) {\n<23> fprintf ( stderr , "Error reading file: %u of %u bytes read," " error: %d, retries: %d, %d: %s\n" , ( uint32_t ) len , ( uint32_t ) size , file_error , retry_count , errno , strerror ( errno ) ) ;
<1> static char * StripTags ( char * psz_subtitle ) {\n<4> psz_text = psz_text_start = malloc ( strlen ( psz_subtitle ) + 1 ) ;\n<5> if ( ! psz_text_start ) return NULL ;\n<47> char * psz = realloc ( psz_text_start , strlen ( psz_text_start ) + 1 ) ;
<1> static int compute_bit_allocation(AC3EncodeContext *s,\n<3> uint8_t bap[NB_BLOCKS][AC3_MAX_CHANNELS][N/2],\n<139> bit_alloc(s, bap, encoded_exp, exp_strategy, frame_bits, csnroffst, 0) < 0)\n<153> bit_alloc(s, bap1, encoded_exp, exp_strategy, frame_bits,\n<159> memcpy(bap, bap1, sizeof(bap1));\n<165> bit_alloc(s, bap1, encoded_exp, exp_strategy, frame_bits, csnroffst + 1, 0) >= 0) {\n<169> memcpy(bap, bap1, sizeof(bap1));\n<179> bit_alloc(s, bap1, encoded_exp, exp_strategy, frame_bits,\n<185> memcpy(bap, bap1, sizeof(bap1));\n<191> bit_alloc(s, bap1, encoded_exp, exp_strategy, frame_bits,\n<197> memcpy(bap, bap1, sizeof(bap1));
<1> static int cmv_decode_frame(AVCodecContext *avctx,\n<7> CmvContext *s = avctx->priv_data;\n<22> if (avctx->get_buffer(avctx, &s->frame)<0) {\n<26> memcpy(s->frame.data[1], s->palette, AVPALETTE_SIZE);\n<29> cmv_decode_inter(s, buf+2, buf_end);\n<35> cmv_decode_intra(s, buf+2, buf_end);
<1> static int cow_create(const char *filename, QemuOpts *opts, Error **errp)\n<47> if (ret < 0) {\n<57> memset(&cow_header, 0, sizeof(cow_header));\n<91> ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));
<1> static void test_simpleread ( void ) {\n<4> write ( pair [ 0 ] , TEST1 , strlen ( TEST1 ) + 1 ) ;\n<5> shutdown ( pair [ 0 ] , SHUT_WR ) ;
<1> static void build_pci_bus_end(PCIBus *bus, void *bus_state)\n<15> DECLARE_BITMAP(slot_device_system, PCI_SLOT_MAX);\n<67> if (bsel) {\n<75> memset(slot_hotplug_enable, 0xff, sizeof slot_hotplug_enable);\n<81> memset(slot_hotplug_enable, 0x00, sizeof slot_hotplug_enable);\n<87> memset(slot_device_present, 0x00, sizeof slot_device_present);\n<89> memset(slot_device_system, 0x00, sizeof slot_device_present);\n<91> memset(slot_device_vga, 0x00, sizeof slot_device_vga);\n<93> memset(slot_device_qxl, 0x00, sizeof slot_device_qxl);\n<127> set_bit(slot, slot_device_system);\n<135> set_bit(slot, slot_device_vga);\n<141> set_bit(slot, slot_device_qxl);\n<151> clear_bit(slot, slot_hotplug_enable);\n<163> bool can_eject = test_bit(i, slot_hotplug_enable);\n<167> bool vga = test_bit(i, slot_device_vga);\n<169> bool qxl = test_bit(i, slot_device_qxl);\n<171> bool system = test_bit(i, slot_device_system);\n<173> if (can_eject) {\n<179> memcpy(pcihp, ACPI_PCIHP_AML, ACPI_PCIHP_SIZEOF);\n<181> patch_pcihp(i, pcihp);\n<185> } else if (qxl) {\n<191> memcpy(pcihp, ACPI_PCIQXL_AML, ACPI_PCIQXL_SIZEOF);\n<193> patch_pciqxl(i, pcihp);\n<195> } else if (vga) {\n<201> memcpy(pcihp, ACPI_PCIVGA_AML, ACPI_PCIVGA_SIZEOF);\n<203> patch_pcivga(i, pcihp);\n<209> } else if (present) {\n<215> memcpy(pcihp, ACPI_PCINOHP_AML, ACPI_PCINOHP_SIZEOF);\n<217> patch_pcinohp(i, pcihp);\n<239> if (!test_bit(i, slot_hotplug_enable)) {
<1> static void test_bug8722 ( ) {\n<6> stmt_text = "drop table if exists t1, v1" ;\n<7> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<9> stmt_text = "CREATE TABLE t1 (c1 varchar(10), c2 varchar(10), c3 varchar(10)," " c4 varchar(10), c5 varchar(10), c6 varchar(10)," " c7 varchar(10), c8 varchar(10), c9 varchar(10)," "c10 varchar(10))" ;\n<10> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<12> stmt_text = "INSERT INTO t1 VALUES (1,2,3,4,5,6,7,8,9,10)" ;\n<13> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<15> stmt_text = "CREATE VIEW v1 AS SELECT * FROM t1" ;\n<16> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;\n<18> stmt = mysql_stmt_init ( mysql ) ;\n<19> stmt_text = "select * from v1" ;\n<20> rc = mysql_stmt_prepare ( stmt , stmt_text , strlen ( stmt_text ) ) ;\n<21> check_execute ( stmt , rc ) ;\n<23> stmt_text = "drop table if exists t1, v1" ;\n<24> rc = mysql_real_query ( mysql , stmt_text , strlen ( stmt_text ) ) ;
<1> static int pubkey_get_nskey ( int algorithm ) {\n<7> if ( pubkey ) {\n<8> nskey = strlen ( ( ( gcry_pk_spec_t * ) pubkey -> spec ) -> elements_skey ) ;\n<12> return nskey ;
<1> static int dissect_spoolss_buffer ( tvbuff_t * tvb , gint offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep , BUFFER * b ) {\n<2> if ( b ) memset ( b , 0 , sizeof ( BUFFER ) ) ;\n<3> di -> private_data = b ;
<1> GList * completion_get_aliases ( const char * word ) {\n<6> g_return_val_if_fail ( word != NULL , NULL ) ;\n<7> len = strlen ( word ) ;\n<16> if ( len != 0 && g_ascii_strncasecmp ( node -> key , word , len ) != 0 ) continue ;
<1> void gincostestimate ( PlannerInfo * root , IndexPath * path , double loop_count , Cost * indexStartupCost , Cost * indexTotalCost , Selectivity * indexSelectivity , double * indexCorrelation ) {\n<18> if ( ! index -> hypothetical ) {\n<24> memset ( & ginStats , 0 , sizeof ( ginStats ) ) ;\n<56> memset ( & counts , 0 , sizeof ( counts ) ) ;\n<63> matchPossible = gincost_opexpr ( root , index , qinfo , & counts ) ;\n<67> matchPossible = gincost_scalararrayopexpr ( root , index , qinfo , numEntries , & counts ) ;\n<80> if ( counts . haveFullScan || indexQuals == NIL ) {\n<87> entryPagesFetched += ceil ( counts . searchEntries * rint ( pow ( numEntryPages , 0.15 ) ) ) ;\n<88> partialScale = counts . partialEntries / numEntries ;\n<92> if ( outer_scans > 1 || counts . arrayScans > 1 ) {\n<93> entryPagesFetched *= outer_scans * counts . arrayScans ;\n<96> dataPagesFetched *= outer_scans * counts . arrayScans ;\n<101> dataPagesFetched = ceil ( numDataPages * counts . exactEntries / numEntries ) ;\n<104> if ( outer_scans > 1 || counts . arrayScans > 1 ) {\n<105> dataPagesFetched *= outer_scans * counts . arrayScans ;
<1> int kvm_init(void)\n<41> if (s->fd == -1) {\n<43> fprintf(stderr, "Could not access KVM kernel module: %m\n");\n<55> if (ret < KVM_API_VERSION) {\n<63> fprintf(stderr, "kvm version too old\n");\n<71> if (ret > KVM_API_VERSION) {\n<75> fprintf(stderr, "kvm version not supported\n");\n<105> if (!missing_cap) {\n<113> if (missing_cap) {
<1> int load_uboot(const char *filename, target_ulong *ep, int *is_linux)\n<47> if (hdr->ih_type == IH_TYPE_MULTI) {\n<49> fprintf(stderr, "Unable to load multi-file u-boot images\n");\n<59> if (hdr->ih_comp != IH_COMP_NONE) {\n<61> fprintf(stderr, "Unable to load compressed u-boot images\n");\n<95> if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n<97> fprintf(stderr, "Error reading file\n");
<1> static void qio_channel_websock_handshake_send_res ( QIOChannelWebsock * ioc , const char * resmsg , ... ) {\n<6> response = g_strdup_vprintf ( resmsg , vargs ) ;\n<7> responselen = strlen ( response ) ;\n<8> buffer_reserve ( & ioc -> encoutput , responselen ) ;\n<9> buffer_append ( & ioc -> encoutput , response , responselen ) ;
<1> static int adx_encode_header(AVCodecContext *avctx,unsigned char *buf,size_t bufsize)\n<65> memcpy(buf+0x1c,"\0\0(c)CRI",8);
<1> static char * adb_send_and_receive ( socket_handle_t sock , const char * adb_service , char * buffer , int buffer_length , gssize * data_length ) {\n<5> char status [ 4 ] ;\n<8> adb_service_length = strlen ( adb_service ) ;\n<9> result = send ( sock , adb_service , ( int ) adb_service_length , 0 ) ;\n<10> if ( result != ( gssize ) adb_service_length ) {\n<16> while ( used_buffer_length < 8 ) {\n<17> result = recv ( sock , buffer + used_buffer_length , ( int ) ( buffer_length - used_buffer_length ) , 0 ) ;\n<18> if ( result <= 0 ) {\n<24> memcpy ( status , buffer , 4 ) ;\n<25> tmp_buffer = buffer [ 8 ] ;\n<26> buffer [ 8 ] = '\0' ;\n<27> length = ( gssize ) g_ascii_strtoll ( buffer + 4 , NULL , 16 ) ;\n<28> buffer [ 8 ] = tmp_buffer ;\n<29> while ( used_buffer_length < length + 8 ) {\n<30> result = recv ( sock , buffer + used_buffer_length , ( int ) ( buffer_length - used_buffer_length ) , 0 ) ;\n<31> if ( result <= 0 ) {\n<38> if ( memcmp ( status , "OKAY" , 4 ) ) {\n<39> errmsg_print ( "ERROR: Error while receiving by ADB for <%s>" , adb_service ) ;\n<40> if ( data_length ) * data_length = 0 ;\n<41> return NULL ;\n<43> return buffer + 8 ;
<1> static uint dump_events_for_db ( char * db ) {\n<12> DBUG_PRINT ( "enter" , ( "db: '%s'" , db ) ) ;\n<13> mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;
<1> void hmp_change(Monitor *mon, const QDict *qdict)\n<5> const char *device = qdict_get_str(qdict, "device");\n<7> const char *target = qdict_get_str(qdict, "target");\n<19> if (strcmp(device, "vnc") == 0) {\n<21> if (read_only) {\n<31> if (strcmp(target, "passwd") == 0 ||\n<33> strcmp(target, "password") == 0) {\n<35> if (!arg) {\n<45> qmp_change("vnc", target, !!arg, arg, &err);\n<49> if (read_only) {\n<71> qmp_blockdev_change_medium(true, device, false, NULL, target,\n<93> hmp_handle_error(mon, &err);
<1> static void remoteDispatchStringError ( remote_error * rerr , int code , const char * msg ) {\n<3> memset ( & verr , 0 , sizeof verr ) ;\n<9> remoteDispatchCopyError ( rerr , & verr ) ;
<1> static void rm_read_audio_stream_info(AVFormatContext *s, AVStream *st,\n<11> char buf[256];\n<23> if (((version >> 16) & 0xff) == 3) {\n<111> buf[0] = get_byte(pb);\n<113> buf[1] = get_byte(pb);\n<115> buf[2] = get_byte(pb);\n<117> buf[3] = get_byte(pb);\n<119> buf[4] = 0;\n<125> get_str8(pb, buf, sizeof(buf)); /* desc */\n<131> if (!strcmp(buf, "dnet")) {\n<133> st->codec->codec_id = CODEC_ID_AC3;\n<135> } else if (!strcmp(buf, "28_8")) {\n<137> st->codec->codec_id = CODEC_ID_RA_288;\n<139> st->codec->extradata_size= 0;\n<141> rm->audio_framesize = st->codec->block_align;\n<143> st->codec->block_align = coded_framesize;\n<147> if(rm->audio_framesize >= UINT_MAX / sub_packet_h){\n<159> } else if (!strcmp(buf, "cook")) {\n<163> get_be16(pb); get_byte(pb);\n<165> if (((version >> 16) & 0xff) == 5)\n<169> codecdata_length = get_be32(pb);\n<171> if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n<209> } else if (!strcmp(buf, "raac") || !strcmp(buf, "racp")) {\n<213> get_be16(pb); get_byte(pb);\n<215> if (((version >> 16) & 0xff) == 5)\n<219> st->codec->codec_id = CODEC_ID_AAC;\n<221> codecdata_length = get_be32(pb);\n<223> if (codecdata_length >= 1) {\n<239> st->codec->codec_id = CODEC_ID_NONE;\n<241> pstrcpy(st->codec->codec_name, sizeof(st->codec->codec_name),\n<247> if (read_all) {
<1> static void start_children(FFStream *feed)\n<9> if (feed->pid < 0) {\n<10> fprintf(stderr, "Unable to create children\n");
<1> static SplinePointList * SplinesFromLayers ( SplineChar * sc , int * flags , int tostroke ) {\n<6> real inversetrans [ 6 ] , transform [ 6 ] ;\n<32> if ( sc -> layers [ layer ] . dostroke ) {\n<33> memset ( & si , '\0' , sizeof ( si ) ) ;\n<36> si . radius = sc -> layers [ layer ] . stroke_pen . width / 2.0f ;\n<37> if ( sc -> layers [ layer ] . stroke_pen . width == WIDTH_INHERITED ) si . radius = .5 ;\n<38> if ( si . cap == lc_inherited ) si . cap = lc_butt ;\n<39> if ( si . join == lj_inherited ) si . join = lj_miter ;\n<41> memcpy ( transform , sc -> layers [ layer ] . stroke_pen . trans , 4 * sizeof ( real ) ) ;\n<42> transform [ 4 ] = transform [ 5 ] = 0 ;\n<43> MatInverse ( inversetrans , transform ) ;\n<48> temp = SplineSetStroke ( each , & si , sc -> layers [ layer ] . order2 ) ;\n<55> new = SplinePointListTransform ( new , transform , tpt_AllPoints ) ;
<1> static int parse_strk(AVFormatContext *s,\n<3> FourxmDemuxContext *fourxm, uint8_t *buf, int size)\n<23> if (av_reallocp_array(&fourxm->tracks, track + 1, sizeof(AudioTrack)))\n<27> memset(&fourxm->tracks[fourxm->track_count], 0,\n<29> sizeof(AudioTrack) * (track + 1 - fourxm->track_count));
<1> static int av_encode(AVFormatContext **output_files,\n<91> ist->file_index = i;\n<93> ist->index = k;\n<127> if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n<129> fprintf(stderr, "Number of stream maps must match number of output streams\n");\n<143> int si = stream_maps[i].stream_index;\n<147> if (fi < 0 || fi > nb_input_files - 1 ||\n<149> si < 0 || si > file_table[fi].nb_streams - 1) {\n<151> fprintf(stderr,"Could not find input stream #%d.%d\n", fi, si);\n<191> ost = ost_table[n++];\n<193> ost->file_index = k;\n<195> ost->index = i;\n<209> if (ist_table[ost->source_index]->st->codec.codec_type != ost->st->codec.codec_type) {\n<211> fprintf(stderr, "Codec type mismatch for mapping #%d.%d -> #%d.%d\n",\n<265> if (!found) {\n<267> fprintf(stderr, "Could not find input stream matching output stream #%d.%d\n",\n<291> for(i=0;i<nb_ostreams;i++) {\n<391> if(!ost->resample)\n<395> printf("Can't resample.  Aborting.\n");\n<417> if(!ost->resample)\n<421> printf("Can't resample.  Aborting.\n");\n<585> if (!logbuffer) {\n<587> fprintf(stderr, "Could not allocate log buffer\n");\n<625> fprintf(stderr, "Stream mapping:\n");\n<627> for(i=0;i<nb_ostreams;i++) {\n<629> ost = ost_table[i];\n<649> ost = ost_table[i];\n<657> if (!codec) {\n<659> fprintf(stderr, "Unsupported codec for output stream #%d.%d\n",\n<667> if (avcodec_open(&ost->st->codec, codec) < 0) {\n<669> fprintf(stderr, "Error while opening codec for stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\n",\n<687> ist = ist_table[i];\n<693> codec = avcodec_find_decoder(ist->st->codec.codec_id);\n<695> if (!codec) {\n<697> fprintf(stderr, "Unsupported codec (id=%d) for input stream #%d.%d\n",\n<705> if (avcodec_open(&ist->st->codec, codec) < 0) {\n<707> fprintf(stderr, "Error while opening codec for input stream #%d.%d\n",\n<781> for(i=0;i<nb_output_files;i++) {\n<785> if (av_write_header(os) < 0) {\n<787> fprintf(stderr, "Could not write header for output file #%d (incorrect codec paramters ?)\n", i);\n<801> if ( !using_stdin )\n<803> fprintf(stderr, "Press [q] to stop encoding\n");\n<875> ist = ist_table[ost->source_index];\n<885> file_index = ist->file_index;\n<913> if (av_read_packet(is, &pkt) < 0) {\n<921> if (!pkt.size) {\n<931> if (do_hex_dump) {\n<933> printf("stream #%d, size=%d:\n", pkt.stream_index, pkt.size);\n<935> av_hex_dump(pkt.data, pkt.size);\n<943> if (pkt.stream_index >= file_table[file_index].nb_streams)\n<949> ist = ist_table[ist_index];\n<987> if( pkt.pts != AV_NOPTS_VALUE )\n<1009> switch(ist->st->codec.codec_type) {\n<1017> ret = avcodec_decode_audio(&ist->st->codec, samples, &data_size,\n<1021> if (ret < 0)\n<1067> if (ret < 0) {\n<1071> fprintf(stderr, "Error while decoding stream #%d.%d\n",\n<1075> av_free_packet(&pkt);\n<1127> pre_process_video_frame(ist, &picture, &buffer_to_free);\n<1225> if (ost->encoding_needed) {\n<1231> do_audio_out(os, ost, ist, data_buf, data_size);\n<1251> if (ost1->file_index == ost->file_index &&\n<1265> do_video_out(os, ost, ist, &picture, &frame_size, audio_sync);\n<1269> do_video_stats(os, ost, frame_size);\n<1293> memset(&avframe, 0, sizeof(AVFrame));\n<1295> ost->st->codec.coded_frame= &avframe;\n<1297> avframe.key_frame = pkt.flags & PKT_FLAG_KEY;\n<1301> av_write_frame(os, ost->index, data_buf, data_size);\n<1319> av_free_packet(&pkt);\n<1365> avcodec_close(&ist->st->codec);\n<1403> av_free(ist);\n<1407> av_free(ist_table);\n<1441> av_free(ost);
<1> static int lxc_cgroupfs_get ( const char * filename , char * value , size_t len , const char * name , const char * lxcpath ) {\n<4> subsystem = alloca ( strlen ( filename ) + 1 ) ;\n<5> strcpy ( subsystem , filename ) ;\n<6> if ( ( p = strchr ( subsystem , '.' ) ) != NULL ) * p = '\0' ;\n<7> path = lxc_cgroup_get_hierarchy_abs_path ( subsystem , name , lxcpath ) ;\n<8> if ( path ) {\n<9> ret = do_cgroup_get ( path , filename , value , len ) ;\n<10> free ( path ) ;
<1> void kadmin_getpols ( int argc , char * argv [ ] ) {\n<6> if ( ! ( argc == 1 || ( argc == 2 && ( expr = argv [ 1 ] ) ) ) ) {\n<7> fprintf ( stderr , _ ( "usage: get_policies [expression]\n" ) ) ;\n<16> i < count ;\n<17> i ++ ) printf ( "%s\n" , names [ i ] ) ;\n<18> kadm5_free_name_list ( handle , names , count ) ;
<1> int av_vsrc_buffer_add_frame2(AVFilterContext *buffer_filter, AVFrame *frame,\n<33> if(width != c->w || height != c->h || pix_fmt != c->pix_fmt){\n<47> if(!scale || strcmp(scale->filter->name,"scale")){\n<49> AVFilter *f= avfilter_get_by_name("scale");\n<53> av_log(buffer_filter, AV_LOG_INFO, "Inserting scaler filter\n");\n<55> if(avfilter_open(&scale, f, "Input equalizer") < 0)\n<87> c->pix_fmt= scale->inputs[0]->format= pix_fmt;\n<89> c->w= scale->inputs[0]->w= width;\n<91> c->h= scale->inputs[0]->h= height;\n<95> link= scale->outputs[0];\n<97> if ((ret =  link->srcpad->config_props(link)) < 0)\n<105> memcpy(c->frame.data    , frame->data    , sizeof(frame->data));\n<107> memcpy(c->frame.linesize, frame->linesize, sizeof(frame->linesize));
<83> for(i=0;i<MAX_COMPONENTS;i++) {\n<85> free(s->current_picture[i]);\n<87> s->current_picture[i] = NULL;
<1> static void version ( struct parse * pcmd , FILE * fp ) {\n<2> ( void ) fprintf ( fp , "%s\n" , Version ) ;
<1> static void mm_decode_intra(MmContext * s, int half_horiz, int half_vert, const uint8_t *buf, int buf_size)\n<4> i=0; x=0; y=0;\n<8> run_length = 1;\n<9> color = buf[i];\n<12> run_length = (buf[i] & 0x7f) + 2;\n<13> color = buf[i+1];\n<17> run_length *=2;\n<18> if (color) {\n<19> memset(s->frame.data[0] + y*s->frame.linesize[0] + x, color, run_length);\n<20> if (half_vert)\n<21> memset(s->frame.data[0] + (y+1)*s->frame.linesize[0] + x, color, run_length);\n<23> x+= run_length;\n<24> if (x >= s->avctx->width) {\n<25> x=0;
<1> static int AddEntry ( struct pskeydict * dict , struct psstack * stack , int sp ) {\n<4> if ( dict -> cnt == 0 ) {\n<6> dict -> entries = malloc ( dict -> max * sizeof ( struct pskeyval ) ) ;\n<10> dict -> entries = realloc ( dict -> entries , dict -> max * sizeof ( struct pskeyval ) ) ;\n<19> i < dict -> cnt ;\n<20> ++ i ) if ( strcmp ( dict -> entries [ i ] . key , stack [ sp - 2 ] . u . str ) == 0 ) break ;\n<21> if ( i != dict -> cnt ) {\n<22> free ( stack [ sp - 2 ] . u . str ) ;\n<23> if ( dict -> entries [ i ] . type == ps_string || dict -> entries [ i ] . type == ps_instr || dict -> entries [ i ] . type == ps_lit ) free ( dict -> entries [ i ] . u . str ) ;\n<26> memset ( & dict -> entries [ i ] , '\0' , sizeof ( struct pskeyval ) ) ;
<1> static void dsp_x8_put_solidcolor ( uint8_t const pix , uint8_t * dst , int const linesize ) {\n<4> k < 8 ;\n<6> memset ( dst , pix , 8 ) ;\n<7> dst += linesize ;
<1> int qemuMonitorTextSetLink ( qemuMonitorPtr mon , const char * name , enum virDomainNetInterfaceLinkState state ) {\n<2> char * info = NULL ;\n<11> if ( qemuMonitorHMPCommand ( mon , cmd , & info ) < 0 ) {\n<15> if ( strstr ( info , "\nunknown " ) ) {\n<16> qemuReportError ( VIR_ERR_NO_SUPPORT , "%s" , _ ( "\'set_link\' not supported by this qemu" ) ) ;\n<19> if ( strstr ( info , "\nDevice " ) ) {\n<20> qemuReportError ( VIR_ERR_OPERATION_FAILED , "%s" , _ ( "device name rejected" ) ) ;\n<23> VIR_FREE ( info ) ;\n<24> VIR_FREE ( cmd ) ;\n<25> return 0 ;\n<26> error : VIR_FREE ( info ) ;\n<27> VIR_FREE ( cmd ) ;\n<28> return - 1 ;
<1> static int qemuMonitorParseBalloonInfo ( char * text , virDomainMemoryStatPtr stats , unsigned int nr_stats ) {\n<2> char * p = text ;\n<4> if ( parseMemoryStat ( & p , VIR_DOMAIN_MEMORY_STAT_ACTUAL_BALLOON , "actual=" , & stats [ nr_stats_found ] ) == 1 ) {\n<7> while ( * p && nr_stats_found < nr_stats ) {\n<8> if ( parseMemoryStat ( & p , VIR_DOMAIN_MEMORY_STAT_SWAP_IN , ",mem_swapped_in=" , & stats [ nr_stats_found ] ) || parseMemoryStat ( & p , VIR_DOMAIN_MEMORY_STAT_SWAP_OUT , ",mem_swapped_out=" , & stats [ nr_stats_found ] ) || parseMemoryStat ( & p , VIR_DOMAIN_MEMORY_STAT_MAJOR_FAULT , ",major_page_faults=" , & stats [ nr_stats_found ] ) || parseMemoryStat ( & p , VIR_DOMAIN_MEMORY_STAT_MINOR_FAULT , ",minor_page_faults=" , & stats [ nr_stats_found ] ) || parseMemoryStat ( & p , VIR_DOMAIN_MEMORY_STAT_UNUSED , ",free_mem=" , & stats [ nr_stats_found ] ) || parseMemoryStat ( & p , VIR_DOMAIN_MEMORY_STAT_AVAILABLE , ",total_mem=" , & stats [ nr_stats_found ] ) ) nr_stats_found ++ ;\n<9> if ( * p == ',' ) p ++ ;\n<10> p = strchr ( p , ',' ) ;\n<11> if ( ! p ) break ;
<1> static void mainstone_common_init(ram_addr_t ram_size, int vga_ram_size,\n<31> if (ram_size < MAINSTONE_RAM + MAINSTONE_ROM + 2 * MAINSTONE_FLASH +\n<35> fprintf(stderr, "This platform requires %i bytes of memory\n",\n<37> MAINSTONE_RAM + MAINSTONE_ROM + 2 * MAINSTONE_FLASH +\n<67> if (index == -1) {\n<69> fprintf(stderr, "Two flash images must be given with the "\n<79> if (!pflash_cfi01_register(mainstone_flash_base[i],\n<87> fprintf(stderr, "qemu: Error registering flash memory.\n");\n<103> printf("map addr %p\n", &map);\n<105> pxa27x_register_keypad(cpu->kp, map, 0xe0);
<1> static int opt_input_file(const char *opt, const char *filename)\n<23> if (!(file_iformat = av_find_input_format(last_asked_format))) {\n<25> fprintf(stderr, "Unknown input format: '%s'\n", last_asked_format);\n<37> if (!strcmp(filename, "-"))\n<39> filename = "pipe:";\n<43> using_stdin |= !strncmp(filename, "pipe:", 5) ||\n<45> !strcmp(filename, "/dev/stdin");\n<55> print_error(filename, AVERROR(ENOMEM));\n<117> err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n<121> print_error(filename, err);\n<165> if(!found){\n<167> fprintf(stderr, "Specified program id not found\n");\n<203> if (ret < 0 && verbose >= 0) {\n<205> fprintf(stderr, "%s: could not find codec parameters\n", filename);\n<231> if (ret < 0) {\n<233> fprintf(stderr, "%s: could not seek to position %0.3f\n",\n<235> filename, (double)timestamp / AV_TIME_BASE);\n<249> for(i=0;i<ic->nb_streams;i++) {\n<277> if (i < nb_ts_scale)\n<323> if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {\n<327> if (verbose >= 0)\n<329> fprintf(stderr,"\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\n",\n<331> i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,\n<335> (float)rfps / rfps_base, rfps, rfps_base);\n<389> av_dump_format(ic, nb_input_files, filename, 0);
<1> static int mpeg_decode_mb(MpegEncContext *s, DCTELEM block[12][64])\n<159> s->qscale = get_qscale(s);\n<163> if (s->concealment_motion_vectors) {\n<187> memset(s->last_mv, 0, sizeof(s->last_mv)); /* reset mv prediction */\n<195> ff_xvmc_pack_pblocks(s, -1); // inter are always full blocks\n<199> exchange_uv(s);\n<213> mpeg2_fast_decode_block_intra(s, *s->pblocks[i], i);\n<221> if (mpeg2_decode_block_intra(s, *s->pblocks[i], i) < 0)\n<233> if (mpeg1_decode_block_intra(s, *s->pblocks[i], i) < 0)
<1> void xmlInitializeGlobalState ( xmlGlobalStatePtr gs ) {\n<45> memset ( & gs -> xmlLastError , 0 , sizeof ( xmlError ) ) ;
<1> static void flush_encoders(void)\n<11> OutputStream   *ost = output_streams[i];\n<39> avcodec_send_frame(enc, NULL);\n<83> ret = avcodec_receive_packet(enc, &pkt);\n<93> if (ost->logfile && enc->stats_out) {\n<95> fprintf(ost->logfile, "%s", enc->stats_out);\n<109> output_packet(os, &pkt, ost);
<1> static int read_restart_header(MLPDecodeContext *m, GetBitContext *gbp,\n<7> SubStream *s = &m->substream[substr];\n<113> if (s->min_channel > s->max_channel) {\n<181> memset(s->ch_assign, 0, sizeof(s->ch_assign));\n<185> for (ch = 0; ch <= s->max_matrix_channel; ch++) {\n<283> memset(s->output_shift   , 0, sizeof(s->output_shift   ));\n<285> memset(s->quant_step_size, 0, sizeof(s->quant_step_size));
<1> build_rsdt(GArray *table_data, BIOSLinker *linker, GArray *table_offsets,\n<13> const int table_data_len = (sizeof(uint32_t) * table_offsets->len);\n<19> rsdt = acpi_data_push(table_data, rsdt_len);\n<21> memcpy(rsdt->table_offset_entry, table_offsets->data, table_data_len);\n<41> (void *)rsdt, "RSDT", rsdt_len, 1, oem_id, oem_table_id);
<1> static int cuvid_test_dummy_decoder(AVCodecContext *avctx,\n<21> memset(&cuinfo, 0, sizeof(cuinfo));\n<67> ret = CHECK_CU(ctx->cvdl->cuvidCreateDecoder(&cudec, &cuinfo));
<1> int jbig2_immediate_generic_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const byte * segment_data ) {\n<4> int8_t gbat [ 8 ] ;\n<6> int gbat_bytes = 0 ;\n<14> jbig2_get_region_segment_info ( & rsi , segment_data ) ;\n<19> if ( ! ( seg_flags & 1 ) ) {\n<20> gbat_bytes = ( seg_flags & 6 ) ? 2 : 8 ;\n<21> if ( 18 + gbat_bytes > segment -> data_length ) return jbig2_error ( ctx , JBIG2_SEVERITY_FATAL , segment -> number , "Segment too short" ) ;\n<22> memcpy ( gbat , segment_data + 18 , gbat_bytes ) ;\n<23> jbig2_error ( ctx , JBIG2_SEVERITY_INFO , segment -> number , "gbat: %d, %d" , gbat [ 0 ] , gbat [ 1 ] ) ;\n<25> offset = 18 + gbat_bytes ;\n<30> memcpy ( params . gbat , gbat , gbat_bytes ) ;\n<35> code = jbig2_decode_generic_mmr ( ctx , segment , & params , segment_data + offset , segment -> data_length - offset , image ) ;\n<39> GB_stats = jbig2_new ( ctx , Jbig2ArithCx , stats_size ) ;\n<40> if ( GB_stats == NULL ) {\n<44> memset ( GB_stats , 0 , stats_size ) ;\n<55> code = jbig2_decode_generic_region ( ctx , segment , & params , as , image , GB_stats ) ;\n<61> jbig2_free ( ctx -> allocator , GB_stats ) ;
<1> static void gx_ttfReader__Read ( ttfReader * self , void * p , int n ) {\n<2> gx_ttfReader * r = ( gx_ttfReader * ) self ;\n<6> q = r -> glyph_data . bits . data + r -> pos ;\n<7> r -> error = ( r -> glyph_data . bits . size - r -> pos < n ? gs_note_error ( gs_error_invalidfont ) : 0 ) ;\n<8> if ( r -> error == 0 ) memcpy ( p , q , n ) ;\n<14> cnt += r -> error ) {\n<15> r -> error = r -> pfont -> data . string_proc ( r -> pfont , ( ulong ) r -> pos + cnt , ( ulong ) n - cnt , & q ) ;\n<17> else if ( r -> error == 0 ) {\n<18> memcpy ( ( char * ) p + cnt , q , n - cnt ) ;\n<22> memcpy ( ( char * ) p + cnt , q , r -> error ) ;\n<27> if ( r -> error ) {\n<28> memset ( p , 0 , n ) ;\n<31> r -> pos += n ;
<1> void qemu_spice_init(void)\n<43> if (!port && !tls_port) {\n<45> fprintf(stderr, "neither port nor tls-port specified for spice.");\n<51> if (port < 0 || port > 65535) {\n<53> fprintf(stderr, "spice port is out of range");\n<59> if (tls_port < 0 || tls_port > 65535) {\n<61> fprintf(stderr, "spice tls-port is out of range");\n<71> if (tls_port) {\n<75> if (NULL == x509_dir) {\n<77> x509_dir = ".";\n<81> len = strlen(x509_dir) + 32;\n<93> x509_key_file = g_malloc(len);\n<95> snprintf(x509_key_file, len, "%s/%s", x509_dir, X509_SERVER_KEY_FILE);\n<109> x509_cert_file = g_malloc(len);\n<111> snprintf(x509_cert_file, len, "%s/%s", x509_dir, X509_SERVER_CERT_FILE);\n<125> x509_cacert_file = g_malloc(len);\n<127> snprintf(x509_cacert_file, len, "%s/%s", x509_dir, X509_CA_CERT_FILE);\n<193> if (qemu_opt_get_bool(opts, "sasl", 0)) {\n<209> fprintf(stderr, "spice: sasl is not available (spice >= 0.9 required)\n");\n<307> if (0 != spice_server_init(spice_server, &core_interface)) {\n<309> fprintf(stderr, "failed to initialize spice server");
<1> static int qcow_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors)\n<7> BDRVQcowState *s = bs->opaque;\n<25> if (bs->backing_hd) {\n<45> memset(buf, 0, 512 * n);\n<51> if (qcow2_decompress_cluster(bs, cluster_offset) < 0)\n<55> memcpy(buf, s->cluster_cache + index_in_cluster * 512, 512 * n);\n<69> qcow2_encrypt_sectors(s, sector_num, buf, buf, n, 0,\n<81> buf += n * 512;
<1> build_ssdt(GArray *table_data, GArray *linker,\n<21> ssdt_ptr = acpi_data_push(table_data, sizeof(ssdp_misc_aml));\n<23> memcpy(ssdt_ptr, ssdp_misc_aml, sizeof(ssdp_misc_aml));\n<45> patch_pci_windows(pci, ssdt_ptr, sizeof(ssdp_misc_aml));\n<69> for (i = 0; i < acpi_cpus; i++) {\n<71> uint8_t *proc = acpi_data_push(sb_scope, ACPI_PROC_SIZEOF);\n<73> memcpy(proc, ACPI_PROC_AML, ACPI_PROC_SIZEOF);\n<75> proc[ACPI_PROC_OFFSET_CPUHEX] = acpi_get_hex(i >> 4);\n<77> proc[ACPI_PROC_OFFSET_CPUHEX+1] = acpi_get_hex(i);\n<79> proc[ACPI_PROC_OFFSET_CPUID1] = i;\n<81> proc[ACPI_PROC_OFFSET_CPUID2] = i;
<1> static void smbios_build_type_0_fields(QemuOpts *opts)\n<43> val = qemu_opt_get(opts, "release");\n<45> if (val) {\n<47> if (sscanf(val, "%hhu.%hhu", &major, &minor) != 2) {\n<49> error_report("Invalid release");\n<51> exit(1);
<1> static char *qemu_rbd_next_tok(int max_len,\n<3> char *src, char delim,\n<49> l = strlen(src);\n<51> if (l >= max_len) {\n<67> return src;
<1> void qemu_chr_printf(CharDriverState *s, const char *fmt, ...)\n<9> va_start(ap, fmt);\n<11> vsnprintf(buf, sizeof(buf), fmt, ap);\n<13> qemu_chr_write(s, (uint8_t *)buf, strlen(buf));\n<15> va_end(ap);
<1> static int mpegts_write_packet(AVFormatContext *s, AVPacket *pkt)\n<9> uint8_t *buf= pkt->data;\n<11> MpegTSWriteStream *ts_st = st->priv_data;\n<85> while (size > 0) {\n<87> len = max_payload_size - ts_st->payload_index;\n<89> if (len > size)\n<91> len = size;\n<93> memcpy(ts_st->payload + ts_st->payload_index, buf, len);\n<95> buf += len;\n<97> size -= len;\n<99> ts_st->payload_index += len;\n<101> if (access_unit_index && access_unit_index < buf &&\n<115> mpegts_write_pes(s, st, ts_st->payload, ts_st->payload_index,
<1> static void kempf_restore_buf(const uint8_t *src, int len,\n<3> uint8_t *dst, int stride,\n<5> const uint8_t *jpeg_tile, int tile_stride,\n<9> const uint8_t *pal, int npal, int tidx)\n<33> for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {\n<43> if (col != tidx)\n<45> memcpy(dst + i * 3, pal + col * 3, 3);\n<49> memcpy(dst + i * 3, jpeg_tile + i * 3, 3);
<1> static void qemu_enqueue_packet(VLANClientState *sender,\n<3> const uint8_t *buf, int size,\n<13> packet = qemu_malloc(sizeof(VLANPacket) + size);\n<21> memcpy(packet->data, buf, size);\n<25> TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);
<1> ssize_t qemu_sendv_packet(VLANClientState *sender, const struct iovec *iov,\n<31> packet = qemu_malloc(sizeof(VLANPacket) + max_len);\n<37> packet->size = 0;\n<39> for (i = 0; i < iovcnt; i++) {\n<41> size_t len = iov[i].iov_len;\n<45> memcpy(packet->data + packet->size, iov[i].iov_base, len);\n<47> packet->size += len;
<1> static void readline_update(ReadLineState *rs)\n<9> if (rs->cmd_buf_size != rs->last_cmd_buf_size ||\n<11> memcmp(rs->cmd_buf, rs->last_cmd_buf, rs->cmd_buf_size) != 0) {\n<19> rs->cmd_buf[rs->cmd_buf_size] = '\0';\n<21> if (rs->read_password) {\n<23> len = strlen(rs->cmd_buf);\n<25> for(i = 0; i < len; i++)\n<31> monitor_printf(rs->mon, "%s", rs->cmd_buf);\n<37> memcpy(rs->last_cmd_buf, rs->cmd_buf, rs->cmd_buf_size);\n<39> rs->last_cmd_buf_size = rs->cmd_buf_size;\n<41> rs->last_cmd_buf_index = rs->cmd_buf_size;
<1> static void sun4m_hw_init(const struct sun4m_hwdef *hwdef,\n<3> MachineState *machine)\n<285> if (hwdef->fd_base) {\n<289> memset(fd, 0, sizeof(fd));\n<293> sun4m_fdctrl_init(slavio_irq[22], hwdef->fd_base, fd,\n<311> if (drive_get_max_bus(IF_SCSI) > 0) {\n<313> fprintf(stderr, "qemu: too many SCSI bus\n");\n<417> if (machine->kernel_cmdline) {\n<425> fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);\n<429> strlen(machine->kernel_cmdline) + 1);
<1> int ff_h264_decode_ref_pic_marking(H264Context *h, GetBitContext *gb,\n<9> MMCO mmco_temp[MAX_MMCO_COUNT], *mmco = mmco_temp;\n<81> !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) {\n<123> ret = ff_generate_sliding_window_mmcos(h, first_slice);\n<139> if (first_slice && mmco_index != -1) {\n<141> memcpy(h->mmco, mmco_temp, sizeof(h->mmco));
<1> void avcodec_get_context_defaults2(AVCodecContext *s, enum AVMediaType codec_type){\n<5> memset(s, 0, sizeof(AVCodecContext));\n<27> av_opt_set_defaults2(s, flags, flags);
<1> static inline void mix_stereo_to_mono(AC3DecodeContext *ctx)\n<15> memset(output[2], 0, sizeof(output[2]));
<1> void simplestring_addn ( simplestring * target , const char * source , int add_len ) {\n<2> if ( target && source ) {\n<3> if ( ! target -> str ) {\n<4> simplestring_init_str ( target ) ;\n<6> if ( target -> len + add_len + 1 > target -> size ) {\n<9> newsize = newsize - ( newsize % incr ) + incr ;\n<10> target -> str = ( char * ) realloc ( target -> str , newsize ) ;\n<11> target -> size = target -> str ? newsize : 0 ;\n<14> if ( add_len ) {\n<15> memcpy ( target -> str + target -> len , source , add_len ) ;\n<17> target -> len += add_len ;
<1> void kvm_s390_interrupt_internal(S390CPU *cpu, int type, uint32_t parm,\n<43> if (r < 0) {\n<45> fprintf(stderr, "KVM failed to inject interrupt\n");
<1> static int serial_parse(const char *devname)\n<11> if (strcmp(devname, "none") == 0)\n<13> return 0;\n<15> if (index == MAX_SERIAL_PORTS) {\n<17> fprintf(stderr, "qemu: too many serial ports\n");\n<23> snprintf(label, sizeof(label), "serial%d", index);\n<25> serial_hds[index] = qemu_chr_new(label, devname, NULL);\n<27> if (!serial_hds[index]) {\n<29> fprintf(stderr, "qemu: could not connect serial device"
<1> static int cpu_x86_find_by_name(x86_def_t *x86_cpu_def, const char *cpu_model)\n<11> char *s = strdup(cpu_model);\n<13> char *featurestr, *name = strtok(s, ",");\n<25> for (i = 0; i < ARRAY_SIZE(x86_defs); i++) {\n<27> if (strcmp(name, x86_defs[i].name) == 0) {\n<29> def = &x86_defs[i];\n<37> if (kvm_enabled() && strcmp(name, "host") == 0) {\n<39> cpu_x86_fill_host(x86_cpu_def);\n<41> } else if (!def) {\n<47> memcpy(x86_cpu_def, def, sizeof(*def));\n<53> add_flagname_to_bitmaps("hypervisor", &plus_features,\n<55> &plus_ext_features, &plus_ext2_features, &plus_ext3_features);\n<59> featurestr = strtok(NULL, ",");\n<63> while (featurestr) {\n<67> if (featurestr[0] == '+') {\n<69> add_flagname_to_bitmaps(featurestr + 1, &plus_features, &plus_ext_features, &plus_ext2_features, &plus_ext3_features);\n<71> } else if (featurestr[0] == '-') {\n<73> add_flagname_to_bitmaps(featurestr + 1, &minus_features, &minus_ext_features, &minus_ext2_features, &minus_ext3_features);\n<75> } else if ((val = strchr(featurestr, '='))) {\n<77> *val = 0; val++;\n<79> if (!strcmp(featurestr, "family")) {\n<83> family = strtol(val, &err, 10);\n<85> if (!*val || *err || family < 0) {\n<87> fprintf(stderr, "bad numerical value %s\n", val);\n<95> } else if (!strcmp(featurestr, "model")) {\n<99> model = strtol(val, &err, 10);\n<101> if (!*val || *err || model < 0 || model > 0xff) {\n<103> fprintf(stderr, "bad numerical value %s\n", val);\n<111> } else if (!strcmp(featurestr, "stepping")) {\n<115> stepping = strtol(val, &err, 10);\n<117> if (!*val || *err || stepping < 0 || stepping > 0xf) {\n<119> fprintf(stderr, "bad numerical value %s\n", val);\n<127> } else if (!strcmp(featurestr, "vendor")) {\n<129> if (strlen(val) != 12) {\n<131> fprintf(stderr, "vendor string must be 12 chars long\n");\n<137> x86_cpu_def->vendor1 = 0;\n<139> x86_cpu_def->vendor2 = 0;\n<141> x86_cpu_def->vendor3 = 0;\n<143> for(i = 0; i < 4; i++) {\n<145> x86_cpu_def->vendor1 |= ((uint8_t)val[i    ]) << (8 * i);\n<147> x86_cpu_def->vendor2 |= ((uint8_t)val[i + 4]) << (8 * i);\n<149> x86_cpu_def->vendor3 |= ((uint8_t)val[i + 8]) << (8 * i);\n<153> x86_cpu_def->vendor_override = 1;\n<155> } else if (!strcmp(featurestr, "model_id")) {\n<157> pstrcpy(x86_cpu_def->model_id, sizeof(x86_cpu_def->model_id),\n<163> fprintf(stderr, "unrecognized feature %s\n", featurestr);\n<171> fprintf(stderr, "feature string `%s' not in format (+feature|-feature|feature=xyz)\n", featurestr);\n<177> featurestr = strtok(NULL, ",");\n<181> x86_cpu_def->features |= plus_features;\n<183> x86_cpu_def->ext_features |= plus_ext_features;\n<185> x86_cpu_def->ext2_features |= plus_ext2_features;\n<187> x86_cpu_def->ext3_features |= plus_ext3_features;\n<189> x86_cpu_def->features &= ~minus_features;\n<191> x86_cpu_def->ext_features &= ~minus_ext_features;\n<193> x86_cpu_def->ext2_features &= ~minus_ext2_features;\n<195> x86_cpu_def->ext3_features &= ~minus_ext3_features;\n<197> free(s);\n<205> free(s);\n<207> return -1;
<1> static void decode_vui(HEVCContext *s, HEVCSPS *sps)\n<5> VUI *vui          = &sps->vui;\n<121> if( get_bits_left(gb) >= 66)\n<123> memcpy(&backup, gb, sizeof(backup));\n<131> vui->def_disp_win.left_offset   = get_ue_golomb_long(gb) * 2;\n<133> vui->def_disp_win.right_offset  = get_ue_golomb_long(gb) * 2;\n<135> vui->def_disp_win.top_offset    = get_ue_golomb_long(gb) * 2;\n<137> vui->def_disp_win.bottom_offset = get_ue_golomb_long(gb) * 2;\n<167> vui->def_disp_win.bottom_offset = 0;\n<175> vui->vui_timing_info_present_flag = get_bits1(gb);\n<181> if( get_bits_left(gb) < 66) {\n<193> memset(&vui->def_disp_win, 0, sizeof(vui->def_disp_win));\n<195> memcpy(gb, &backup, sizeof(backup));\n<201> vui->vui_num_units_in_tick               = get_bits_long(gb, 32);
<1> void cpu_physical_memory_write_rom(hwaddr addr,\n<3> const uint8_t *buf, int len)\n<19> l = len;\n<39> ptr = qemu_get_ram_ptr(addr1);\n<41> memcpy(ptr, buf, l);\n<43> invalidate_and_set_dirty(addr1, l);\n<49> buf += l;
<1> static int spapr_vga_init(PCIBus *pci_bus)\n<5> switch (vga_interface_type) {\n<19> fprintf(stderr, "This vga model is not supported,"
<1> void ide_init_drive(IDEState *s, DriveInfo *dinfo,\n<43> bdrv_set_change_cb(s->bs, cdrom_change_cb, s);\n<47> if (serial && *serial) {\n<49> strncpy(s->drive_serial_str, serial, sizeof(s->drive_serial_str));\n<69> ide_reset(s);
<1> static int create_header64(DumpState *s)\n<31> dh = g_malloc0(size);\n<35> strncpy(dh->signature, KDUMP_SIGNATURE, strlen(KDUMP_SIGNATURE));\n<61> strncpy(dh->utsname.machine, ELF_MACHINE_UNAME, sizeof(dh->utsname.machine));\n<95> if (write_buffer(s->fd, 0, dh, size) < 0) {\n<199> g_free(dh);
<1> int net_client_init(Monitor *mon, const char *device, const char *p)\n<39> if (!strcmp(device, "nic")) {\n<51> int idx = nic_get_free_idx();\n<55> if (check_params(buf, sizeof(buf), nic_params, p) < 0) {\n<107> if (get_param_value(buf, sizeof(buf), "model", p)) {\n<109> nd->model = strdup(buf);\n<113> if (get_param_value(buf, sizeof(buf), "addr", p)) {\n<115> nd->devaddr = strdup(buf);\n<135> if (!strcmp(device, "none")) {\n<137> if (*p != '\0') {\n<305> if (!strcmp(device, "tap")) {\n<307> char ifname[64], chkbuf[64];\n<309> char setup_script[1024], down_script[1024];\n<315> vlan->nb_host_devs++;\n<317> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<333> s = net_tap_fd_init(vlan, device, name, fd);\n<371> s = net_tap_init(vlan, device, name, ifname, setup_script, down_script);\n<389> if (!strcmp(device, "socket")) {\n<391> char chkbuf[64];\n<393> if (get_param_value(buf, sizeof(buf), "fd", p) > 0) {\n<411> if (net_socket_fd_init(vlan, device, name, fd, 1))\n<433> ret = net_socket_listen_init(vlan, device, name, buf);\n<453> ret = net_socket_connect_init(vlan, device, name, buf);\n<473> ret = net_socket_mcast_init(vlan, device, name, buf);\n<555> if (!strcmp(device, "dump")) {\n<557> int len = 65536;\n<561> if (get_param_value(buf, sizeof(buf), "len", p) > 0) {\n<567> if (!get_param_value(buf, sizeof(buf), "file", p)) {\n<573> ret = net_dump_init(mon, vlan, device, name, buf, len);\n<577> config_error(mon, "Unknown network device: %s\n", device);\n<579> ret = -1;\n<585> if (ret < 0) {\n<587> config_error(mon, "Could not initialize device '%s'\n", device);
<1> void *av_realloc(void *ptr, unsigned int size)\n<15> if(size > INT_MAX)\n<33> return realloc(ptr, size);
<1> static gcry_err_code_t sexp_to_enc ( gcry_sexp_t sexp , gcry_mpi_t * * retarray , gcry_module_t * retalgo , int * ret_modern , int * flags , struct pk_encoding_ctx * ctx ) {\n<23> if ( ! name ) {\n<27> if ( ! strcmp ( name , "flags" ) ) {\n<30> * ret_modern = 1 ;\n<31> for ( i = gcry_sexp_length ( l2 ) - 1 ;\n<32> i > 0 ;\n<33> i -- ) {\n<35> if ( ! s ) ;\n<36> else if ( n == 3 && ! memcmp ( s , "raw" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_RAW ;\n<37> else if ( n == 5 && ! memcmp ( s , "pkcs1" , 5 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_PKCS1 ;\n<38> else if ( n == 4 && ! memcmp ( s , "oaep" , 4 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) ctx -> encoding = PUBKEY_ENC_OAEP ;\n<39> else if ( n == 3 && ! memcmp ( s , "pss" , 3 ) && ctx -> encoding == PUBKEY_ENC_UNKNOWN ) {\n<40> err = GPG_ERR_CONFLICT ;\n<43> else if ( n == 11 && ! memcmp ( s , "no-blinding" , 11 ) ) parsed_flags |= PUBKEY_FLAG_NO_BLINDING ;\n<45> err = GPG_ERR_INV_FLAG ;\n<64> s = gcry_sexp_nth_data ( l2 , 1 , & n ) ;\n<65> if ( ! s ) err = GPG_ERR_NO_OBJ ;\n<67> ctx -> label = gcry_malloc ( n ) ;\n<68> if ( ! ctx -> label ) err = gpg_err_code_from_syserror ( ) ;\n<70> memcpy ( ctx -> label , s , n ) ;\n<71> ctx -> labellen = n ;\n<79> ( l2 = gcry_sexp_nth ( list , i ) ) != NULL ;\n<80> i ++ ) {\n<81> s = gcry_sexp_nth_data ( l2 , 0 , & n ) ;\n<82> if ( ! ( n == 9 && ! memcmp ( s , "hash-algo" , 9 ) ) && ! ( n == 5 && ! memcmp ( s , "label" , 5 ) ) && ! ( n == 15 && ! memcmp ( s , "random-override" , 15 ) ) ) break ;\n<83> gcry_sexp_release ( l2 ) ;\n<89> gcry_free ( name ) ;\n<99> ath_mutex_lock ( & pubkeys_registered_lock ) ;\n<100> module = gcry_pk_lookup_name ( name ) ;\n<101> ath_mutex_unlock ( & pubkeys_registered_lock ) ;\n<102> if ( ! module ) {\n<107> elems = pubkey -> elements_enc ;\n<108> array = gcry_calloc ( strlen ( elems ) + 1 , sizeof ( * array ) ) ;\n<109> if ( ! array ) {\n<113> err = sexp_elements_extract ( list , elems , array , NULL ) ;\n<116> gcry_free ( name ) ;\n<122> gcry_free ( ctx -> label ) ;
<1> static void mcf_fec_receive(void *opaque, const uint8_t *buf, size_t size)\n<25> if (!s->rx_enabled) {\n<27> fprintf(stderr, "mcf_fec_receive: Unexpected packet\n");\n<63> if ((bd.flags & FEC_BD_E) == 0) {\n<73> fprintf(stderr, "mcf_fec: Lost end of frame\n");
<1> static void term_hist_add(const char *cmdline)\n<11> if (cmdline[0] == '\0')\n<17> if (term_hist_entry != -1) {\n<21> hist_entry = term_history[term_hist_entry];\n<25> if (strcmp(hist_entry, cmdline) == 0) {\n<35> for (idx = 0; idx < TERM_MAX_CMDS; idx++) {\n<39> if (hist_entry == NULL)\n<43> if (strcmp(hist_entry, cmdline) == 0) {\n<47> new_entry = hist_entry;\n<51> memmove(&term_history[idx], &term_history[idx + 1],\n<53> &term_history[TERM_MAX_CMDS] - &term_history[idx + 1]);\n<55> term_history[TERM_MAX_CMDS - 1] = NULL;\n<57> for (; idx < TERM_MAX_CMDS; idx++) {\n<59> if (term_history[idx] == NULL)\n<71> if (idx == TERM_MAX_CMDS) {\n<75> free(term_history[0]);\n<79> &term_history[TERM_MAX_CMDS] - &term_history[1]);\n<87> if (new_entry == NULL)\n<89> new_entry = strdup(cmdline);\n<91> term_history[idx] = new_entry;
<1> static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,\n<119> if ((ret = decode_ihdr_chunk(avctx, s, length)) < 0)\n<127> if ((ret = decode_phys_chunk(avctx, s)) < 0)\n<139> if ((ret = decode_fctl_chunk(avctx, s, length)) < 0)\n<173> if ((ret = decode_idat_chunk(avctx, s, length, p)) < 0)\n<181> if (decode_plte_chunk(avctx, s, length) < 0)\n<189> if (decode_trns_chunk(avctx, s, length) < 0)\n<197> if (decode_text_chunk(s, length, 0, metadatap) < 0)\n<207> if (decode_text_chunk(s, length, 1, metadatap) < 0)\n<249> if (decode_iccp_chunk(s, length, p) < 0)\n<305> handle_small_bpp(s, p);\n<315> size_t raw_bpp = s->bpp - byte_depth;\n<327> uint8_t *row = &s->image_buf[s->image_linesize * y];\n<333> for (x = s->width; x > 0; --x) {\n<335> uint8_t *pixel = &row[s->bpp * (x - 1)];\n<337> memmove(pixel, &row[raw_bpp * (x - 1)], raw_bpp);\n<341> if (!memcmp(pixel, s->transparent_color_be, raw_bpp)) {\n<343> memset(&pixel[raw_bpp], 0, byte_depth);\n<347> memset(&pixel[raw_bpp], 0xff, byte_depth);\n<375> handle_p_frame_png(s, p);\n<381> (ret = handle_p_frame_apng(avctx, s, p)) < 0)
<1> AVFilterContext *ff_filter_alloc(const AVFilter *filter, const char *inst_name)\n<9> if (!filter)\n<17> if (!ret)\n<51> ret->nb_inputs = pad_count(filter->inputs);\n<57> if (!ret->input_pads)\n<61> memcpy(ret->input_pads, filter->inputs, sizeof(AVFilterPad) * ret->nb_inputs);\n<73> ret->nb_outputs = pad_count(filter->outputs);\n<79> if (!ret->output_pads)\n<83> memcpy(ret->output_pads, filter->outputs, sizeof(AVFilterPad) * ret->nb_outputs);\n<103> return ret;\n<111> av_freep(&ret->input_pads);\n<117> av_freep(&ret->output_pads);\n<123> av_free(ret);
<1> size_t iov_from_buf(struct iovec *iov, unsigned int iov_cnt, size_t iov_off,\n<3> const void *buf, size_t size)\n<15> buf_off = 0;\n<19> if (iov_off < (iovec_off + iov[i].iov_len)) {\n<21> size_t len = MIN((iovec_off + iov[i].iov_len) - iov_off, size);\n<25> memcpy(iov[i].iov_base + (iov_off - iovec_off), buf + buf_off, len);\n<29> buf_off += len;\n<31> iov_off += len;\n<33> size -= len;
<1> static int dvdsub_parse(AVCodecParserContext *s,\n<7> const uint8_t *buf, int buf_size)\n<11> DVDSubParseContext *pc = s->priv_data;\n<15> if (pc->packet_index == 0) {\n<17> if (buf_size < 2)\n<21> pc->packet_len = AV_RB16(buf);\n<27> av_freep(&pc->packet);\n<29> pc->packet = av_malloc(pc->packet_len);\n<35> if (pc->packet_index + buf_size <= pc->packet_len) {\n<37> memcpy(pc->packet + pc->packet_index, buf, buf_size);\n<39> pc->packet_index += buf_size;\n<49> return buf_size;\n<67> return buf_size;
<1> static void omap_pwt_write(void *opaque, target_phys_addr_t addr,\n<33> if (value & 1)\n<35> printf("%s: %iHz buzz on\n", __FUNCTION__, (int)\n<69> printf("%s: silence!\n", __FUNCTION__);
<1> static void short_usage ( FILE * f ) {\n<2> short_usage_sub ( f ) ;\n<3> fprintf ( f , "For more options, use %s --help\n" , my_progname_short ) ;
<1> av_cold void ff_rl_init(RLTable *rl,\n<7> int8_t  max_level[MAX_RUN + 1], max_run[MAX_LEVEL + 1];\n<9> uint8_t index_run[MAX_RUN + 1];\n<25> for (last = 0; last < 2; last++) {\n<37> end = rl->n;\n<43> memset(max_level, 0, MAX_RUN + 1);\n<45> memset(max_run, 0, MAX_LEVEL + 1);\n<47> memset(index_run, rl->n, MAX_RUN + 1);\n<55> if (index_run[run] == rl->n)\n<57> index_run[run] = i;\n<59> if (level > max_level[run])\n<61> max_level[run] = level;\n<63> if (run > max_run[level])\n<65> max_run[level] = run;\n<71> rl->max_level[last] = static_store[last];\n<75> rl->max_level[last] = av_malloc(MAX_RUN + 1);\n<77> memcpy(rl->max_level[last], max_level, MAX_RUN + 1);\n<81> rl->max_run[last]   = static_store[last] + MAX_RUN + 1;\n<85> rl->max_run[last]   = av_malloc(MAX_LEVEL + 1);\n<87> memcpy(rl->max_run[last], max_run, MAX_LEVEL + 1);\n<91> rl->index_run[last] = static_store[last] + MAX_RUN + MAX_LEVEL + 2;\n<95> rl->index_run[last] = av_malloc(MAX_RUN + 1);\n<97> memcpy(rl->index_run[last], index_run, MAX_RUN + 1);
<1> static int do_attach(USBDevice *dev)\n<5> USBBus *bus = usb_bus_from_device(dev);\n<31> if (dev->port_path) {\n<33> QTAILQ_FOREACH(port, &bus->free, next) {\n<35> if (strcmp(port->path, dev->port_path) == 0) {\n<43> if (port == NULL) {\n<45> error_report("Error: usb port %s (bus %s) not found\n",\n<73> QTAILQ_REMOVE(&bus->free, port, next);\n<79> usb_attach(port, dev);\n<83> QTAILQ_INSERT_TAIL(&bus->used, port, next);
<1> static inline abi_long target_to_host_sockaddr(int fd, struct sockaddr *addr,\n<25> target_saddr = lock_user(VERIFY_READ, target_addr, len, 1);\n<27> if (!target_saddr)\n<33> sa_family = tswap16(target_saddr->sa_family);\n<67> if (len > unix_maxlen)\n<69> len = unix_maxlen;\n<75> memcpy(addr, target_saddr, len);\n<85> lladdr = (struct target_sockaddr_ll *)addr;\n<93> unlock_user(target_saddr, target_addr, 0);
<1> void arm_load_kernel(CPUState *env, struct arm_boot_info *info)\n<23> if (!info->kernel_filename) {\n<25> fprintf(stderr, "Kernel image must be specified\n");\n<67> kernel_size = load_elf(info->kernel_filename, NULL, NULL, &elf_entry,\n<75> kernel_size = load_uimage(info->kernel_filename, &entry, NULL,\n<85> kernel_size = load_image_targphys(info->kernel_filename, entry,\n<93> if (kernel_size < 0) {\n<95> fprintf(stderr, "qemu: could not load kernel '%s'\n",\n<117> if (initrd_size < 0) {\n<119> fprintf(stderr, "qemu: could not load initrd '%s'\n",\n<153> info->write_secondary_boot(env, info);\n<167> env->boot_info = info;
<1> static inline int dmg_read_chunk(BlockDriverState *bs, uint64_t sector_num)\n<13> uint32_t chunk = search_chunk(s, sector_num);\n<33> switch (s->types[chunk]) { /* block entry type */\n<153> memset(s->uncompressed_chunk, 0, 512 * s->sectorcounts[chunk]);
<1> static void qdm2_decode_super_block(QDM2Context *q)\n<15> memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1));\n<17> memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid));\n<19> memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2));\n<29> average_quantized_coeffs(q); // average elements in quantized_coeffs[max_ch][10][8]\n<231> process_synthesis_subpackets(q, q->sub_packet_list_D);\n<237> process_subpacket_10(q, NULL);\n<239> process_subpacket_11(q, NULL);\n<241> process_subpacket_12(q, NULL);
<1> int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n<19> l = f->buf_size - f->buf_index;\n<21> if (l == 0) {\n<23> qemu_fill_buffer(f);\n<25> l = f->buf_size - f->buf_index;\n<27> if (l == 0)\n<33> if (l > size)\n<35> l = size;\n<37> memcpy(buf, f->buf + f->buf_index, l);\n<39> f->buf_index += l;\n<41> buf += l;\n<43> size -= l;
<1> static int svq1_encode_plane ( SVQ1Context * s , int plane , unsigned char * src_plane , unsigned char * ref_plane , unsigned char * decoded_plane , int width , int height , int src_stride , int stride ) {\n<7> uint8_t * src = s -> scratchbuf + stride * 16 ;\n<53> s -> m . new_picture . f . data [ 0 ] = src - y * 16 * stride ;\n<56> i < 16 && i + 16 * y < height ;\n<58> memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n<59> for ( x = width ;\n<61> x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n<64> i < 16 && i + 16 * y < 16 * block_height ;\n<65> i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n<84> i < 16 && i + 16 * y < height ;\n<86> memcpy ( & src [ i * stride ] , & src_plane [ ( i + 16 * y ) * src_stride ] , width ) ;\n<87> for ( x = width ;\n<89> x ++ ) src [ i * stride + x ] = src [ i * stride + x - 1 ] ;\n<92> i < 16 && i + 16 * y < 16 * block_height ;\n<93> i ++ ) memcpy ( & src [ i * stride ] , & src [ ( i - 1 ) * stride ] , 16 * block_width ) ;\n<123> score [ 0 ] += encode_block ( s , src + 16 * x , NULL , temp , stride , 5 , 64 , lambda , 1 ) ;\n<156> score [ 1 ] += encode_block ( s , src + 16 * x , temp + 16 , decoded , stride , 5 , 64 , lambda , 0 ) ;\n<159> score [ 2 ] = s -> dsp . sse [ 0 ] ( NULL , src + 16 * x , ref , stride , 16 ) ;
<1> static int gdb_handle_packet(GDBState *s, const char *line_buf)\n<29> ch = *p++;\n<31> switch(ch) {\n<121> fprintf(stderr, "\nQEMU: Terminated via GDBstub\n");\n<257> len = strlen(p) / 2;\n<259> hextomem((uint8_t *)registers, p, len);\n<357> if (!gdb_has_xml)\n<361> addr = strtoull(p, (char **)&p, 16);\n<363> if (*p == '=')\n<365> p++;\n<367> reg_size = strlen(p) / 2;\n<369> hextomem(mem_buf, p, reg_size);\n<501> if (!strcmp(p,"qemu.sstepbits")) {\n<505> snprintf(buf, sizeof(buf), "ENABLE=%x,NOIRQ=%x,NOTIMER=%x",\n<513> put_packet(s, buf);\n<517> } else if (strncmp(p,"qemu.sstep",10) == 0) {\n<545> } else if (strcmp(p,"C") == 0) {\n<551> put_packet(s, "QC1");\n<555> } else if (strcmp(p,"fThreadInfo") == 0) {\n<557> s->query_cpu = first_cpu;\n<561> } else if (strcmp(p,"sThreadInfo") == 0) {\n<565> if (s->query_cpu) {\n<579> } else if (strncmp(p,"ThreadExtraInfo,", 16) == 0) {
<1> int load_image_gzipped(const char *filename, hwaddr addr, uint64_t max_sz)\n<17> if (!g_file_get_contents(filename, (char **) &compressed_data, &len,\n<53> if (bytes < 0) {\n<55> fprintf(stderr, "%s: unable to decompress gzipped kernel file\n",
<1> void *qemu_malloc(size_t size)\n<5> return malloc(size);
<1> static unsigned int dec_movem_rm(DisasContext *dc)\n<13> DIS(fprintf (logfile, "movem $r%u, [$r%u%s\n", dc->op2, dc->op1,\n<19> cris_flush_cc_state(dc);\n<31> for (i = 0; i <= dc->op2; i++) {\n<37> gen_store(dc, addr, cpu_R[i], 4);\n<47> cris_cc_mask(dc, 0);
<1> void checkasm_check_h264qpel(void)\n<37> if (check_func(tab[i][j], "%s_h264_qpel_%d_mc%d%d_%d", op_name, size, j & 3, j >> 2, bit_depth)) {\n<41> call_ref(dst0, src0, (ptrdiff_t)size * SIZEOF_PIXEL);\n<43> call_new(dst1, src1, (ptrdiff_t)size * SIZEOF_PIXEL);\n<45> if (memcmp(buf0, buf1, BUF_SIZE) || memcmp(dst0, dst1, BUF_SIZE))\n<47> fail();\n<49> bench_new(dst1, src1, (ptrdiff_t)size * SIZEOF_PIXEL);
<1> void qmp_block_set_io_throttle(const char *device, int64_t bps, int64_t bps_rd,\n<77> if (!bs) {\n<87> memset(&cfg, 0, sizeof(cfg));\n<151> if (!check_throttle_config(&cfg, errp)) {\n<159> if (throttle_enabled(&cfg)) {\n<177> bdrv_set_io_limits(bs, &cfg);
<16> static void feature_destroy ( hb_feature_t * g ) {\n<17> free ( g ) ;
<1> static int os_host_main_loop_wait(int64_t timeout)\n<27> if (!timeout && (spin_counter > MAX_MAIN_LOOP_SPIN)) {\n<33> if (!notified && !qtest_driver()) {
<1> static void find_completion(const char *cmdline)\n<17> parse_cmdline(cmdline, &nb_args, args);\n<35> len = strlen(cmdline);\n<37> if (len > 0 && isspace(cmdline[len - 1])) {\n<47> if (nb_args <= 1) {\n<53> cmdname = "";\n<57> cmdname = args[0];\n<59> completion_index = strlen(cmdname);\n<63> cmd_completion(cmdname, cmd->name);\n<99> str = args[nb_args - 1];\n<101> switch(*ptype) {\n<107> completion_index = strlen(str);\n<109> file_completion(str);\n<117> completion_index = strlen(str);\n<119> bdrv_iterate(block_completion_it, (void *)str);
<1> static int create_ppc_opcodes (CPUPPCState *env, const ppc_def_t *def)\n<29> if (register_insn(env->opcodes, opc) < 0) {\n<31> printf("*** ERROR initializing PowerPC instruction "
<1> static struct iovec *lock_iovec(int type, abi_ulong target_addr,\n<27> if (count < 0 || count > IOV_MAX) {\n<37> vec = calloc(count, sizeof(struct iovec));\n<39> if (vec == NULL) {\n<53> if (target_vec == NULL) {\n<81> if (len < 0) {\n<97> if (!vec[i].iov_base) {\n<133> free(vec);
<1> void validate_bootdevices(const char *devices)\n<33> if (*p < 'a' || *p > 'p') {\n<35> fprintf(stderr, "Invalid boot device '%c'\n", *p);\n<41> if (bitmap & (1 << (*p - 'a'))) {\n<43> fprintf(stderr, "Boot device '%c' was given twice\n", *p);\n<49> bitmap |= 1 << (*p - 'a');
<1> static int protocol_client_auth_vnc(VncState *vs, uint8_t *data, size_t len)\n<5> unsigned char response[VNC_AUTH_CHALLENGE_SIZE];\n<15> if (!vs->vd->password || !vs->vd->password[0]) {\n<23> if (vs->vd->expires < now) {\n<33> memcpy(response, vs->challenge, VNC_AUTH_CHALLENGE_SIZE);\n<39> pwlen = strlen(vs->vd->password);\n<43> key[i] = i<pwlen ? vs->vd->password[i] : 0;\n<47> for (j = 0; j < VNC_AUTH_CHALLENGE_SIZE; j += 8)\n<49> des(response+j, response+j);\n<55> if (memcmp(response, data, VNC_AUTH_CHALLENGE_SIZE) != 0) {\n<57> VNC_DEBUG("Client challenge reponse did not match\n");\n<63> VNC_DEBUG("Accepting VNC challenge response\n");\n<65> vnc_write_u32(vs, 0); /* Accept auth */\n<67> vnc_flush(vs);\n<71> start_client_init(vs);\n<75> return 0;\n<81> vnc_write_u32(vs, 1); /* Reject auth */\n<83> if (vs->minor >= 8) {\n<87> vnc_write_u32(vs, sizeof(err));\n<89> vnc_write(vs, err, sizeof(err));\n<93> vnc_flush(vs);\n<95> vnc_client_error(vs);\n<97> return 0;
<1> static int ram_load(QEMUFile *f, void *opaque, int version_id)\n<39> if (flags & RAM_SAVE_FLAG_COMPRESS) {\n<41> uint8_t ch = qemu_get_byte(f);\n<43> memset(qemu_get_ram_ptr(addr), ch, TARGET_PAGE_SIZE);\n<47> if (ch == 0 &&\n<51> madvise(qemu_get_ram_ptr(addr), TARGET_PAGE_SIZE, MADV_DONTNEED);\n<59> qemu_get_buffer(f, qemu_get_ram_ptr(addr), TARGET_PAGE_SIZE);
<7> ColorSpaceContext *s = ctx->priv;\n<97> if (!s->in_primaries) {\n<113> if (!s->out_primaries) {\n<143> s->lrgb2lrgb_passthrough = !memcmp(s->in_primaries, s->out_primaries,\n<147> if (!s->lrgb2lrgb_passthrough) {\n<153> fill_rgb2xyz_table(s->out_primaries, rgb2xyz);\n<157> fill_rgb2xyz_table(s->in_primaries, rgb2xyz);\n<203> if (!s->in_txchr) {\n<219> if (!s->in_txchr) {\n<235> if (!s->out_txchr) {\n<243> if (!s->out_txchr) {\n<279> s->rgb2rgb_passthrough = s->fast_mode || (s->lrgb2lrgb_passthrough &&\n<281> !memcmp(s->in_txchr, s->out_txchr, sizeof(*s->in_txchr)));\n<285> res = fill_gamma_table(s);\n<297> if (!s->in_lumacoef) {\n<317> if (!s->in_lumacoef) {\n<335> if (!s->out_lumacoef) {\n<343> if (!s->out_lumacoef) {\n<387> s->yuv2yuv_passthrough = s->yuv2yuv_fastmode && s->in_rng == s->out_rng &&\n<425> fill_rgb2yuv_table(s->in_lumacoef, rgb2yuv);\n<491> fill_rgb2yuv_table(s->out_lumacoef, rgb2yuv);
<1> static void curses_refresh(DisplayChangeListener *dcl)\n<39> if (nextchr == ERR)\n<41> chr = getch();\n<53> if (chr == ERR)\n<89> if (keycode == 1) {\n<91> nextchr = getch();\n<95> if (nextchr != ERR) {
<1> static int ppce500_load_device_tree(CPUPPCState *env,\n<75> const char *toplevel_compat = qemu_opt_get(machine_opts, "dt_compatible");\n<143> if (ret < 0) {\n<145> fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");\n<155> if (ret < 0) {\n<157> fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");\n<169> if (ret < 0)\n<171> fprintf(stderr, "couldn't set /chosen/bootargs\n");\n<481> if (toplevel_compat) {\n<483> qemu_devtree_setprop(fdt, "/", "compatible", toplevel_compat,\n<485> strlen(toplevel_compat) + 1);
<1> static void xhci_port_write(void *ptr, hwaddr reg,\n<47> uint32_t old_pls = get_field(port->portsc, PORTSC_PLS);\n<49> uint32_t new_pls = get_field(val, PORTSC_PLS);\n<51> switch (new_pls) {\n<87> fprintf(stderr, "%s: ignore pls write (old %d, new %d)\n",
<1> SocketAddress *socket_parse(const char *str, Error **errp)\n<47> } else if (strstart(str, "vsock:", NULL)) {\n<51> addr->u.vsock.data = g_new(VsockSocketAddress, 1);\n<53> if (vsock_parse(addr->u.vsock.data, str + strlen("vsock:"), errp)) {\n<73> return addr;\n<79> qapi_free_SocketAddress(addr);\n<81> return NULL;
<1> static int decrypt_init(AVFormatContext *s, ID3v2ExtraMeta *em, uint8_t *header)\n<5> OMAContext *oc = s->priv_data;\n<7> ID3v2ExtraMetaGEOB *geob = NULL;\n<21> while (em) {\n<23> if (!strcmp(em->tag, "GEOB") &&\n<25> (geob = em->data) &&\n<27> (!strcmp(geob->description, "OMG_LSI") ||\n<29> !strcmp(geob->description, "OMG_BKLSI"))) {\n<35> em = em->next;\n<39> if (!em) {\n<49> if (geob->datasize < 64) {\n<63> if (AV_RB16(gdata) != 1)\n<79> if (memcmp(&gdata[OMA_ENC_HEADER_SIZE], "KEYRING     ", 12)) {\n<81> av_log(s, AV_LOG_ERROR, "Invalid encryption header\n");\n<83> return -1;\n<87> if (oc->k_size + oc->e_size + oc->i_size > geob->datasize) {\n<101> memcpy(oc->iv, &header[0x58], 8);\n<103> hex_log(s, AV_LOG_DEBUG, "IV", oc->iv, 8);\n<117> if (!memcmp(oc->r_val, (const uint8_t[8]){0}, 8) ||\n<119> rprobe(s, gdata, oc->r_val) < 0 &&\n<125> for (i = 0; i < FF_ARRAY_ELEMS(leaf_table); i += 2) {\n<135> if (!rprobe(s, gdata, oc->r_val) || !nprobe(s, gdata, geob->datasize, oc->n_val))\n<141> if (i >= FF_ARRAY_ELEMS(leaf_table)) {\n<155> av_des_init(&oc->av_des, oc->m_val, 64, 0);\n<157> av_des_crypt(&oc->av_des, oc->e_val, &gdata[OMA_ENC_HEADER_SIZE + 40], 1, NULL, 0);\n<159> hex_log(s, AV_LOG_DEBUG, "EK", oc->e_val, 8);\n<165> av_des_init(&oc->av_des, oc->e_val, 64, 1);\n<169> return 0;
<1> static void encode_plane(FFV1Context *s, uint8_t *src, int w, int h,\n<17> memset(s->sample_buffer, 0, ring_size * (w + 6) * sizeof(*s->sample_buffer));\n<25> sample[i] = s->sample_buffer + (w + 6) * ((h + i - y) % ring_size) + 3;\n<41> encode_line(s, w, sample, plane_index, 8);\n<63> encode_line(s, w, sample, plane_index, s->bits_per_raw_sample);
<1> static void sbr_mapping(AACContext *ac, SpectralBandReplication *sbr,\n<11> memset(ch_data->s_indexmapped[1], 0, 7*sizeof(ch_data->s_indexmapped[1]));\n<55> (e >= e_a[1] || (ch_data->s_indexmapped[0][m_midpoint - sbr->kx[1]] == 1));\n<63> for (i = 0; i < ilim; i++) {\n<65> int additional_sinusoid_present = 0;\n<71> additional_sinusoid_present = 1;\n<79> memset(&sbr->s_mapped[e][table[i] - sbr->kx[1]], additional_sinusoid_present,\n<81> (table[i + 1] - table[i]) * sizeof(sbr->s_mapped[e][0]));\n<89> memcpy(ch_data->s_indexmapped[0], ch_data->s_indexmapped[ch_data->bs_num_env], sizeof(ch_data->s_indexmapped[0]));
<1> void av_url_split(char *proto, int proto_size,\n<11> const char *url)\n<33> if ((p = strchr(url, ':'))) {\n<35> av_strlcpy(proto, url, FFMIN(proto_size, p + 1 - url));\n<37> p++; /* skip ':' */\n<39> if (*p == '/') p++;\n<41> if (*p == '/') p++;\n<47> av_strlcpy(path, url, path_size);\n<49> return;\n<57> ls = strchr(p, '/');\n<59> ls2 = strchr(p, '?');\n<61> if(!ls)\n<63> ls = ls2;\n<65> else if (ls && ls2)\n<69> if(ls)\n<75> ls = &p[strlen(p)]; // XXX\n<81> if (ls != p) {\n<85> if ((at = strchr(p, '@')) && at < ls) {\n<89> FFMIN(authorization_size, at + 1 - p));\n<91> p = at + 1; /* skip '@' */\n<97> if (*p == '[' && (brk = strchr(p, ']')) && brk < ls) {\n<101> av_strlcpy(hostname, p + 1,\n<103> FFMIN(hostname_size, brk - p));\n<105> if (brk[1] == ':' && port_ptr)\n<109> } else if ((col = strchr(p, ':')) && col < ls) {\n<113> FFMIN(col + 1 - p, hostname_size));\n<115> if (port_ptr) *port_ptr = atoi(col + 1);\n<121> FFMIN(ls + 1 - p, hostname_size));
<1> static unsigned int dec_btstq(DisasContext *dc)\n<7> dc->op1 = EXTRACT_FIELD(dc->ir, 0, 4);\n<9> DIS(fprintf (logfile, "btstq %u, $r%d\n", dc->op1, dc->op2));\n<13> cris_cc_mask(dc, CC_MASK_NZ);\n<19> l0, cpu_R[dc->op2], tcg_const_tl(dc->op1), 4);\n<21> cris_update_cc_op(dc, CC_OP_FLAGS, 4);\n<23> t_gen_mov_preg_TN(dc, PR_CCS, l0);
<1> static void vscsi_inquiry_no_target(VSCSIState *s, vscsi_req *req)\n<7> uint8_t resp_data[36];\n<15> if ((cdb[1] & 0x01) || (cdb[1] & 0x01) || cdb[2] != 0) {\n<37> memset(resp_data, 0, 36);\n<49> memcpy(&resp_data[16], "QEMU EMPTY      ", 16);\n<51> memcpy(&resp_data[8], "QEMU    ", 8);\n<59> rc = vscsi_srp_transfer_data(s, req, 0, resp_data, len);
<1> static int get_pci_irq_state(QEMUFile *f, void *pv, size_t size)\n<7> uint32_t irq_state[PCI_NUM_PINS];\n<15> if (irq_state[i] != 0x1 && irq_state[i] != 0) {\n<17> fprintf(stderr, "irq state %d: must be 0 or 1.\n",
<1> static int mxf_parse_structural_metadata(MXFContext *mxf)\n<97> if (!component || component->type != SourceClip)\n<103> for (k = 0; k < mxf->packages_count; k++) {\n<105> if (!(temp_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[k]))) {\n<113> if (!memcmp(temp_package->package_uid, component->source_package_uid, 16)) {\n<115> source_package = temp_package;\n<123> if (!source_package) {
<1> static float pvq_band_cost(CeltPVQ *pvq, CeltFrame *f, OpusRangeCoder *rc, int band,\n<17> float *X = buf;\n<19> float *X_orig = f->block[0].coeffs + (ff_celt_freq_bands[band] << f->size);\n<21> float *Y = (f->channels == 2) ? &buf[176] : NULL;\n<23> float *Y_orig = f->block[1].coeffs + (ff_celt_freq_bands[band] << f->size);\n<29> memcpy(X, X_orig, band_size*sizeof(float));\n<31> if (Y)\n<33> memcpy(Y, Y_orig, band_size*sizeof(float));\n<51> pvq->quant_band(pvq, f, rc, band, X, NULL, band_size, b / 2, f->blocks, NULL,\n<57> pvq->quant_band(pvq, f, rc, band, Y, NULL, band_size, b / 2, f->blocks, NULL,\n<63> pvq->quant_band(pvq, f, rc, band, X, Y, band_size, b, f->blocks, NULL, f->size,\n<73> err_x += (X[i] - X_orig[i])*(X[i] - X_orig[i]);\n<77> err_y += (Y[i] - Y_orig[i])*(Y[i] - Y_orig[i]);
<1> AVFilterBufferRef *avfilter_default_get_audio_buffer(AVFilterLink *link, int perms,\n<11> AVFilterBufferRef *ref = NULL;\n<19> if (!samples || !(ref = av_mallocz(sizeof(AVFilterBufferRef))))\n<33> if (!ref->audio)\n<81> samples->linesize[i] = planar > 0 ? per_channel_size : sample_size;\n<83> memset(&samples->linesize[chans_nb], 0, (8-chans_nb) * sizeof(samples->linesize[0]));\n<93> if (!buf)\n<113> samples->data[i] = buf + step_size;\n<121> samples->data[i] = buf;\n<127> memset(&samples->data[chans_nb], 0, (8-chans_nb) * sizeof(samples->data[0]));\n<131> memcpy(ref->data,     samples->data,     sizeof(ref->data));\n<133> memcpy(ref->linesize, samples->linesize, sizeof(ref->linesize));\n<137> return ref;
<1> static int msrle_decode_frame(AVCodecContext *avctx,\n<13> MsrleContext *s = avctx->priv_data;\n<33> if (avctx->bits_per_coded_sample > 1 && avctx->bits_per_coded_sample <= 8) {\n<35> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n<39> if (pal) {\n<43> memcpy(s->pal, pal, AVPALETTE_SIZE);\n<49> memcpy(s->frame->data[1], s->pal, AVPALETTE_SIZE);\n<59> int linesize = (avctx->width * avctx->bits_per_coded_sample + 7) / 8;\n<61> uint8_t *ptr = s->frame->data[0];\n<63> uint8_t *buf = avpkt->data + (avctx->height-1)*istride;\n<71> if (avctx->bits_per_coded_sample == 4) {\n<75> ptr[j+0] = buf[j>>1] >> 4;\n<77> ptr[j+1] = buf[j>>1] & 0xF;\n<83> ptr[j+0] = buf[j>>1] >> 4;\n<87> memcpy(ptr, buf, linesize);\n<91> buf -= istride;\n<93> ptr += s->frame->linesize[0];
<1> static int flic_decode_frame_8BPP ( AVCodecContext * avctx , void * data , int * got_frame , const uint8_t * buf , int buf_size ) {\n<2> FlicDecodeContext * s = avctx -> priv_data ;\n<35> pixels = s -> frame . data [ 0 ] ;\n<42> while ( ( frame_size > 0 ) && ( num_chunks > 0 ) ) {\n<45> switch ( chunk_type ) {\n<66> if ( s -> palette [ palette_ptr ] != entry ) s -> new_palette = 1 ;\n<67> s -> palette [ palette_ptr ++ ] = entry ;\n<86> pixels [ pixel_ptr ] = line_packets & 0xff ;\n<109> pixels [ pixel_ptr ++ ] = palette_idx2 ;\n<117> pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n<147> pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n<157> pixels [ pixel_ptr ++ ] = palette_idx1 ;\n<166> case FLI_BLACK : memset ( pixels , 0 , s -> frame . linesize [ 0 ] * s -> avctx -> height ) ;\n<187> pixels [ pixel_ptr ++ ] = palette_idx1 ;\n<198> pixels [ pixel_ptr ++ ] = bytestream2_get_byte ( & g2 ) ;\n<215> bytestream2_get_buffer ( & g2 , & pixels [ y_ptr ] , s -> avctx -> width ) ;\n<228> memcpy ( s -> frame . data [ 1 ] , s -> palette , AVPALETTE_SIZE ) ;
<1> static int flac_probe(AVProbeData *p)\n<9> if(ff_id3v2_match(bufptr))\n<11> bufptr += ff_id3v2_tag_len(bufptr);\n<15> if(memcmp(bufptr, "fLaC", 4)) return 0;\n<17> else                          return AVPROBE_SCORE_MAX / 2;
<1> TSReturnCode TSHttpTxnConfigFind ( const char * name , int length , TSOverridableConfigKey * conf , TSRecordDataType * type ) {\n<6> if ( length == - 1 ) {\n<7> length = strlen ( name ) ;\n<10> case 24 : if ( ! strncmp ( name , "proxy.config.srv_enabled" , length ) ) {\n<14> case 28 : if ( ! strncmp ( name , "proxy.config.http.cache.http" , length ) ) {\n<18> case 29 : if ( ! strncmp ( name , "proxy.config.ssl.hsts_max_age" , length ) ) {\n<22> case 31 : if ( ! strncmp ( name , "proxy.config.http.chunking.size" , length ) ) {\n<26> case 33 : if ( ! strncmp ( name , "proxy.config.http.cache.fuzz.time" , length ) ) {\n<34> case 34 : if ( ! strncmp ( name , "proxy.config.http.chunking_enabled" , length ) ) {\n<44> case 35 : switch ( name [ length - 1 ] ) {\n<45> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.range.write" , length ) ) {\n<49> case 'p' : if ( ! strncmp ( name , "proxy.config.http.normalize_ae_gzip" , length ) ) {\n<55> case 36 : switch ( name [ length - 1 ] ) {\n<56> case 'p' : if ( ! strncmp ( name , "proxy.config.http.cache.range.lookup" , length ) ) {\n<60> case 't' : if ( ! strncmp ( name , "proxy.config.net.sock_packet_tos_out" , length ) ) {\n<64> case 'd' : if ( ! strncmp ( name , "proxy.config.http.slow.log.threshold" , length ) ) {\n<70> case 37 : switch ( name [ length - 1 ] ) {\n<71> case 'd' : if ( ! strncmp ( name , "proxy.config.http.redirection_enabled" , length ) ) {\n<75> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.max_stale_age" , length ) ) {\n<89> case 'r' : if ( ! strncmp ( name , "proxy.config.http.response_server_str" , length ) ) {\n<97> case 't' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_post_out" , length ) ) {\n<112> case 38 : switch ( name [ length - 1 ] ) {\n<113> case 'd' : if ( ! strncmp ( name , "proxy.config.http.server_tcp_init_cwnd" , length ) ) {\n<121> case 's' : if ( ! strncmp ( name , "proxy.config.http.send_http11_requests" , length ) ) {\n<127> case 39 : switch ( name [ length - 1 ] ) {\n<128> case 'e' : if ( ! strncmp ( name , "proxy.config.body_factory.template_base" , length ) ) {\n<133> case 'm' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_from" , length ) ) {\n<137> case 'n' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_enabled_in" , length ) ) {\n<141> case 's' : if ( ! strncmp ( name , "proxy.config.http.doc_in_cache_skip_dns" , length ) ) {\n<147> case 40 : switch ( name [ length - 1 ] ) {\n<148> case 'd' : if ( ! strncmp ( name , "proxy.config.http.forward_connect_method" , length ) ) {\n<152> case 'e' : if ( ! strncmp ( name , "proxy.config.http.down_server.cache_time" , length ) ) {\n<159> case 'r' : if ( ! strncmp ( name , "proxy.config.url_remap.pristine_host_hdr" , length ) ) {\n<169> case 's' : if ( ! strncmp ( name , "proxy.config.http.origin_max_connections" , length ) ) {\n<182> case 't' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_enabled_out" , length ) ) {\n<186> case 'y' : if ( ! strncmp ( name , "proxy.config.http.cache.fuzz.probability" , length ) ) {\n<193> case 41 : switch ( name [ length - 1 ] ) {\n<194> case 'd' : if ( ! strncmp ( name , "proxy.config.http.response_server_enabled" , length ) ) {\n<198> case 'e' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_cookie" , length ) ) {\n<211> case 'r' : if ( ! strncmp ( name , "proxy.config.http.insert_response_via_str" , length ) ) {\n<220> case 42 : switch ( name [ length - 1 ] ) {\n<221> case 'd' : if ( ! strncmp ( name , "proxy.config.http.negative_caching_enabled" , length ) ) {\n<225> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.when_to_revalidate" , length ) ) {\n<232> case 'r' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_referer" , length ) ) {\n<240> case 't' : if ( ! strncmp ( name , "proxy.config.net.sock_recv_buffer_size_out" , length ) ) {\n<255> case 43 : switch ( name [ length - 1 ] ) {\n<256> case 'e' : if ( ! strncmp ( name , "proxy.config.http.negative_caching_lifetime" , length ) ) {\n<260> case 'k' : if ( ! strncmp ( name , "proxy.config.http.default_buffer_water_mark" , length ) ) {\n<264> case 'l' : if ( ! strncmp ( name , "proxy.config.http.cache.cluster_cache_local" , length ) ) {\n<268> case 'r' : if ( ! strncmp ( name , "proxy.config.http.cache.heuristic_lm_factor" , length ) ) {\n<275> case 44 : switch ( name [ length - 1 ] ) {\n<276> case 'p' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_client_ip" , length ) ) {\n<280> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.open_read_retry_time" , length ) ) {\n<286> case 45 : switch ( name [ length - 1 ] ) {\n<287> case 'd' : if ( ! strncmp ( name , "proxy.config.http.down_server.abort_threshold" , length ) ) {\n<294> case 'n' : if ( ! strncmp ( name , "proxy.config.http.cache.ignore_authentication" , length ) ) {\n<298> case 't' : if ( ! strncmp ( name , "proxy.config.http.anonymize_remove_user_agent" , length ) ) {\n<302> case 's' : if ( ! strncmp ( name , "proxy.config.http.connect_attempts_rr_retries" , length ) ) {\n<309> case 'e' : if ( 0 == strncmp ( name , "proxy.config.http.auth_server_session_private" , length ) ) {\n<313> case 'y' : if ( ! strncmp ( name , "proxy.config.http.redirect_use_orig_cache_key" , length ) ) {\n<319> case 46 : switch ( name [ length - 1 ] ) {\n<320> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.ignore_client_no_cache" , length ) ) {\n<339> case 'r' : if ( ! strncmp ( name , "proxy.config.http.insert_squid_x_forwarded_for" , length ) ) {\n<343> case 's' : if ( ! strncmp ( name , "proxy.config.http.connect_attempts_max_retries" , length ) ) {\n<350> case 't' : if ( ! strncmp ( name , "proxy.config.http.forward.proxy_auth_to_parent" , length ) ) {\n<354> case 'h' : if ( 0 == strncmp ( name , "proxy.config.http.server_session_sharing.match" , length ) ) {\n<358> case 'n' : if ( ! strncmp ( name , "proxy.config.http.cache.open_write_fail_action" , length ) ) {\n<364> case 47 : switch ( name [ length - 1 ] ) {\n<365> case 'b' : if ( ! strncmp ( name , "proxy.config.http.parent_proxy.mark_down_hostdb" , length ) ) {\n<369> case 'd' : if ( ! strncmp ( name , "proxy.config.http.negative_revalidating_enabled" , length ) ) {\n<373> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.guaranteed_min_lifetime" , length ) ) {\n<380> case 'n' : if ( ! strncmp ( name , "proxy.config.http.transaction_active_timeout_in" , length ) ) {\n<384> case 't' : if ( ! strncmp ( name , "proxy.config.http.post_connect_attempts_timeout" , length ) ) {\n<390> case 48 : switch ( name [ length - 1 ] ) {\n<391> case 'e' : if ( ! strncmp ( name , "proxy.config.http.cache.ignore_client_cc_max_age" , length ) ) {\n<399> case '_' : if ( ! strncmp ( name , "proxy.config.http.transaction_active_timeout_out" , length ) ) {\n<403> case 'e' : if ( ! strncmp ( name , "proxy.config.http.background_fill_active_timeout" , length ) ) {\n<411> case 49 : if ( ! strncmp ( name , "proxy.config.http.attach_server_session_to_client" , length ) ) {\n<415> case 50 : if ( ! strncmp ( name , "proxy.config.http.cache.cache_responses_to_cookies" , length ) ) {\n<419> case 51 : switch ( name [ length - 1 ] ) {\n<420> case 'n' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_no_activity_timeout_in" , length ) ) {\n<424> case 'd' : if ( ! strncmp ( name , "proxy.config.http.post.check.content_length.enabled" , length ) ) {\n<430> case 52 : switch ( name [ length - 1 ] ) {\n<431> case 'c' : if ( ! strncmp ( name , "proxy.config.http.cache.cache_urls_that_look_dynamic" , length ) ) {\n<435> case 'n' : if ( ! strncmp ( name , "proxy.config.http.transaction_no_activity_timeout_in" , length ) ) {\n<439> case 't' : if ( ! strncmp ( name , "proxy.config.http.keep_alive_no_activity_timeout_out" , length ) ) {\n<448> case 53 : switch ( name [ length - 1 ] ) {\n<449> case 't' : if ( ! strncmp ( name , "proxy.config.http.transaction_no_activity_timeout_out" , length ) ) {\n<453> case 'd' : if ( ! strncmp ( name , "proxy.config.http.background_fill_completed_threshold" , length ) ) {\n<458> case 's' : if ( ! strncmp ( name , "proxy.config.http.parent_proxy.total_connect_attempts" , length ) ) {\n<464> case 55 : if ( ! strncmp ( name , "proxy.config.http.parent_proxy.connect_attempts_timeout" , length ) ) {\n<468> case 58 : if ( ! strncmp ( name , "proxy.config.http.connect_attempts_max_retries_dead_server" , length ) ) {
<1> static int ftp_status(FTPContext *s, char **line, const int response_codes[])\n<37> av_log(s, AV_LOG_DEBUG, "%s\n", buf);\n<41> if (!pref_code_found) {\n<43> if (strlen(buf) < 3)\n<49> err = 0;\n<51> for (i = 0; i < 3; ++i) {\n<53> if (buf[i] < '0' || buf[i] > '9')\n<59> err += buf[i] - '0';\n<65> for (i = 0; response_codes[i]; ++i) {\n<79> *line = av_strdup(buf);
<1> static int decode_i_frame ( FourXContext * f , const uint8_t * buf , int length ) {\n<20> prestream = read_huffman_tables ( f , prestream ) ;\n<27> av_fast_malloc ( & f -> bitstream_buffer , & f -> bitstream_buffer_size , prestream_size + FF_INPUT_BUFFER_PADDING_SIZE ) ;\n<28> if ( ! f -> bitstream_buffer ) return AVERROR ( ENOMEM ) ;\n<29> f -> dsp . bswap_buf ( f -> bitstream_buffer , ( const uint32_t * ) prestream , prestream_size / 4 ) ;\n<30> memset ( ( uint8_t * ) f -> bitstream_buffer + prestream_size , 0 , FF_INPUT_BUFFER_PADDING_SIZE ) ;
<1> void do_exec ( struct st_command * command ) {\n<18> if ( builtin_echo [ 0 ] && strncmp ( cmd , "echo" , 4 ) == 0 ) {\n<19> replace ( & ds_cmd , "echo" , 4 , builtin_echo , strlen ( builtin_echo ) ) ;\n<25> if ( ! ( res_file = my_popen ( & ds_cmd , "r" ) ) ) {\n<35> while ( fgets ( buf , sizeof ( buf ) , res_file ) ) {\n<36> if ( disable_result_log ) {\n<37> buf [ strlen ( buf ) - 1 ] = 0 ;\n<38> DBUG_PRINT ( "exec_result" , ( "%s" , buf ) ) ;\n<41> replace_dynstr_append ( ds_result , buf ) ;\n<44> error = pclose ( res_file ) ;
<1> static int mpeg4_decode_partitioned_mb(MpegEncContext *s, DCTELEM block[6][64])\n<7> const int xy= s->mb_x + s->mb_y*s->mb_width;\n<81> if(mpeg4_decode_block(s, block[i], i, cbp&32, 1) < 0){\n<83> fprintf(stderr, "texture corrupted at %d %d\n", s->mb_x, s->mb_y);\n<115> if(mpeg4_decode_block(s, block[i], i, cbp&32, 0) < 0){\n<117> fprintf(stderr, "texture corrupted at %d %d (trying to continue with mc/dc only)\n", s->mb_x, s->mb_y);\n<143> if(mpeg4_decode_block(s, block[i], i, cbp&32, 1) < 0){\n<145> fprintf(stderr, "texture corrupted at %d %d (trying to continue with dc only)\n", s->mb_x, s->mb_y);
<1> static int rm_read_audio_stream_info(AVFormatContext *s, ByteIOContext *pb,\n<9> char buf[256];\n<21> if (((version >> 16) & 0xff) == 3) {\n<111> buf[0] = get_byte(pb);\n<113> buf[1] = get_byte(pb);\n<115> buf[2] = get_byte(pb);\n<117> buf[3] = get_byte(pb);\n<119> buf[4] = 0;\n<125> get_str8(pb, buf, sizeof(buf)); /* desc */\n<131> if (!strcmp(buf, "dnet")) {\n<133> st->codec->codec_id = CODEC_ID_AC3;\n<135> st->need_parsing = AVSTREAM_PARSE_FULL;\n<137> } else if (!strcmp(buf, "28_8")) {\n<139> st->codec->codec_id = CODEC_ID_RA_288;\n<141> st->codec->extradata_size= 0;\n<143> rm->audio_framesize = st->codec->block_align;\n<145> st->codec->block_align = coded_framesize;\n<149> if(rm->audio_framesize >= UINT_MAX / sub_packet_h){\n<161> } else if ((!strcmp(buf, "cook")) || (!strcmp(buf, "atrc")) || (!strcmp(buf, "sipr"))) {\n<165> get_be16(pb); get_byte(pb);\n<167> if (((version >> 16) & 0xff) == 5)\n<171> codecdata_length = get_be32(pb);\n<173> if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n<183> if(sub_packet_size <= 0){\n<193> if (!strcmp(buf, "cook")) st->codec->codec_id = CODEC_ID_COOK;\n<195> else if (!strcmp(buf, "sipr")) st->codec->codec_id = CODEC_ID_SIPR;\n<197> else st->codec->codec_id = CODEC_ID_ATRAC3;\n<225> } else if (!strcmp(buf, "raac") || !strcmp(buf, "racp")) {\n<229> get_be16(pb); get_byte(pb);\n<231> if (((version >> 16) & 0xff) == 5)\n<235> st->codec->codec_id = CODEC_ID_AAC;\n<237> codecdata_length = get_be32(pb);\n<239> if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n<263> st->codec->codec_id = CODEC_ID_NONE;\n<265> av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n<269> if (read_all) {\n<291> return 0;
<1> static int svq3_decode_mb(SVQ3Context *s, unsigned int mb_type)\n<5> H264Context *h = &s->h;\n<107> if (h->mb_x > 0 && h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - 1] + 6] != -1) {\n<123> if (h->mb_y > 0) {\n<129> 4 * 2 * sizeof(int16_t));\n<133> (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride]] == -1) ? PART_NOT_AVAILABLE : 1, 4);\n<145> (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride + 1] + 6] == -1 ||\n<147> h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride]] == -1) ? PART_NOT_AVAILABLE : 1;\n<161> (h->intra4x4_pred_mode[h->mb2br_xy[mb_xy - h->mb_stride - 1] + 3] == -1) ? PART_NOT_AVAILABLE : 1;\n<201> for (i = 0; i < 4; i++)\n<203> memset(h->cur_pic.motion_val[0][b_xy + i * h->b_stride],\n<205> 0, 4 * 2 * sizeof(int16_t));\n<217> for (i = 0; i < 4; i++)\n<219> memset(h->cur_pic.motion_val[1][b_xy + i * h->b_stride],\n<221> 0, 4 * 2 * sizeof(int16_t));\n<231> } else if (mb_type == 8 || mb_type == 33) {   /* INTRA4x4 */\n<233> memset(h->intra4x4_pred_mode_cache, -1, 8 * 5 * sizeof(int8_t));\n<289> left = &h->intra4x4_pred_mode_cache[scan8[i] - 1];\n<291> top  = &h->intra4x4_pred_mode_cache[scan8[i] - 8];\n<313> for (i = 0; i < 4; i++)\n<315> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8 * i], DC_PRED, 4);\n<321> write_back_intra_pred_mode(h);\n<327> ff_h264_check_intra4x4_pred_mode(h);\n<337> for (i = 0; i < 4; i++)\n<339> memset(&h->intra4x4_pred_mode_cache[scan8[0] + 8 * i], DC_128_PRED, 4);\n<361> if ((h->intra16x16_pred_mode = ff_h264_check_intra_pred_mode(h, dir, 0)) == -1) {\n<381> for (i = 0; i < 4; i++)\n<383> memset(h->cur_pic.motion_val[0][b_xy + i * h->b_stride],\n<385> 0, 4 * 2 * sizeof(int16_t));\n<389> for (i = 0; i < 4; i++)\n<391> memset(h->cur_pic.motion_val[1][b_xy + i * h->b_stride],\n<393> 0, 4 * 2 * sizeof(int16_t));\n<399> if (!IS_INTRA4x4(mb_type)) {\n<401> memset(h->intra4x4_pred_mode + h->mb2br_xy[mb_xy], DC_PRED, 8);\n<405> if (!IS_SKIP(mb_type) || h->pict_type == AV_PICTURE_TYPE_B) {\n<407> memset(h->non_zero_count_cache + 8, 0, 14 * 8 * sizeof(uint8_t));\n<569> h->chroma_pred_mode = ff_h264_check_intra_pred_mode(h, DC_PRED8x8, 1);
<1> static uint get_table_structure ( char * table , char * db , char * table_type , char * ignore_flag ) {\n<9> FILE * sql_file = md_result_file ;\n<16> * ignore_flag = check_if_ignore_table ( table , table_type ) ;\n<20> verbose_msg ( "-- Warning: Unable to use delayed inserts for table '%s' " "because it's of type %s\n" , table , table_type ) ;\n<35> result_table = quote_name ( table , table_buff , 1 ) ;\n<36> opt_quoted_table = quote_name ( table , table_buff2 , 0 ) ;\n<37> if ( opt_order_by_primary ) order_by = primary_key_fields ( result_table ) ;\n<39> if ( ! opt_no_create_info ) {\n<45> if ( ! ( sql_file = open_sql_file_for_table ( table , O_WRONLY ) ) ) DBUG_RETURN ( 0 ) ;\n<48> if ( strcmp ( table_type , "VIEW" ) == 0 ) print_comment ( sql_file , 0 , "\n--\n-- Temporary table structure for view %s\n--\n\n" , result_table ) ;\n<49> else print_comment ( sql_file , 0 , "\n--\n-- Table structure for table %s\n--\n\n" , result_table ) ;\n<55> field = mysql_fetch_field_direct ( result , 0 ) ;\n<56> if ( strcmp ( field -> name , "View" ) == 0 ) {\n<57> char * scv_buff = NULL ;\n<59> verbose_msg ( "-- It's a view, create dummy table for view\n" ) ;\n<60> if ( ( row = mysql_fetch_row ( result ) ) && ( scv_buff = row [ 1 ] ) ) scv_buff = my_strdup ( scv_buff , MYF ( 0 ) ) ;\n<61> mysql_free_result ( result ) ;\n<62> my_snprintf ( query_buff , sizeof ( query_buff ) , "SHOW FIELDS FROM %s" , result_table ) ;\n<63> if ( switch_character_set_results ( mysql , "binary" ) || mysql_query_with_error_report ( mysql , & result , query_buff ) || switch_character_set_results ( mysql , default_charset ) ) {\n<64> if ( mysql_errno ( mysql ) == ER_VIEW_INVALID ) fprintf ( sql_file , "\n-- failed on view %s: %s\n\n" , result_table , scv_buff ? scv_buff : "" ) ;\n<69> n_cols = mysql_num_rows ( result ) ;\n<70> if ( 0 != n_cols ) {\n<71> if ( n_cols >= 1000 ) fprintf ( stderr , "-- Warning: Creating a stand-in table for view %s may" " fail when replaying the dump file produced because " "of the number of columns exceeding 1000. Exercise " "caution when replaying the produced dump file.\n" , table ) ;\n<88> check_io ( sql_file ) ;\n<90> mysql_free_result ( result ) ;\n<91> if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n<92> seen_views = 1 ;\n<93> DBUG_RETURN ( 0 ) ;\n<96> is_log_table = general_log_or_slow_log_tables ( db , table ) ;\n<110> check_io ( sql_file ) ;\n<113> my_snprintf ( query_buff , sizeof ( query_buff ) , "show fields from %s" , result_table ) ;\n<145> verbose_msg ( "%s: Warning: Can't set SQL_QUOTE_SHOW_CREATE option (%s)\n" , my_progname_short , mysql_error ( mysql ) ) ;\n<153> print_comment ( sql_file , 0 , "\n--\n-- Table structure for table %s\n--\n\n" , result_table ) ;\n<158> check_io ( sql_file ) ;\n<165> dynstr_append_checked ( & insert_pat , result_table ) ;\n<172> while ( ( row = mysql_fetch_row ( result ) ) ) {\n<177> check_io ( sql_file ) ;\n<185> print_xml_row ( sql_file , "field" , result , & row , NullS ) ;\n<188> if ( opt_keywords ) fprintf ( sql_file , " %s.%s %s" , result_table , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n<189> else fprintf ( sql_file , " %s %s" , quote_name ( row [ SHOW_FIELDNAME ] , name_buff , 0 ) , row [ SHOW_TYPE ] ) ;\n<191> fputs ( " DEFAULT " , sql_file ) ;\n<192> unescape ( sql_file , row [ SHOW_DEFAULT ] , lengths [ SHOW_DEFAULT ] ) ;\n<194> if ( ! row [ SHOW_NULL ] [ 0 ] ) fputs ( " NOT NULL" , sql_file ) ;\n<195> if ( row [ SHOW_EXTRA ] [ 0 ] ) fprintf ( sql_file , " %s" , row [ SHOW_EXTRA ] ) ;\n<196> check_io ( sql_file ) ;\n<204> my_snprintf ( buff , sizeof ( buff ) , "show keys from %s" , result_table ) ;\n<205> if ( mysql_query_with_error_report ( mysql , & result , buff ) ) {\n<210> fprintf ( stderr , "%s: Can't get keys for table %s (%s)\n" , my_progname_short , result_table , mysql_error ( mysql ) ) ;\n<211> if ( path ) my_fclose ( sql_file , MYF ( MY_WME ) ) ;\n<228> while ( ( row = mysql_fetch_row ( result ) ) ) {\n<230> print_xml_row ( sql_file , "key" , result , & row , NullS ) ;\n<234> if ( keynr ++ ) putc ( ')' , sql_file ) ;\n<235> if ( atoi ( row [ 1 ] ) ) fprintf ( sql_file , ",\n KEY %s (" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n<236> else if ( keynr == primary_key ) fputs ( ",\n PRIMARY KEY (" , sql_file ) ;\n<237> else fprintf ( sql_file , ",\n UNIQUE %s (" , quote_name ( row [ 2 ] , name_buff , 0 ) ) ;\n<240> fputs ( quote_name ( row [ 4 ] , name_buff , 0 ) , sql_file ) ;\n<241> if ( row [ 7 ] ) fprintf ( sql_file , " (%s)" , row [ 7 ] ) ;\n<242> check_io ( sql_file ) ;\n<255> verbose_msg ( "-- Warning: Couldn't get status information for " "table %s (%s)\n" , result_table , mysql_error ( mysql ) ) ;\n<258> else if ( ! ( row = mysql_fetch_row ( result ) ) ) {\n<259> fprintf ( stderr , "Error: Couldn't read status information for table %s (%s)\n" , result_table , mysql_error ( mysql ) ) ;\n<262> if ( opt_xml ) print_xml_row ( sql_file , "options" , result , & row , NullS ) ;\n<265> print_value ( sql_file , result , row , "engine=" , "Engine" , 0 ) ;\n<266> print_value ( sql_file , result , row , "" , "Create_options" , 0 ) ;\n<267> print_value ( sql_file , result , row , "comment=" , "Comment" , 1 ) ;
<1> int avpicture_layout(const AVPicture* src, enum AVPixelFormat pix_fmt,\n<5> unsigned char *dest, int dest_size)\n<33> av_image_fill_linesizes(linesizes, pix_fmt, width);\n<39> const unsigned char *s = src->data[i];\n<45> for (j = 0; j < h; j++) {\n<47> memcpy(dest, s, linesizes[i]);\n<49> dest += linesizes[i];\n<51> s += src->linesize[i];\n<59> if (desc->flags & AV_PIX_FMT_FLAG_PAL)\n<61> memcpy((unsigned char *)(((size_t)dest + 3) & ~3),\n<63> src->data[1], 256 * 4);
<1> int ff_dxva2_commit_buffer(AVCodecContext *avctx,\n<7> unsigned type, const void *data, unsigned size,\n<57> if (size <= dxva_size) {\n<59> memcpy(dxva_data, data, size);
<37> dinfo = drive_get_by_blockdev(blk->conf.bs);\n<39> if (*dinfo->serial) {\n<41> blk->serial = strdup(dinfo->serial);\n<67> s->blk = blk;
<1> int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)\n<13> if (!ff_thread_can_start_frame(avctx)) {\n<247> if (ff_alloc_picture(s, s->last_picture_ptr, 0) < 0) {\n<259> avctx->height * s->last_picture_ptr->f.linesize[0]);\n<277> for(i=0; i<avctx->height; i++)\n<279> memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);
<1> static int spapr_phb_init(SysBusDevice *s)\n<5> sPAPRPHBState *sphb = SPAPR_PCI_HOST_BRIDGE(s);\n<19> namebuf = alloca(strlen(sphb->dtbusname) + 32);\n<25> sprintf(namebuf, "%s.mmio", sphb->dtbusname);\n<27> memory_region_init(&sphb->memspace, namebuf, INT64_MAX);\n<31> sprintf(namebuf, "%s.mmio-alias", sphb->dtbusname);\n<33> memory_region_init_alias(&sphb->memwindow, namebuf, &sphb->memspace,\n<59> sprintf(namebuf, "%s.io", sphb->dtbusname);\n<61> memory_region_init(&sphb->iospace, namebuf, SPAPR_PCI_IO_WIN_SIZE);\n<69> sprintf(namebuf, "%s.io-alias", sphb->dtbusname);\n<71> memory_region_init_io(&sphb->iowindow, &spapr_io_ops, sphb,\n<87> if (msi_supported) {\n<89> sprintf(namebuf, "%s.msi", sphb->dtbusname);\n<91> memory_region_init_io(&sphb->msiwindow, &spapr_msi_ops, sphb,\n<105> sphb->busname ? sphb->busname : sphb->dtbusname,\n<125> pci_setup_iommu(bus, spapr_pci_dma_context_fn, sphb);\n<129> QLIST_INSERT_HEAD(&spapr->phbs, sphb, list);
<1> static int smacker_read_packet(AVFormatContext *s, AVPacket *pkt)\n<5> SmackerContext *smk = s->priv_data;\n<37> if(flags & SMACKER_PAL){\n<41> uint8_t *pal = smk->pal;\n<43> uint8_t oldpal[768];\n<47> memcpy(oldpal, pal, 768);\n<69> pal += ((t & 0x7F) + 1) * 3;\n<93> *pal++ = oldpal[off + 0];\n<95> *pal++ = oldpal[off + 1];\n<97> *pal++ = oldpal[off + 2];\n<107> *pal++ = smk_pal[t];\n<177> if (av_new_packet(pkt, frame_size + 769))\n<185> pkt->data[0] = palchange;\n<187> memcpy(pkt->data + 1, smk->pal, 768);\n<207> if (av_new_packet(pkt, smk->buf_sizes[smk->curstream]))\n<211> memcpy(pkt->data, smk->bufs[smk->curstream], smk->buf_sizes[smk->curstream]);\n<213> pkt->size = smk->buf_sizes[smk->curstream];\n<219> smk->aud_pts[smk->curstream] += AV_RL32(pkt->data);
<1> static unsigned int dec_move_rs(DisasContext *dc)\n<5> DIS(fprintf (logfile, "move $r%u, $s%u\n", dc->op1, dc->op2));\n<7> cris_cc_mask(dc, 0);\n<11> tcg_const_tl(dc->op2), tcg_const_tl(dc->op1));
<1> static void end_frame(AVFilterLink *link)\n<27> find_motion(deshake, (deshake->ref == NULL) ? in->data[0] : deshake->ref->data[0], in->data[0], link->w, link->h, in->linesize[0], &t);\n<61> find_motion(deshake, src1, src2, deshake->cw, deshake->ch, in->linesize[0], &t);\n<119> if (deshake->fp) {\n<121> snprintf(tmp, 256, "%f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f, %f\n", orig.vector.x, deshake->avg.vector.x, t.vector.x, orig.vector.y, deshake->avg.vector.y, t.vector.y, orig.angle, deshake->avg.angle, t.angle, orig.zoom, deshake->avg.zoom, t.zoom);\n<123> fwrite(tmp, sizeof(char), strlen(tmp), deshake->fp);
<1> static void netfilter_set_status(Object *obj, const char *str, Error **errp)\n<5> NetFilterState *nf = NETFILTER(obj);\n<11> if (strcmp(str, "on") && strcmp(str, "off")) {\n<13> error_setg(errp, "Invalid value for netfilter status, "\n<17> return;\n<21> if (nf->on == !strcmp(str, "on")) {\n<23> return;\n<27> nf->on = !nf->on;\n<29> if (nfc->status_changed) {
<1> int css_register_io_adapter(CssIoAdapterType type, uint8_t isc, bool swap,\n<51> ret = fsc->register_io_adapter(fs, *id, isc, swap, maskable);\n<53> if (ret == 0) {\n<67> fprintf(stderr, "Unexpected error %d when registering adapter %d\n",\n<75> return ret;
<1> static void *circular_buffer_task( void *_URLContext)\n<7> UDPContext *s = h->priv_data;\n<15> ff_socket_nonblock(s->udp_fd, 0);\n<41> len = recv(s->udp_fd, s->tmp+4, sizeof(s->tmp)-4, 0);\n<45> if (len < 0) {\n<47> if (ff_neterrno() != AVERROR(EAGAIN) && ff_neterrno() != AVERROR(EINTR)) {\n<59> AV_WL32(s->tmp, len);\n<61> if(left < len + 4) {\n<65> if (s->overrun_nonfatal) {\n<91> av_fifo_generic_write(s->fifo, s->tmp, len+4, NULL);
<1> static int get_sot(Jpeg2000DecoderContext *s, int n)\n<81> if (!TPsot) {\n<83> Jpeg2000Tile *tile = s->tile + s->curtileno;\n<89> memcpy(tile->codsty, s->codsty, s->ncomponents * sizeof(Jpeg2000CodingStyle));\n<91> memcpy(tile->qntsty, s->qntsty, s->ncomponents * sizeof(Jpeg2000QuantStyle));
<1> int avfilter_parse_graph(AVFilterGraph *graph, const char *filters,\n<3> AVFilterInOut *open_inputs,\n<57> if(link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx) < 0)\n<63> if(parse_outputs(&filters, &curr_inputs, &open_inputs, &open_outputs,\n<77> if(chr == ';' && curr_inputs) {\n<95> if (*filters) {\n<109> if(open_inputs && !strcmp(open_inputs->name, "out") && curr_inputs) {\n<113> const char *tmp = "[out]";\n<115> if(parse_outputs(&tmp, &curr_inputs, &open_inputs,\n<117> &open_outputs, log_ctx) < 0)\n<125> return 0;\n<133> free_inout(open_inputs);\n<137> free_inout(curr_inputs);
<7> static int raw_decode(AVCodecContext *avctx, void *data, int *got_frame,\n<17> const uint8_t *buf             = avpkt->data;\n<19> int buf_size                   = avpkt->size;\n<175> frame->buf[0] = av_buffer_alloc(FFMAX(context->frame_size, buf_size));\n<357> } else if (need_copy) {\n<359> memcpy(frame->buf[0]->data, buf, buf_size);\n<361> buf = frame->buf[0]->data;\n<371> buf += buf_size - context->frame_size;\n<377> if (buf_size < len && ((avctx->codec_tag & 0xFFFFFF) != MKTAG('B','I','T', 0) || !need_copy)) {\n<381> av_buffer_unref(&frame->buf[0]);\n<395> av_buffer_unref(&frame->buf[0]);\n<405> const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE,\n<413> context->palette = av_buffer_alloc(AVPALETTE_SIZE);\n<417> av_buffer_unref(&frame->buf[0]);\n<427> av_buffer_unref(&frame->buf[0]);\n<435> if (pal) {\n<437> memcpy(context->palette->data, pal, AVPALETTE_SIZE);\n<445> int pal_size = avpkt->size - vid_size;\n<449> if (avpkt->size > vid_size && pal_size <= AVPALETTE_SIZE) {\n<451> pal = avpkt->data + vid_size;\n<453> memcpy(context->palette->data, pal, pal_size);\n<511> frame->buf[1]  = av_buffer_ref(context->palette);\n<515> av_buffer_unref(&frame->buf[0]);
<1> PGconn * GetConnection ( void ) {\n<11> char * err_msg = NULL ;\n<14> conn_opts = PQconninfoParse ( connection_string , & err_msg ) ;\n<15> if ( conn_opts == NULL ) {\n<16> fprintf ( stderr , "%s: %s" , progname , err_msg ) ;\n<47> values [ i ] = progname ;\n<64> need_password = ( dbgetpassword == 1 && dbpassword == NULL ) ;\n<67> if ( dbpassword ) free ( dbpassword ) ;\n<68> dbpassword = simple_prompt ( _ ( "Password: " ) , 100 , false ) ;\n<72> keywords [ i ] = "password" ;\n<73> values [ i ] = dbpassword ;\n<76> keywords [ i ] = NULL ;\n<77> values [ i ] = NULL ;\n<79> tmpconn = PQconnectdbParams ( keywords , values , true ) ;\n<80> if ( ! tmpconn ) {\n<81> fprintf ( stderr , _ ( "%s: could not connect to server\n" ) , progname ) ;\n<90> if ( PQstatus ( tmpconn ) != CONNECTION_OK ) {\n<91> fprintf ( stderr , _ ( "%s: could not connect to server: %s" ) , progname , PQerrorMessage ( tmpconn ) ) ;\n<93> free ( values ) ;\n<94> free ( keywords ) ;\n<98> free ( values ) ;\n<99> free ( keywords ) ;
<1> static int ass_split(ASSSplitContext *ctx, const char *buf)\n<5> char c, section[16];\n<17> while (buf && *buf) {\n<19> if (sscanf(buf, "[%15[0-9A-Za-z+ ]]%c", section, &c) == 2) {\n<21> buf += strcspn(buf, "\n") + 1;\n<23> for (i=0; i<FF_ARRAY_ELEMS(ass_sections); i++)\n<25> if (!strcmp(section, ass_sections[i].section)) {\n<27> ctx->current_section = i;\n<29> buf = ass_split_section(ctx, buf);\n<35> buf += strcspn(buf, "\n") + 1;
<1> static int mss2_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n<13> MSS12Context *c  = &ctx->c;\n<237> if ((i = decode_pal_v2(c, buf, buf_size)) < 0)\n<391> } else if (!implicit_rect || wmv9_mask != -1) {\n<447> memset(c->pal_pic, 0, c->pal_stride * avctx->height);\n<485> uint8_t *dst = c->rgb_pic + y * c->rgb_stride + x * 3;\n<487> if (wmv9_mask != -1) {\n<489> ctx->dsp.mss2_gray_fill_masked(dst, c->rgb_stride,\n<493> c->pal_pic + y * c->pal_stride + x,\n<503> memset(dst, 0x80, w * 3);\n<505> dst += c->rgb_stride;\n<507> } while (--h);
<1> void qemu_put_buffer(QEMUFile *f, const uint8_t *buf, int size)\n<7> while (size > 0) {\n<9> l = IO_BUF_SIZE - f->buf_index;\n<11> if (l > size)\n<13> l = size;\n<15> memcpy(f->buf + f->buf_index, buf, l);\n<17> f->buf_index += l;\n<19> buf += l;\n<21> size -= l;
<1> static int parse_adaptation_sets(AVFormatContext *s)\n<5> WebMDashMuxContext *w = s->priv_data;\n<7> char *p = w->adaptation_sets;\n<17> while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n<19> if (*p == ' ')\n<23> else if (state == new_set && !strncmp(p, "id=", 3)) {\n<27> if (w->as == NULL) return -1;\n<33> p += 3; // consume "id="\n<37> while (*p != ',') *q++ = *p++;\n<41> p++;\n<45> } else if (state == parsed_id && !strncmp(p, "streams=", 8)) {\n<47> p += 8; // consume "streams="\n<55> q = p;\n<63> as->streams[as->nb_streams - 1] = to_integer(p, q - p);\n<67> if (*q == '\0') break;\n<71> p = ++q;\n<81> return 0;
<1> PXA2xxState *pxa270_init(unsigned int sdram_size, const char *revision)\n<15> if (revision && strncmp(revision, "pxa27", 5)) {\n<17> fprintf(stderr, "Machine requires a PXA27x processor.\n");\n<31> if (!s->env) {\n<33> fprintf(stderr, "Unable to find CPU definition\n");\n<79> if (!dinfo) {\n<81> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> build_rsdp(GArray *rsdp_table, BIOSLinker *linker, unsigned rsdt)\n<5> AcpiRsdpDescriptor *rsdp = acpi_data_push(rsdp_table, sizeof *rsdp);\n<15> memcpy(&rsdp->signature, "RSD PTR ", 8);\n<17> memcpy(rsdp->oem_id, ACPI_BUILD_APPNAME6, 6);\n<35> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
<1> static int dissect_dns_answer ( tvbuff_t * tvb , int offsetx , int dns_data_offset , column_info * cinfo , proto_tree * dns_tree , packet_info * pinfo , gboolean is_mdns ) {\n<19> len = get_dns_name_type_class ( tvb , offsetx , dns_data_offset , & name , & name_len , & dns_type , & dns_class ) ;\n<42> if ( dns_tree != NULL ) {\n<43> name_out = format_text ( name , strlen ( name ) ) ;\n<45> rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , "%s: type %s, class %s" , name_out , type_name , class_name ) ;\n<46> add_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , dns_type , pinfo , is_mdns ) ;\n<49> rr_tree = proto_tree_add_subtree_format ( dns_tree , tvb , offsetx , ( data_offset - data_start ) + data_len , ett_dns_rr , & trr , "%s: type %s" , name_out , type_name ) ;\n<50> add_opt_rr_to_tree ( rr_tree , tvb , offsetx , name , name_len , is_mdns ) ;\n<59> switch ( dns_type ) {\n<78> ns_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & ns_name ) ;\n<79> name_out = format_text ( ns_name , strlen ( ns_name ) ) ;\n<81> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<83> proto_item_append_text ( trr , ", ns %s" , name_out ) ;\n<110> cname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & cname ) ;\n<111> name_out = format_text ( cname , strlen ( cname ) ) ;\n<113> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<115> proto_item_append_text ( trr , ", cname %s" , name_out ) ;\n<125> mname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & mname ) ;\n<126> name_out = format_text ( mname , strlen ( mname ) ) ;\n<128> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<130> proto_item_append_text ( trr , ", mname %s" , name_out ) ;\n<133> rname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & rname ) ;\n<134> name_out = format_text ( rname , strlen ( rname ) ) ;\n<135> proto_tree_add_string ( rr_tree , hf_dns_soa_rname , tvb , cur_offset , rname_len , name_out ) ;\n<250> pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n<251> name_out = format_text ( pname , strlen ( pname ) ) ;\n<253> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<255> proto_item_append_text ( trr , ", %s" , name_out ) ;\n<303> mx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & mx_name ) ;\n<304> name_out = format_text ( mx_name , strlen ( mx_name ) ) ;\n<306> col_append_fstr ( cinfo , COL_INFO , " %u %s" , preference , name_out ) ;\n<308> proto_item_append_text ( trr , ", preference %u, mx %s" , preference , name_out ) ;\n<538> next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n<539> name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n<565> target_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & target ) ;\n<566> name_out = format_text ( target , strlen ( target ) ) ;\n<567> proto_tree_add_string ( rr_tree , hf_dns_srv_target , tvb , cur_offset , target_len , name_out ) ;\n<607> replacement_len = get_dns_name ( tvb , offset , 0 , dns_data_offset , & replacement ) ;\n<608> name_out = format_text ( replacement , strlen ( replacement ) ) ;\n<611> proto_tree_add_string ( rr_tree , hf_dns_naptr_replacement , tvb , offset , replacement_len , name_out ) ;\n<621> kx_name_len = get_dns_name ( tvb , cur_offset + 2 , 0 , dns_data_offset , & kx_name ) ;\n<622> name_out = format_text ( kx_name , strlen ( kx_name ) ) ;\n<624> col_append_fstr ( cinfo , COL_INFO , " %u %s" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n<626> proto_item_append_text ( trr , ", preference %u, kx %s" , tvb_get_ntohs ( tvb , cur_offset ) , name_out ) ;\n<674> pname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & pname ) ;\n<677> pname = "" ;\n<680> name_out = format_text ( pname , strlen ( pname ) ) ;\n<683> col_append_fstr ( cinfo , COL_INFO , " %d %s %s" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n<692> proto_tree_add_string ( rr_tree , hf_dns_a6_prefix_name , tvb , a6_offset , pname_len , name_out ) ;\n<694> proto_item_append_text ( trr , ", addr %d %s %s" , pre_len , address_to_str ( wmem_packet_scope ( ) , & suffix_addr ) , name_out ) ;\n<700> dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n<701> name_out = format_text ( dname , strlen ( dname ) ) ;\n<703> col_append_fstr ( cinfo , COL_INFO , " %s" , name_out ) ;\n<705> proto_item_append_text ( trr , ", dname %s" , name_out ) ;\n<933> next_domain_name_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & next_domain_name ) ;\n<934> name_out = format_text ( next_domain_name , strlen ( next_domain_name ) ) ;\n<1288> dname_len = get_dns_name ( tvb , cur_offset , 0 , dns_data_offset , & dname ) ;\n<1289> name_out = format_text ( dname , strlen ( dname ) ) ;\n<1290> proto_tree_add_string ( rr_tree , hf_dns_winsr_name_result_domain , tvb , cur_offset , dname_len , name_out ) ;
<1> static uint dump_routines_for_db ( char * db ) {\n<15> DBUG_PRINT ( "enter" , ( "db: '%s'" , db ) ) ;\n<16> mysql_real_escape_string ( mysql , db_name_buff , db , ( ulong ) strlen ( db ) ) ;\n<17> print_comment ( sql_file , 0 , "\n--\n-- Dumping routines for database '%s'\n--\n" , db ) ;\n<21> if ( opt_xml ) fputs ( "\t<routines>\n" , sql_file ) ;\n<33> while ( ( row = mysql_fetch_row ( routine_res ) ) ) {\n<34> DBUG_PRINT ( "info" , ( "length of body for %s row[2] '%s' is %zu" , routine_name , row [ 2 ] ? row [ 2 ] : "(null)" , row [ 2 ] ? strlen ( row [ 2 ] ) : 0 ) ) ;\n<35> if ( row [ 2 ] == NULL ) {\n<36> print_comment ( sql_file , 1 , "\n-- insufficient privileges to %s\n" , query_buff ) ;\n<37> print_comment ( sql_file , 1 , "-- does %s have permissions on mysql.proc?\n\n" , current_user ) ;\n<40> else if ( strlen ( row [ 2 ] ) ) {\n<41> if ( opt_xml ) {\n<42> if ( i ) print_xml_row ( sql_file , "routine" , routine_res , & row , "Create Procedure" ) ;\n<43> else print_xml_row ( sql_file , "routine" , routine_res , & row , "Create Function" ) ;\n<57> fprintf ( sql_file , "--\n" "-- WARNING: old server version. " "The following dump may be incomplete.\n" "--\n" ) ;\n<63> \n" "%s ;
<1> static void ps2_common_post_load ( PS2State * s ) {\n<2> PS2Queue * q = & s -> queue ;\n<5> int tmp_data [ PS2_QUEUE_SIZE ] ;\n<7> if ( size > 0 ) {\n<9> i < size ;\n<11> tmp_data [ i ] = q -> data [ q -> rptr ] ;\n<16> memcpy ( q -> data , tmp_data , size ) ;\n<19> q -> wptr = size ;\n<20> q -> count = size ;
<1> static int svq1_decode_frame(AVCodecContext *avctx, void *data,\n<105> if (!pmv)\n<177> if (!previous) {\n<189> memset(pmv, 0, ((width / 8) + 3) * sizeof(svq1_pmv));\n<255> av_free(pmv);
<1> static inline void tcg_out_ldst(TCGContext *s, int ret, int addr, int offset, int op)\n<5> if (offset == (offset & 0xfff))\n<13> fprintf(stderr, "unimplemented %s with offset %d\n", __func__, offset);
<1> int css_do_tsch_get_irb(SubchDev *sch, IRB *target_irb, int *irb_len)\n<5> SCSW *s = &sch->curr_status.scsw;\n<15> if (!(p->flags & (PMCW_FLAGS_MASK_DNV | PMCW_FLAGS_MASK_ENA))) {\n<23> stctl = s->ctrl & SCSW_CTRL_MASK_STCTL;\n<29> memset(&irb, 0, sizeof(IRB));\n<35> memcpy(&irb.scsw, s, sizeof(SCSW));\n<57> if ((s->dstat & SCSW_DSTAT_UNIT_CHECK) &&\n<69> memcpy(irb.ecw, sch->sense_data, sizeof(sch->sense_data));\n<71> for (i = 0; i < ARRAY_SIZE(irb.ecw); i++) {\n<85> copy_irb_to_guest(target_irb, &irb, p, irb_len);
<1> static int bochs_open(BlockDriverState *bs, const char *filename, int flags)\n<37> if (read(fd, &bochs, sizeof(bochs)) != sizeof(bochs)) {\n<45> if (strcmp(bochs.magic, HEADER_MAGIC) ||\n<47> strcmp(bochs.type, REDOLOG_TYPE) ||\n<49> strcmp(bochs.subtype, GROWING_TYPE) ||\n<51> ((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n<61> if (le32_to_cpu(bochs.version) == HEADER_V1) {\n<63> memcpy(&header_v1, &bochs, sizeof(bochs));\n<75> lseek(s->fd, le32_to_cpu(bochs.header), SEEK_SET);\n<79> s->catalog_size = le32_to_cpu(bochs.extra.redolog.catalog);\n<81> s->catalog_bitmap = qemu_malloc(s->catalog_size * 4);\n<83> if (read(s->fd, s->catalog_bitmap, s->catalog_size * 4) !=\n<85> s->catalog_size * 4)\n<113> close(fd);\n<115> return -1;
<1> static void sun4m_hw_init(const struct hwdef *hwdef, int ram_size,\n<27> if (def == NULL) {\n<29> fprintf(stderr, "Unable to find Sparc CPU definition\n");\n<103> if (graphic_depth != 8 && graphic_depth != 24) {\n<105> fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth);\n<111> tcx_init(ds, hwdef->tcx_base, phys_ram_base + ram_size, ram_size,\n<117> if (nd_table[0].model == NULL\n<119> || strcmp(nd_table[0].model, "lance") == 0) {\n<121> lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq);\n<123> } else if (strcmp(nd_table[0].model, "?") == 0) {\n<125> fprintf(stderr, "qemu: Supported NICs: lance\n");\n<127> exit (1);\n<131> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);\n<133> exit (1);
<1> int ff_h2645_packet_split(H2645Packet *pkt, const uint8_t *buf, int length,\n<123> if (pkt->nals_allocated < pkt->nb_nals + 1) {\n<129> if (!tmp)\n<135> pkt->nals = tmp;\n<139> (new_size - pkt->nals_allocated) * sizeof(*tmp));
<1> static int qcow_create2(const char *filename, int64_t total_size,\n<3> const char *backing_file, const char *backing_format,\n<19> QCowCreateState s1, *s = &s1;\n<27> memset(s, 0, sizeof(*s));\n<33> if (fd < 0)\n<37> memset(&header, 0, sizeof(header));\n<49> if (backing_file) {\n<51> if (backing_format) {\n<55> backing_format_len = strlen(backing_format);\n<57> ext_bf.len = (backing_format_len + 7) & ~7;\n<65> backing_filename_len = strlen(backing_file);\n<67> header.backing_file_size = cpu_to_be32(backing_filename_len);\n<75> s->cluster_size = 1 << s->cluster_bits;\n<77> header.cluster_bits = cpu_to_be32(s->cluster_bits);\n<91> l2_bits = s->cluster_bits - 3;\n<93> shift = s->cluster_bits + l2_bits;\n<97> offset = align_offset(header_size, s->cluster_size);\n<101> header.l1_table_offset = cpu_to_be64(s->l1_table_offset);\n<105> offset += align_offset(l1_size * sizeof(uint64_t), s->cluster_size);\n<109> s->refcount_table = qemu_mallocz(s->cluster_size);\n<111> s->refcount_block = qemu_mallocz(s->cluster_size);\n<121> offset += s->cluster_size;\n<129> offset += s->cluster_size;\n<135> create_refcount_update(s, 0, header_size);\n<137> create_refcount_update(s, s->l1_table_offset, l1_size * sizeof(uint64_t));\n<139> create_refcount_update(s, s->refcount_table_offset, s->cluster_size);\n<141> create_refcount_update(s, s->refcount_block_offset, s->cluster_size);\n<147> write(fd, &header, sizeof(header));\n<151> if (backing_format_len) {\n<155> int d = ext_bf.len - backing_format_len;\n<159> memset(zero, 0, sizeof(zero));\n<167> write(fd, backing_format, backing_format_len);\n<171> write(fd, zero, d);\n<177> write(fd, backing_file, backing_filename_len);
<1> void * jas_malloc ( size_t size ) {\n<3> JAS_DBGLOG ( 101 , ( "jas_malloc called with %zu\n" , size ) ) ;\n<4> result = malloc ( size ) ;\n<5> JAS_DBGLOG ( 100 , ( "jas_malloc(%zu) -> %p\n" , size , result ) ) ;
<1> static void mdct512(AC3MDCTContext *mdct, int32_t *out, int16_t *in)\n<7> int16_t *rot = mdct->rot_tmp;\n<27> memcpy(&rot[n4], &in[0], 3*n4*sizeof(*in));
<1> static void test_qemu_strtoul_overflow(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoul(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n<77> block_time = (data[0] << 8) | data[1];\n<85> data += 1;\n<123> data += 1;\n<155> data += 1;\n<191> n = matroska_ebmlnum_uint(data, size, &num);\n<203> data += n;\n<215> r = matroska_ebmlnum_sint (data, size, &snum);\n<227> data += r;\n<265> slices = *data++ + 1;\n<289> slice_offset = rv_offset(data, slice, slices);\n<293> slice_size = lace_size[n] - slice_offset;\n<297> slice_size = rv_offset(data, slice+1, slices) - slice_offset;\n<301> if (ppkt)  *ppkt = pkt;\n<305> if (av_new_packet(pkt, slice_size) < 0) {\n<315> memcpy (pkt->data, data+slice_offset, slice_size);\n<335> matroska_queue_packet_reordered(matroska, pkt, is_bframe);\n<339> matroska_queue_packet(matroska, pkt);\n<343> data += lace_size[n];
<1> static int rle_unpack(unsigned char *src, unsigned char *dest, int len)\n<15> pd = dest;\n<19> *pd++ = *ps++;\n<29> l = *ps++;\n<31> if (l & 0x80) {\n<33> l = (l & 0x7F) * 2;\n<35> memcpy(pd, ps, l);\n<37> ps += l;\n<39> pd += l;\n<47> *pd++ = ps[1];\n<55> i += l;
<1> static int tight_init_stream(VncState *vs, int stream_id,\n<33> if (err != Z_OK) {\n<35> fprintf(stderr, "VNC: error initializing zlib\n");
<1> static void test_rfc2231_parser ( void ) {\n<2> const char * input = ";\n<18> rfc822_parser_init ( & parser , ( const void * ) input , strlen ( input ) , NULL ) ;\n<21> output [ i ] != NULL && result [ i ] != NULL ;\n<22> i ++ ) test_assert ( strcmp ( output [ i ] , result [ i ] ) == 0 ) ;\n<23> test_assert ( output [ i ] == NULL && result [ i ] == NULL ) ;
<1> sorecvfrom(struct socket *so)\n<7> socklen_t addrlen = sizeof(struct sockaddr_storage);\n<13> DEBUG_ARG("so = %p", so);\n<17> if (so->so_type == IPPROTO_ICMP) {   /* This is a "ping" reply */\n<19> char buff[256];\n<33> if(len == -1 || len == 0) {\n<39> if(errno == EHOSTUNREACH) code=ICMP_UNREACH_HOST;\n<41> else if(errno == ENETUNREACH) code=ICMP_UNREACH_NET;\n<47> errno,strerror(errno)));\n<49> icmp_error(so->so_m, ICMP_UNREACH,code, 0,strerror(errno));\n<61> udp_detach(so);\n<83> if (!m) {\n<89> m->m_data += IF_MAXLINKHDR;\n<101> len = M_FREEROOM(m);\n<105> ioctlsocket(so->s, FIONREAD, &n);\n<109> if (n > len) {\n<111> n = (m->m_data - m->m_dat) + m->m_len + n + 1;\n<115> len = M_FREEROOM(m);\n<127> DEBUG_MISC((dfd, " did recvfrom %d, errno = %d-%s\n",\n<129> m->m_len, errno,strerror(errno)));\n<131> if(m->m_len<0) {\n<137> if(errno == EHOSTUNREACH) code=ICMP_UNREACH_HOST;\n<139> else if(errno == ENETUNREACH) code=ICMP_UNREACH_NET;\n<143> DEBUG_MISC((dfd," rx error, tx icmp ICMP_UNREACH:%i\n", code));\n<145> icmp_error(so->so_m, ICMP_UNREACH,code, 0,strerror(errno));\n<147> m_free(m);\n<189> udp_output(so, m, (struct sockaddr_in *) &addr);
<1> int av_image_fill_pointers(uint8_t *data[4], enum PixelFormat pix_fmt, int height,\n<13> memset(data     , 0, sizeof(data[0])*4);\n<15> memset(size     , 0, sizeof(size));\n<17> memset(has_plane, 0, sizeof(has_plane));\n<35> size[0] = (size[0] + 3) & ~3;\n<37> data[1] = ptr + size[0]; /* palette is stored here as 256 32 bits words */\n<39> return size[0] + 256 * 4;\n<51> total_size = size[0];\n<53> for (i = 1; has_plane[i] && i < 4; i++) {\n<57> data[i] = data[i-1] + size[i-1];\n<63> total_size += size[i];
<1> static void onenand_reset(OneNANDState *s, int cold)\n<5> memset(&s->addr, 0, sizeof(s->addr));\n<17> onenand_intr_update(s);\n<43> if (cold) {\n<47> memset(s->blockwp, ONEN_LOCK_LOCKED, s->blocks);
<1> static unsigned int dec_adds_r(DisasContext *dc)\n<7> int size = memsize_z(dc);\n<11> memsize_char(size),\n<17> cris_cc_mask(dc, CC_MASK_NZVC);
<1> qcrypto_block_luks_open(QCryptoBlock *block,\n<95> if (rv < 0) {\n<133> if (memcmp(luks->header.magic, qcrypto_block_luks_magic,\n<137> error_setg(errp, "Volume is not in LUKS format");\n<139> ret = -EINVAL;\n<145> if (luks->header.version != QCRYPTO_BLOCK_LUKS_VERSION) {\n<175> ivgen_name = strchr(luks->header.cipher_mode, '-');\n<177> if (!ivgen_name) {\n<181> error_setg(errp, "Unexpected cipher mode string format %s",\n<189> *ivgen_name = '\0';\n<191> ivgen_name++;\n<195> ivhash_name = strchr(ivgen_name, ':');\n<197> if (!ivhash_name) {\n<227> ciphermode = qcrypto_block_luks_cipher_mode_lookup(luks->header.cipher_mode,\n<279> ivalg = qcrypto_block_luks_ivgen_name_lookup(ivgen_name,\n<463> g_free(masterkey);\n<465> qcrypto_cipher_free(block->cipher);\n<467> qcrypto_ivgen_free(block->ivgen);\n<469> g_free(luks);\n<471> g_free(password);\n<473> return ret;
<1> static inline void mix_2f_2r_to_stereo(AC3DecodeContext *ctx)\n<19> memset(output[3], 0, sizeof(output[3]));\n<21> memset(output[4], 0, sizeof(output[4]));
<1> static PCIDevice *do_pci_register_device(PCIDevice *pci_dev, PCIBus *bus,\n<15> if (!bus->devices[devfn])\n<25> } else if (bus->devices[devfn]) {\n<37> memset(pci_dev->irq_state, 0, sizeof(pci_dev->irq_state));\n<39> pci_config_alloc(pci_dev);\n<41> pci_set_default_subsystem_id(pci_dev);\n<43> pci_init_cmask(pci_dev);\n<45> pci_init_wmask(pci_dev);\n<61> bus->devices[devfn] = pci_dev;\n<63> pci_dev->irq = qemu_allocate_irqs(pci_set_irq, pci_dev, PCI_NUM_PINS);\n<67> return pci_dev;
<1> static int get_segment (CPUState *env, mmu_ctx_t *ctx,\n<393> if (logfile) {\n<395> fprintf(logfile, "ERROR: instruction should not need "
<1> static int rwpipe_read_ppm_header( rwpipe *rw, int *width, int *height )\n<5> char line[ 3 ];\n<7> FILE *in = rwpipe_reader( rw );\n<13> fgets( line, 3, in );\n<15> if ( !strncmp( line, "P6", 2 ) )
<1> static int openfile(char *name, int flags, QDict *opts)\n<23> qemuio_blk = blk_new_open(name, NULL, opts, flags, &local_err);\n<39> if (bdrv_is_encrypted(bs)) {\n<43> printf("Disk image '%s' is encrypted.\n", name);
<1> static int readv_f(int argc, char **argv)\n<23> int pattern = 0;\n<29> while ((c = getopt(argc, argv, "CP:qv")) != EOF) {\n<45> if (pattern < 0) {\n<85> offset = cvtnum(argv[optind]);\n<87> if (offset < 0) {\n<89> printf("non-numeric length argument -- %s\n", argv[optind]);\n<113> buf = create_iovec(&qiov, &argv[optind], nr_iov, 0xab);\n<115> if (buf == NULL) {\n<131> if (cnt < 0) {\n<133> printf("readv failed: %s\n", strerror(-cnt));\n<141> if (Pflag) {\n<143> void *cmp_buf = malloc(qiov.size);\n<145> memset(cmp_buf, pattern, qiov.size);\n<147> if (memcmp(buf, cmp_buf, qiov.size)) {\n<155> free(cmp_buf);\n<171> dump_buffer(buf, offset, qiov.size);\n<181> print_report("read", &t2, offset, qiov.size, total, cnt, Cflag);\n<187> qemu_io_free(buf);
<1> int qcow2_grow_l1_table(BlockDriverState *bs, uint64_t min_size,\n<7> BDRVQcowState *s = bs->opaque;\n<51> if (new_l1_size > INT_MAX) {\n<71> new_l1_table = g_malloc0(align_offset(new_l1_size2, 512));\n<73> memcpy(new_l1_table, s->l1_table, s->l1_size * sizeof(uint64_t));\n<85> g_free(new_l1_table);\n<123> new_l1_table[i] = cpu_to_be64(new_l1_table[i]);\n<125> ret = bdrv_pwrite_sync(bs->file, new_l1_table_offset, new_l1_table, new_l1_size2);\n<153> g_free(s->l1_table);\n<169> g_free(new_l1_table);
<1> BlockDriverAIOCB *bdrv_aio_read(BlockDriverState *bs, int64_t sector_num,\n<3> uint8_t *buf, int nb_sectors,\n<23> if (sector_num == 0 && bs->boot_sector_enabled && nb_sectors > 0) {\n<25> memcpy(buf, bs->boot_sector_data, 512);\n<31> buf += 512;\n<37> ret = drv->bdrv_aio_read(bs, sector_num, buf, nb_sectors, cb, opaque);
<1> PCIBus *ppce500_pci_init(qemu_irq pci_irqs[4], target_phys_addr_t registers)\n<53> if (index < 0)\n<69> if (index < 0)\n<81> if (index < 0)\n<105> printf("%s error\n", __func__);
<1> vpx_codec_err_t vpx_svc_set_scale_factors ( SvcContext * svc_ctx , const char * scale_factors ) {\n<2> SvcInternal * const si = get_svc_internal ( svc_ctx ) ;\n<3> if ( svc_ctx == NULL || scale_factors == NULL || si == NULL ) {\n<6> strncpy ( si -> scale_factors , scale_factors , sizeof ( si -> scale_factors ) ) ;
<1> static void versatile_init(ram_addr_t ram_size, int vga_ram_size,\n<39> if (!env) {\n<41> fprintf(stderr, "Unable to find CPU definition\n");\n<75> for(n = 0; n < nb_nics; n++) {\n<77> nd = &nd_table[n];\n<79> if (!nd->model)\n<81> nd->model = done_smc ? "rtl8139" : "smc91c111";\n<83> if (strcmp(nd->model, "smc91c111") == 0) {\n<85> smc91c111_init(nd, 0x10010000, sic[25]);\n<89> pci_nic_init(pci_bus, nd, -1);\n<101> if (drive_get_max_bus(IF_SCSI) > 0) {\n<103> fprintf(stderr, "qemu: too many SCSI bus\n");\n<153> if (index == -1) {\n<155> fprintf(stderr, "qemu: missing SecureDigital card\n");
<1> static void keyword_literal(void)\n<31> g_assert(strcmp(qstring_get_str(str), "true") == 0);\n<57> g_assert(strcmp(qstring_get_str(str), "false") == 0);
<1> static int set_boot_dev(ISADevice *s, const char *boot_device)\n<13> nbds = strlen(boot_device);\n<15> if (nbds > PC_MAX_BOOT_DEVICES) {\n<25> bds[i] = boot_device2nibble(boot_device[i]);\n<29> error_report("Invalid boot device for PC: '%c'",
<1> void ff_build_rac_states(RangeCoder *c, int factor, int max_p){\n<11> memset(c->zero_state, 0, sizeof(c->zero_state));\n<13> memset(c-> one_state, 0, sizeof(c-> one_state));
<127> if (buf_size < s->image_width*s->image_height*3) {\n<139> res = encode_bitstream(s, p, buf, buf_size, opt_w*16, opt_h*16, s->previous_frame, &I_frame);\n<145> memcpy(s->previous_frame, p->data[0], s->image_height*p->linesize[0]);
<1> static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size, uint8_t *buf, int buf_size)\n<87> for (i = 0; i < MAX_BLOCKS; i++)\n<89> memset(ctx->delay[i], 0, sizeof(ctx->delay[i]));\n<145> if (ac3_parse_audio_block(ctx, i)) {\n<161> if (ctx->bsi.flags & AC3_BSI_LFEON) {\n<163> ff_imdct_calc(&ctx->imdct_ctx_512, ctx->tmp_output, ab->transform_coeffs[0], ctx->tmp_imdct);\n<167> ab->block_output[0][l] = ctx->tmp_output[l] * window[l] + ctx->delay[0][l] * window[255 -l];\n<169> memcpy(ctx->delay[0], ctx->tmp_output + 256, sizeof(ctx->delay[0]));\n<177> if (ctx->audio_block.blksw & (1 << j)) {\n<191> ab->block_output[j + 1][l] = ctx->tmp_output[l] * window[l] + ctx->delay[j + 1][l] * window[255 - l];\n<193> ff_imdct_calc(&ctx->imdct_ctx_256, ctx->delay[j + 1], tmp_block_second_half, ctx->tmp_imdct);\n<197> ff_imdct_calc(&ctx->imdct_ctx_512, ctx->tmp_output, ab->transform_coeffs[j + 1], ctx->tmp_imdct);\n<201> ab->block_output[j + 1][l] = ctx->tmp_output[l] * window[l] + ctx->delay[j + 1][l] * window[255 - l];\n<203> memcpy(ctx->delay[j + 1], ctx->tmp_output + 256, sizeof(ctx->delay[j + 1]));
<1> static void read_ttag(AVFormatContext *s, int taglen, const char *key)\n<13> dst[0] = 0;\n<15> if (taglen < 1)\n<51> get_buffer(s->pb, dst, len);\n<53> dst[len] = 0;\n<61> if (!strcmp(key, "genre")\n<63> && (sscanf(dst, "(%d)", &genre) == 1 || sscanf(dst, "%d", &genre) == 1)\n<65> && genre <= ID3v1_GENRE_MAX)\n<67> av_strlcpy(dst, ff_id3v1_genre_str[genre], sizeof(dst));\n<73> av_metadata_set(&s->metadata, key, dst);
<1> static void sun4uv_init(MemoryRegion *address_space_mem,\n<3> MachineState *machine,\n<137> sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", machine->ram_size,\n<171> if (machine->kernel_cmdline) {\n<175> strlen(machine->kernel_cmdline) + 1);\n<177> fw_cfg_add_string(fw_cfg, FW_CFG_CMDLINE_DATA, machine->kernel_cmdline);
<1> length_f(int argc, char **argv)\n<13> if (size < 0) {\n<15> printf("getlength: %s", strerror(size));\n<23> cvtstr(size, s1, sizeof(s1));\n<25> printf("%s\n", s1);
<1> static int video_get_buffer(AVCodecContext *s, AVFrame *pic)\n<23> if (!desc) {\n<37> memset(pic->data, 0, sizeof(pic->data));\n<39> pic->extended_data = pic->data;\n<79> av_log(s, AV_LOG_DEBUG, "default_get_buffer called on pic %p\n", pic);\n<87> av_frame_unref(pic);
<1> abi_long do_syscall(void *cpu_env, int num, abi_long arg1,\n<389> int total_size = 0;\n<439> gp += sizeof(abi_ulong), q++) {\n<449> if (!(*q = lock_user_string(addr)))\n<453> total_size += strlen(*q) + 1;\n<463> gp += sizeof(abi_ulong), q++) {\n<473> if (!(*q = lock_user_string(addr)))\n<477> total_size += strlen(*q) + 1;\n<489> if (total_size > MAX_ARG_PAGES * TARGET_PAGE_SIZE) {\n<529> unlock_user(*q, addr, 0);\n<543> unlock_user(*q, addr, 0);\n<2471> p2 = lock_user(VERIFY_WRITE, arg2, arg3, 0);\n<2473> if (!p || !p2)\n<2479> if (strncmp((const char *)p, "/proc/self/exe", 14) == 0) {\n<2483> temp = realpath(exec_path,real);\n<2485> ret = (temp==NULL) ? get_errno(-1) : strlen(real) ;\n<2487> snprintf((char *)p2, arg3, "%s", real);\n<2493> ret = get_errno(readlink(path(p), p2, arg3));\n<2497> unlock_user(p2, arg2, ret);\n<2861> if (!lock_user_struct(VERIFY_WRITE, target_stfs, arg2, 0))\n<2887> memset(target_stfs->f_spare, 0, sizeof(target_stfs->f_spare));\n<2889> unlock_user_struct(target_stfs, arg2, 1);\n<3279> if (!lock_user_struct(VERIFY_WRITE, target_st, arg2, 0))\n<3283> memset(target_st, 0, sizeof(*target_st));\n<3285> __put_user(st.st_dev, &target_st->st_dev);\n<3287> __put_user(st.st_ino, &target_st->st_ino);\n<3289> __put_user(st.st_mode, &target_st->st_mode);\n<3291> __put_user(st.st_uid, &target_st->st_uid);\n<3293> __put_user(st.st_gid, &target_st->st_gid);\n<3295> __put_user(st.st_nlink, &target_st->st_nlink);\n<3297> __put_user(st.st_rdev, &target_st->st_rdev);\n<3299> __put_user(st.st_size, &target_st->st_size);\n<3301> __put_user(st.st_blksize, &target_st->st_blksize);\n<3303> __put_user(st.st_blocks, &target_st->st_blocks);\n<3305> __put_user(st.st_atime, &target_st->target_st_atime);\n<3307> __put_user(st.st_mtime, &target_st->target_st_mtime);\n<3309> __put_user(st.st_ctime, &target_st->target_st_ctime);\n<3311> unlock_user_struct(target_st, arg2, 1);\n<4341> if (arg2 & (sizeof(abi_ulong) - 1)) {\n<4353> mask = alloca(mask_size);\n<4355> if (!lock_user_struct(VERIFY_READ, p, arg3, 1)) {\n<4361> memcpy(mask, p, arg2);\n<4363> unlock_user_struct(p, arg2, 0);\n<4367> ret = get_errno(sys_sched_setaffinity(arg1, mask_size, mask));
<1> int kvm_init(int smp_cpus)\n<19> if (smp_cpus > 1) {\n<21> fprintf(stderr, "No SMP KVM support, use '-smp 1'\n");\n<49> if (s->fd == -1) {\n<51> fprintf(stderr, "Could not access KVM kernel module: %m\n");\n<63> if (ret < KVM_API_VERSION) {\n<69> fprintf(stderr, "kvm version too old\n");\n<77> if (ret > KVM_API_VERSION) {\n<81> fprintf(stderr, "kvm version not supported\n");\n<107> if (!kvm_check_extension(s, KVM_CAP_USER_MEMORY)) {\n<111> fprintf(stderr, "kvm does not support KVM_CAP_USER_MEMORY\n%s",\n<127> if (!kvm_check_extension(s, KVM_CAP_DESTROY_MEMORY_REGION_WORKS)) {
<1> static int mpc7_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame_ptr , AVPacket * avpkt ) {\n<5> MPCContext * c = avctx -> priv_data ;\n<9> Band * bands = c -> bands ;\n<12> memset ( bands , 0 , sizeof ( * bands ) * ( c -> maxbands + 1 ) ) ;\n<31> if ( ! c -> bits ) return AVERROR ( ENOMEM ) ;\n<82> memset ( c -> Q , 0 , sizeof ( c -> Q ) ) ;\n<88> ch ++ ) idx_to_quant ( c , & gb , bands [ i ] . res [ ch ] , c -> Q [ ch ] + off ) ;\n<89> ff_mpc_dequantize_and_synth ( c , mb , ( int16_t * * ) frame -> extended_data , 2 ) ;
<1> int qxl_render_cursor(PCIQXLDevice *qxl, QXLCommandExt *ext)\n<29> if (qxl->debug > 1 && cmd->type != QXL_CURSOR_MOVE) {\n<31> fprintf(stderr, "%s", __FUNCTION__);\n<35> fprintf(stderr, "\n");
<1> static void stellaris_enet_receive(void *opaque, const uint8_t *buf, size_t size)\n<19> if (s->np >= 31) {\n<29> DPRINTF("Received packet len=%d\n", size);\n<47> *(p++) = (size + 6) >> 8;\n<49> memcpy (p, buf, size);\n<51> p += size;\n<53> crc = crc32(~0, buf, size);\n<61> *(p++) = crc >> 24;\n<65> if ((size & 3) != 2) {\n<67> memset(p, 0, (6 - size) & 3);
<1> int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n<17> if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n<21> memcpy(buf, pvinfo.hcall, buf_len);
<3> AVCodecContext *avctx,\n<11> ADXParseContext *s = s1->priv_data;\n<13> ParseContext *pc = &s->pc;\n<25> ff_combine_frame(pc, END_NOT_FOUND, &buf, &buf_size);\n<31> if (ret = avpriv_adx_decode_header(avctx, pc->buffer, pc->index,\n<41> if (s->header_size && s->header_size <= pc->index) {\n<45> if (!avctx->extradata)\n<51> memcpy(avctx->extradata, pc->buffer, s->header_size);\n<53> memmove(pc->buffer, pc->buffer + s->header_size, s->header_size);\n<55> pc->index -= s->header_size;\n<81> if (pc->index && s->buf_pos) {\n<83> memmove(pc->buffer, &pc->buffer[s->buf_pos], pc->index - s->buf_pos);\n<97> if (ff_combine_frame(pc, next, &buf, &buf_size) < 0 || !buf_size) {
<1> static int mpjpeg_read_packet(AVFormatContext *s, AVPacket *pkt)\n<11> MPJPEGDemuxContext *mpjpeg = s->priv_data;\n<17> mpjpeg->searchstr = av_strdup("\r\n--");\n<19> if (!mpjpeg->boundary || !mpjpeg->searchstr) {\n<29> mpjpeg->searchstr_len = strlen(mpjpeg->searchstr);\n<79> while ((ret = av_append_packet(s->pb, pkt, read_chunk - remaining)) >= 0) {\n<85> char *start = pkt->data + pkt->size - len;\n<89> if (!memcmp(start, mpjpeg->searchstr, mpjpeg->searchstr_len)) {\n<93> avio_seek(s->pb, -(len-2), SEEK_CUR);\n<95> pkt->size -= (len-2);\n<97> return pkt->size;\n<101> len--;\n<103> start++;\n<105> } while (len >= mpjpeg->searchstr_len);
<1> int authreadkeys ( const char * file ) {\n<12> if ( fp == NULL ) {\n<18> while ( ( line = fgets ( buf , sizeof buf , fp ) ) != NULL ) {\n<19> token = nexttok ( & line ) ;\n<20> if ( token == NULL ) continue ;\n<30> token = nexttok ( & line ) ;\n<31> if ( token == NULL ) {\n<50> if ( token == NULL ) {\n<54> len = strlen ( token ) ;\n<55> if ( len <= 20 ) {\n<56> MD5auth_setkey ( keyno , keytype , ( u_char * ) token , len ) ;\n<59> char hex [ ] = "0123456789abcdef" ;\n<65> j < jlim ;\n<67> ptr = strchr ( hex , tolower ( ( unsigned char ) token [ j ] ) ) ;\n<68> if ( ptr == NULL ) break ;\n<69> temp = ( u_char ) ( ptr - hex ) ;
<1> static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size,\n<7> const uint8_t *buf = avpkt->data;\n<11> AC3DecodeContext *s = avctx->priv_data;\n<25> if (s->input_buffer) {\n<31> memcpy(s->input_buffer, buf, FFMIN(buf_size, AC3_FRAME_BUFFER_SIZE));\n<33> init_get_bits(&s->gbc, s->input_buffer, buf_size * 8);\n<67> if(av_crc(av_crc_get_table(AV_CRC_16_ANSI), 0, &buf[2], s->frame_size-2)) {
<1> static void mcf5208evb_init(MachineState *machine)\n<85> if (nb_nics > 1) {\n<87> fprintf(stderr, "Too many NICs\n");\n<151> if (qtest_enabled()) {\n<157> fprintf(stderr, "Kernel image must be specified\n");\n<165> kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n<173> kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL,\n<181> kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n<189> if (kernel_size < 0) {\n<191> fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename);
<1> static int open_self_maps(void *cpu_env, int fd)\n<15> char *line = NULL;\n<25> if (fp == NULL) {\n<33> while ((read = getline(&line, &len, fp)) != -1) {\n<81> free(line);
<1> static char *shorts2str(int *sp, int count, const char *sep)\n<9> if (!sep) sep = ", ";\n<11> ap = av_malloc((5 + strlen(sep)) * count);\n<13> if (!ap)\n<17> ap0   = ap;\n<19> ap[0] = '\0';\n<21> for (i = 0; i < count; i++) {\n<23> int l = snprintf(ap, 5 + strlen(sep), "%d%s", sp[i], sep);\n<25> ap += l;\n<29> ap0[strlen(ap0) - strlen(sep)] = '\0';\n<31> return ap0;
<1> static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)\n<11> if (ap == NULL) {\n<23> val = token_get_value(token);\n<27> if (!strcmp(val, "%p")) {\n<31> } else if (!strcmp(val, "%i")) {\n<35> } else if (!strcmp(val, "%d")) {\n<39> } else if (!strcmp(val, "%ld")) {\n<43> } else if (!strcmp(val, "%lld") ||\n<45> !strcmp(val, "%I64d")) {\n<49> } else if (!strcmp(val, "%s")) {\n<53> } else if (!strcmp(val, "%f")) {
<1> int mi_repair ( MI_CHECK * param , register MI_INFO * info , char * name , int rep_quick ) {\n<18> if ( ! ( param -> testflag & T_SILENT ) ) {\n<19> printf ( "- recovering (with keycache) MyISAM-table '%s'\n" , name ) ;\n<20> printf ( "Data records: %s\n" , llstr ( info -> state -> records , llbuff ) ) ;\n<61> info -> state -> records = info -> state -> del = share -> state . split = 0 ;\n<62> info -> state -> empty = 0 ;\n<67> mi_drop_all_indexes ( param , info , TRUE ) ;\n<75> ( void ) _mi_make_key ( info , ( uint ) info -> errkey , info -> lastkey , sort_param . record , 0L ) ;\n<93> if ( mysql_file_chsize ( share -> kfile , info -> state -> key_file_length , 0 , MYF ( 0 ) ) ) {\n<97> if ( rep_quick && del + sort_info . dupp != info -> state -> del ) {\n<115> info -> state -> data_file_length = sort_param . filepos ;\n<119> info -> state -> data_file_length = sort_param . max_pos ;\n<121> if ( param -> testflag & T_CALC_CHECKSUM ) info -> state -> checksum = param -> glob_crc ;\n<123> if ( start_records != info -> state -> records ) printf ( "Data records: %s\n" , llstr ( info -> state -> records , llbuff ) ) ;\n<127> if ( & share -> state . state != info -> state ) memcpy ( & share -> state . state , info -> state , sizeof ( * info -> state ) ) ;\n<136> if ( change_to_newfile ( share -> data_file_name , MI_NAME_DEXT , DATA_TMP_EXT , ( param -> testflag & T_BACKUP_DATA ? MYF ( MY_REDEL_MAKE_BACKUP ) : MYF ( 0 ) ) ) || mi_open_datafile ( info , share , name , - 1 ) ) got_error = 1 ;\n<147> mi_mark_crashed_on_repair ( info ) ;\n<149> my_free ( mi_get_rec_buff_ptr ( info , sort_param . rec_buff ) ) ;\n<150> my_free ( mi_get_rec_buff_ptr ( info , sort_param . record ) ) ;
<1> static void rtas_nvram_store(sPAPREnvironment *spapr,\n<31> if (!nvram) {\n<45> len = rtas_ld(args, 2);\n<49> if (((offset + len) < offset)\n<61> membuf = cpu_physical_memory_map(buffer, &len, 0);\n<63> if (nvram->drive) {\n<69> assert(nvram->buf);\n<73> memcpy(nvram->buf + offset, membuf, len);\n<75> alen = len;\n<79> cpu_physical_memory_unmap(membuf, len, 0, len);
<1> static int update_rom_mapping(VAPICROMState *s, CPUX86State *env, target_ulong ip)\n<47> if (paddr != s->rom_state_paddr) {\n<55> if (memcmp(s->rom_state.signature, "kvm aPiC", 8) != 0) {\n<57> return -1;\n<61> s->rom_state_vaddr = rom_state_vaddr;\n<67> if (rom_state_vaddr == le32_to_cpu(s->rom_state.vaddr)) {
<1> int ffio_ensure_seekback(AVIOContext *s, int buf_size)\n<13> buf_size += s->buf_ptr - s->buffer + max_buffer_size;\n<17> if (buf_size < s->buffer_size || s->seekable)\n<27> if (!buffer)\n<33> memcpy(buffer, s->buffer, s->buffer_size);\n<35> av_free(s->buffer);\n<37> s->buf_ptr = buffer + (s->buf_ptr - s->buffer);\n<39> s->buf_end = buffer + (s->buf_end - s->buffer);\n<41> s->buffer = buffer;
<1> static int dump_tablespaces ( char * ts_where ) {\n<4> char buf [ FN_REFLEN ] ;\n<7> char extra_format [ ] = "UNDO_BUFFER_SIZE=" ;\n<19> if ( mysql_query ( mysql , sqlbuf . str ) || ! ( tableres = mysql_store_result ( mysql ) ) ) {\n<21> if ( mysql_errno ( mysql ) == ER_BAD_TABLE_ERROR || mysql_errno ( mysql ) == ER_BAD_DB_ERROR || mysql_errno ( mysql ) == ER_UNKNOWN_TABLE ) {\n<22> fprintf ( md_result_file , "\n--\n-- Not dumping tablespaces as no INFORMATION_SCHEMA.FILES" " table on this server\n--\n" ) ;\n<23> check_io ( md_result_file ) ;\n<26> fprintf ( stderr , "%s: Error: '%s' when trying to dump tablespaces\n" , my_progname_short , mysql_error ( mysql ) ) ;\n<29> buf [ 0 ] = 0 ;\n<30> while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n<31> if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n<32> if ( first ) {\n<33> print_comment ( md_result_file , 0 , "\n--\n-- Logfile group: %s\n--\n" , row [ 0 ] ) ;\n<34> fprintf ( md_result_file , "\nCREATE" ) ;\n<37> fprintf ( md_result_file , "\nALTER" ) ;\n<39> fprintf ( md_result_file , " LOGFILE GROUP %s\n" " ADD UNDOFILE '%s'\n" , row [ 0 ] , row [ 1 ] ) ;\n<40> if ( first ) {\n<41> ubs = strstr ( row [ 5 ] , extra_format ) ;\n<42> if ( ! ubs ) break ;\n<43> ubs += strlen ( extra_format ) ;\n<47> fprintf ( md_result_file , " UNDO_BUFFER_SIZE %s\n" , ubs ) ;\n<54> strxmov ( buf , row [ 0 ] , NullS ) ;\n<66> buf [ 0 ] = 0 ;\n<67> while ( ( row = mysql_fetch_row ( tableres ) ) ) {\n<68> if ( strcmp ( buf , row [ 0 ] ) != 0 ) first = 1 ;\n<69> if ( first ) {\n<70> print_comment ( md_result_file , 0 , "\n--\n-- Tablespace: %s\n--\n" , row [ 0 ] ) ;\n<71> fprintf ( md_result_file , "\nCREATE" ) ;\n<74> fprintf ( md_result_file , "\nALTER" ) ;\n<76> fprintf ( md_result_file , " TABLESPACE %s\n" " ADD DATAFILE '%s'\n" , row [ 0 ] , row [ 1 ] ) ;\n<77> if ( first ) {\n<78> fprintf ( md_result_file , " USE LOGFILE GROUP %s\n" " EXTENT_SIZE %s\n" , row [ 2 ] , row [ 3 ] ) ;\n<85> strxmov ( buf , row [ 0 ] , NullS ) ;
<1> struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size,\n<33> if (!s->env) {\n<35> fprintf(stderr, "Unable to find CPU definition\n");\n<369> if (!dinfo) {\n<371> fprintf(stderr, "qemu: missing SecureDigital device\n");
<1> static int decode_ref_pic_list_reordering(H264Context *h){\n<17> for(list=0; list<h->list_count; list++){\n<19> memcpy(h->ref_list[list], h->default_ref_list[list], sizeof(Picture)*h->ref_count[list]);\n<155> if (i < 0) {\n<159> memset(&h->ref_list[list][index], 0, sizeof(Picture)); //FIXME\n<173> h->ref_list[list][i]= h->ref_list[list][i-1];\n<177> h->ref_list[list][index]= *ref;\n<181> pic_as_field(&h->ref_list[list][index], pic_structure);
<31> if (dec && dec->subtitle_header) {\n<33> ost->enc_ctx->subtitle_header = av_malloc(dec->subtitle_header_size);\n<35> if (!ost->enc_ctx->subtitle_header)\n<39> memcpy(ost->enc_ctx->subtitle_header, dec->subtitle_header, dec->subtitle_header_size);\n<41> ost->enc_ctx->subtitle_header_size = dec->subtitle_header_size;\n<63> if ((ret = avcodec_open2(ost->enc_ctx, codec, &ost->encoder_opts)) < 0) {\n<91> ret = avcodec_parameters_from_context(ost->st->codecpar, ost->enc_ctx);\n<123> const AVPacketSideData *sd_src = &ost->enc_ctx->coded_side_data[i];\n<125> AVPacketSideData *sd_dst = &ost->st->side_data[i];\n<129> sd_dst->data = av_malloc(sd_src->size);\n<131> if (!sd_dst->data)\n<135> memcpy(sd_dst->data, sd_src->data, sd_src->size);\n<137> sd_dst->size = sd_src->size;
<1> gcry_error_t gcry_mpi_print ( enum gcry_mpi_format format , unsigned char * buffer , size_t buflen , size_t * nwritten , struct gcry_mpi * a ) {\n<17> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<18> if ( n && ( * tmp & 0x80 ) ) {\n<26> if ( buffer ) {\n<27> unsigned char * s = buffer ;\n<28> if ( extra ) * s ++ = 0 ;\n<29> memcpy ( s , tmp , n - extra ) ;\n<31> gcry_free ( tmp ) ;\n<36> unsigned int n = ( nbits + 7 ) / 8 ;\n<37> if ( buffer && n > len ) return gcry_error ( GPG_ERR_TOO_SHORT ) ;\n<40> tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n<41> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<42> memcpy ( buffer , tmp , n ) ;\n<43> gcry_free ( tmp ) ;\n<45> * nwritten = n ;\n<49> unsigned int n = ( nbits + 7 ) / 8 ;\n<54> unsigned char * s = buffer ;\n<55> s [ 0 ] = nbits >> 8 ;\n<56> s [ 1 ] = nbits ;\n<57> tmp = _gcry_mpi_get_buffer ( a , & n , NULL ) ;\n<58> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<59> memcpy ( s + 2 , tmp , n ) ;\n<60> gcry_free ( tmp ) ;\n<62> * nwritten = n + 2 ;\n<71> if ( ! tmp ) return gpg_error_from_syserror ( ) ;\n<72> if ( n && ( * tmp & 0x80 ) ) {\n<80> if ( buffer ) {\n<85> * s ++ = n ;\n<86> if ( extra ) * s ++ = 0 ;\n<87> memcpy ( s , tmp , n - extra ) ;\n<89> gcry_free ( tmp ) ;
<1> int vnc_hextile_send_framebuffer_update(VncState *vs, int x,\n<17> last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n<19> last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);\n<37> free(last_fg);\n<39> free(last_bg);
<1> void cpu_loop(CPUSH4State *env)\n<17> trapnr = cpu_sh4_exec(cs);\n<23> switch (trapnr) {\n<105> printf ("Unhandled trap: 0x%x\n", trapnr);
<1> static int rv34_decode_mv ( RV34DecContext * r , int block_type ) {\n<7> memset ( r -> dmv , 0 , sizeof ( r -> dmv ) ) ;\n<19> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n<36> l ++ ) s -> current_picture_ptr -> f . motion_val [ l ] [ mv_pos + i + j * s -> b8_stride ] [ k ] = calc_add_mv ( r , l , s -> next_picture_ptr -> f . motion_val [ 0 ] [ mv_pos + i + j * s -> b8_stride ] [ k ] ) ;\n<37> if ( ! ( IS_16X8 ( next_bt ) || IS_8X16 ( next_bt ) || IS_8X8 ( next_bt ) ) ) rv34_mc_2mv ( r , block_type ) ;\n<38> else rv34_mc_2mv_skip ( r ) ;\n<41> case RV34_MB_P_16x16 : case RV34_MB_P_MIX16x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n<42> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , 0 ) ;\n<46> if ( r -> rv30 ) rv34_pred_mv_rv3 ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n<47> else rv34_pred_mv_b ( r , block_type , block_type == RV34_MB_B_BACKWARD ) ;\n<48> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 2 , block_type == RV34_MB_B_BACKWARD ) ;\n<50> case RV34_MB_P_16x8 : case RV34_MB_P_8x16 : rv34_pred_mv ( r , block_type , 0 , 0 ) ;\n<51> rv34_pred_mv ( r , block_type , 1 + ( block_type == RV34_MB_P_16x8 ) , 1 ) ;\n<53> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 2 , 1 , 0 ) ;\n<54> rv34_mc_1mv ( r , block_type , 0 , 8 , s -> b8_stride , 2 , 1 , 0 ) ;\n<57> rv34_mc_1mv ( r , block_type , 0 , 0 , 0 , 1 , 2 , 0 ) ;\n<58> rv34_mc_1mv ( r , block_type , 8 , 0 , 1 , 1 , 2 , 0 ) ;\n<61> case RV34_MB_B_BIDIR : rv34_pred_mv_b ( r , block_type , 0 ) ;\n<62> rv34_pred_mv_b ( r , block_type , 1 ) ;\n<63> rv34_mc_2mv ( r , block_type ) ;\n<68> rv34_pred_mv ( r , block_type , i , i ) ;\n<69> rv34_mc_1mv ( r , block_type , ( i & 1 ) << 3 , ( i & 2 ) << 2 , ( i & 1 ) + ( i >> 1 ) * s -> b8_stride , 1 , 1 , 0 ) ;
<1> static void logerr (struct audio_pt *pt, int err, const char *fmt, ...)\n<11> AUD_vlog (pt->drv, fmt, ap);\n<19> AUD_log (pt->drv, "Reason: %s\n", strerror (err));
<1> void ff_er_add_slice(ERContext *s, int startx, int starty,\n<81> if (mask == ~0x7F) {\n<85> (end_xy - start_xy) * sizeof(uint8_t));\n<113> s->error_status_table[start_xy] |= VP_START;
<1> static int qemu_rdma_drain_cq(QEMUFile *f, RDMAContext *rdma)\n<21> if (ret < 0) {\n<23> fprintf(stderr, "rdma migration: complete polling error!\n");
<1> static void sm501_draw_crt(SM501State *s)\n<15> int src_bpp = get_bpp(s, 1);\n<45> switch (src_bpp) {\n<67> printf("sm501 draw crt : invalid DC_CRT_CONTROL=%x.\n",\n<81> if (is_hwc_enabled(s, 1)) {\n<87> hwc_src = get_hwc_address(s, 1);\n<89> c_x = get_hwc_x(s, 1);\n<91> c_y = get_hwc_y(s, 1);\n<93> get_hwc_palette(s, 1, hwc_palette);
<1> void object_property_add(Object *obj, const char *name, const char *type,\n<17> QTAILQ_FOREACH(prop, &obj->properties, node) {\n<19> if (strcmp(prop->name, name) == 0) {\n<21> error_setg(errp, "attempt to add duplicate property '%s'"\n<25> object_get_typename(obj));\n<27> return;\n<35> prop = g_malloc0(sizeof(*prop));\n<39> prop->name = g_strdup(name);\n<41> prop->type = g_strdup(type);\n<45> prop->get = get;\n<47> prop->set = set;\n<49> prop->release = release;\n<51> prop->opaque = opaque;\n<55> QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
<1> static void omap_prcm_apll_update(struct omap_prcm_s *s)\n<21> if (mode[0] == 1 || mode[0] == 2 || mode[1] == 1 || mode[1] == 2)\n<23> fprintf(stderr, "%s: bad EN_54M_PLL or bad EN_96M_PLL\n",
<1> static void init_dequant8_coeff_table(H264Context *h){\n<13> for(i=0; i<2; i++ ){\n<15> if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){\n<17> h->dequant8_coeff[1] = h->dequant8_buffer[0];\n<25> for(q=0; q<52; q++){
<1> rdt_parse_sdp_line (AVFormatContext *s, int st_index,\n<3> PayloadContext *rdt, const char *line)\n<35> if (rdt->nb_rmst < count) {\n<39> if (!rmst)\n<45> (count - rdt->nb_rmst) * sizeof(*rmst));\n<55> rdt_load_mdpr(rdt, s->streams[n], (n - first) * 2);
<1> static int qio_dns_resolver_lookup_sync_inet(QIODNSResolver *resolver,\n<17> char port[33];\n<37> memset(&ai, 0, sizeof(ai));\n<39> ai.ai_flags = AI_PASSIVE;\n<43> ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;\n<47> ai.ai_family = inet_ai_family_from_address(iaddr, &err);\n<49> ai.ai_socktype = SOCK_STREAM;\n<63> if (iaddr->host == NULL) {\n<71> if (iaddr->port != NULL) {\n<73> pstrcpy(port, sizeof(port), iaddr->port);\n<77> port[0] = '\0';\n<83> rc = getaddrinfo(strlen(iaddr->host) ? iaddr->host : NULL,\n<85> strlen(port) ? port : NULL, &ai, &res);\n<87> if (rc != 0) {\n<89> error_setg(errp, "address resolution failed for %s:%s: %s",\n<99> for (e = res; e != NULL; e = e->ai_next) {\n<113> for (i = 0, e = res; e != NULL; i++, e = e->ai_next) {\n<159> freeaddrinfo(res);
<1> static inline void mix_3f_2r_to_stereo(AC3DecodeContext *ctx)\n<19> memset(output[3], 0, sizeof(output[3]));\n<21> memset(output[4], 0, sizeof(output[4]));\n<23> memset(output[5], 0, sizeof(output[5]));
<1> static int ehci_init_transfer(EHCIQueue *q)\n<23> if (cpage > 4) {\n<25> fprintf(stderr, "cpage out of range (%d)\n", cpage);
<1> int ffurl_alloc(URLContext **puc, const char *filename, int flags,\n<11> size_t proto_len = strspn(filename, URL_SCHEME_CHARS);\n<15> if (filename[proto_len] != ':' || is_dos_path(filename))\n<23> FFMIN(proto_len + 1, sizeof(proto_str)));\n<27> av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));\n<29> if ((ptr = strchr(proto_nested, '+')))\n<31> *ptr = '\0';\n<35> while (up = ffurl_protocol_next(up)) {\n<37> if (!strcmp(proto_str, up->name))\n<39> return url_alloc_for_protocol(puc, up, filename, flags, int_cb);\n<41> if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&\n<43> !strcmp(proto_nested, up->name))\n<45> return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
<1> static void tcg_reg_alloc_op(TCGContext *s,\n<5> const TCGArg *args, uint16_t dead_args,\n<21> TCGArg new_args[TCG_MAX_OP_ARGS];\n<27> nb_oargs = def->nb_oargs;\n<29> nb_iargs = def->nb_iargs;\n<39> sizeof(TCGArg) * def->nb_cargs);
<1> static void handle_null_request ( int tun_fd , int dns_fd , struct query * q , int domain_len ) {\n<11> if ( domain_len < 2 ) return ;\n<12> memcpy ( in , q -> name , MIN ( domain_len , sizeof ( in ) ) ) ;\n<13> if ( in [ 0 ] == 'V' || in [ 0 ] == 'v' ) {\n<15> read = unpack_data ( unpacked , sizeof ( unpacked ) , & ( in [ 1 ] ) , domain_len - 1 , b32 ) ;\n<19> if ( version == VERSION ) {\n<21> if ( userid >= 0 ) {\n<25> tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n<26> memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n<27> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<30> send_version_response ( dns_fd , VERSION_ACK , users [ userid ] . seed , userid , q ) ;\n<31> syslog ( LOG_INFO , "accepted version for user #%d from %s" , userid , format_addr ( & q -> from , q -> fromlen ) ) ;\n<71> send_version_response ( dns_fd , VERSION_FULL , created_users , 0 , q ) ;\n<72> syslog ( LOG_INFO , "dropped user from %s, server full" , format_addr ( & q -> from , q -> fromlen ) ) ;\n<76> send_version_response ( dns_fd , VERSION_NACK , VERSION , 0 , q ) ;\n<77> syslog ( LOG_INFO , "dropped user from %s, sent bad version %08X" , format_addr ( & q -> from , q -> fromlen ) , version ) ;
<1> static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) {\n<12> case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ;\n<13> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n<14> cctx -> tls_aad_len = arg ;\n<16> uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ;\n<23> case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ;\n<24> memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ;\n<30> case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ;\n<31> if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ;\n<32> if ( ptr ) {\n<34> memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ;\n<36> cctx -> M = arg ;
<1> static inline void bt_hci_lmp_acl_data(struct bt_hci_s *hci, uint16_t handle,\n<3> const uint8_t *data, int start, int len)\n<17> if (len + HCI_ACL_HDR_SIZE > sizeof(hci->acl_buf)) {\n<19> fprintf(stderr, "%s: can't take ACL packets %i bytes long\n",\n<27> memcpy(hci->acl_buf + HCI_ACL_HDR_SIZE, data, len);\n<35> pkt->dlen = cpu_to_le16(len);
<1> static void sdl_audio_callback(void *opaque, Uint8 *stream, int len)\n<5> VideoState *is = opaque;\n<21> while (len > 0) {\n<25> audio_size = audio_decode_frame(is, &pts);\n<31> is->audio_buf      = is->silence_buf;\n<39> update_sample_display(is, (int16_t *)is->audio_buf, audio_size);\n<49> len1 = is->audio_buf_size - is->audio_buf_index;\n<51> if (len1 > len)\n<53> len1 = len;\n<55> memcpy(stream, (uint8_t *)is->audio_buf + is->audio_buf_index, len1);\n<57> len -= len1;\n<59> stream += len1;\n<61> is->audio_buf_index += len1;
<1> void dtls1_stop_timer ( SSL * s ) {\n<2> memset ( & s -> d1 -> timeout , 0 , sizeof ( s -> d1 -> timeout ) ) ;\n<3> memset ( & s -> d1 -> next_timeout , 0 , sizeof ( s -> d1 -> next_timeout ) ) ;\n<5> BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT , 0 , & ( s -> d1 -> next_timeout ) ) ;
<1> static void prom_set(uint32_t* prom_buf, int index, const char *string, ...)\n<17> if (string == NULL) {\n<27> table_addr = sizeof(int32_t) * ENVP_NB_ENTRIES + index * ENVP_ENTRY_SIZE;\n<29> prom_buf[index] = tswap32(ENVP_ADDR + table_addr);\n<33> va_start(ap, string);\n<35> vsnprintf((char *)prom_buf + table_addr, ENVP_ENTRY_SIZE, string, ap);\n<37> va_end(ap);
<1> int ff_h264_execute_ref_pic_marking(H264Context *h, MMCO *mmco, int mmco_count)\n<129> if (h->short_ref[0] == h->cur_pic_ptr)\n<193> remove_short(h, h->short_ref[0]->frame_num, 0);\n<233> if (h->short_ref_count && h->short_ref[0] == h->cur_pic_ptr) {\n<265> if (h->short_ref_count)\n<269> h->short_ref_count * sizeof(H264Picture*));\n<287> (h->short_ref[0] == h->cur_pic_ptr) > h->sps.ref_frame_count) {
<1> static void net_socket_send(void *opaque)\n<5> NetSocketState *s = opaque;\n<23> if (err != EWOULDBLOCK)\n<27> } else if (size == 0) {\n<35> net_socket_write_poll(s, false);\n<39> qemu_set_fd_handler(s->listen_fd, net_socket_accept, NULL, s);\n<57> memset(s->buf, 0, sizeof(s->buf));\n<59> memset(s->nc.info_str, 0, sizeof(s->nc.info_str));\n<67> buf = buf1;\n<73> switch(s->state) {\n<77> l = 4 - s->index;\n<79> if (l > size)\n<81> l = size;\n<83> memcpy(s->buf + s->index, buf, l);\n<85> buf += l;\n<87> size -= l;\n<89> s->index += l;\n<107> l = s->packet_len - s->index;\n<109> if (l > size)\n<111> l = size;\n<113> if (s->index + l <= sizeof(s->buf)) {\n<115> memcpy(s->buf + s->index, buf, l);\n<119> fprintf(stderr, "serious error: oversized packet received,"\n<131> s->index += l;\n<133> buf += l;\n<135> size -= l;\n<139> qemu_send_packet(&s->nc, s->buf, s->packet_len);
<1> static int s390_ipl_init(SysBusDevice *dev)\n<5> S390IPLState *ipl = S390_IPL(dev);\n<103> kernel_size = load_elf(ipl->kernel, NULL, NULL, &pentry, NULL,\n<109> kernel_size = load_image_targphys(ipl->kernel, 0, ram_size);\n<113> if (kernel_size < 0) {\n<115> fprintf(stderr, "could not load kernel '%s'\n", ipl->kernel);\n<165> initrd_size = load_image_targphys(ipl->initrd, initrd_offset,\n<169> if (initrd_size == -1) {\n<171> fprintf(stderr, "qemu: could not load initrd '%s'\n",
<1> int ff_parse_packing_format(int *ret, const char *arg, void *log_ctx)\n<7> int planar = strtol(arg, &tail, 10);\n<9> if (*tail) {\n<11> planar = (strcmp(arg, "packed") != 0);\n<21> *ret = planar;
<1> static void open_help(void)
<1> static int check_refcounts_l2(BlockDriverState *bs, BdrvCheckResult *res,\n<25> if (bdrv_pread(bs->file, l2_offset, l2_table, l2_size) != l2_size)\n<103> if (refcount < 0) {\n<177> fprintf(stderr, "ERROR: I/O error in check_refcounts_l2\n");
<1> truncate_f(int argc, char **argv)\n<11> offset = cvtnum(argv[1]);\n<13> if (offset < 0) {\n<15> printf("non-numeric truncate argument -- %s\n", argv[1]);\n<25> if (ret < 0) {\n<27> printf("truncate: %s", strerror(ret));
<1> static void uninit(struct vf_instance *vf)\n<5> free(vf->priv);
<1> struct XenDevice *xen_be_find_xendev(const char *type, int dom, int dev)\n<9> TAILQ_FOREACH(xendev, &xendevs, next) {\n<19> if (strcmp(xendev->type, type) != 0)\n<23> return xendev;
<1> static int flic_read_header(AVFormatContext *s,\n<27> if (get_buffer(pb, header, FLIC_HEADER_SIZE) != FLIC_HEADER_SIZE)\n<35> speed = AV_RL32(&header[0x10]);\n<61> if (!st->codec->width || !st->codec->height)\n<71> st->codec->extradata = av_malloc(FLIC_HEADER_SIZE);\n<73> memcpy(st->codec->extradata, header, FLIC_HEADER_SIZE);\n<87> if (AV_RL16(&header[0x10]) == FLIC_CHUNK_MAGIC_1) {\n<103> av_free(st->codec->extradata);\n<107> st->codec->extradata = av_malloc(12);\n<109> memcpy(st->codec->extradata, header, 12);
<1> static BusState *qbus_find_recursive(BusState *bus, const char *name,\n<3> const char *bus_typename)\n<15> if (name && (strcmp(bus->name, name) != 0)) {\n<17> match = 0;\n<23> (strcmp(object_get_typename(OBJECT(bus)), bus_typename) != 0)) {\n<31> return bus;\n<43> ret = qbus_find_recursive(child, name, bus_typename);
<1> static AVStream * parse_media_type(AVFormatContext *s, AVStream *st, int sid,\n<13> if (!ff_guidcmp(subtype, ff_mediasubtype_cpfilters_processed) &&\n<59> if (!ff_guidcmp(formattype, ff_format_waveformatex)) {\n<63> if (ret < 0)\n<79> if (!memcmp(subtype + 4, (const uint8_t[]){FF_MEDIASUBTYPE_BASE_GUID}, 12)) {\n<81> st->codec->codec_id = ff_wav_codec_get_id(AV_RL32(subtype), st->codec->bits_per_coded_sample);\n<83> } else if (!ff_guidcmp(subtype, mediasubtype_mpeg1payload)) {\n<113> if (!ff_guidcmp(formattype, ff_format_videoinfo2)) {\n<119> } else if (!ff_guidcmp(formattype, ff_format_mpeg2_video)) {\n<131> if (count && ff_get_extradata(st->codec, pb, count) < 0) {\n<155> if (!memcmp(subtype + 4, (const uint8_t[]){FF_MEDIASUBTYPE_BASE_GUID}, 12)) {\n<157> st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, AV_RL32(subtype));\n<161> st->codec->codec_id = ff_codec_guid_get_id(ff_video_guids, subtype);
<1> xmlListPtr xmlListCreate ( xmlListDeallocator deallocator , xmlListDataCompare compare ) {\n<3> if ( NULL == ( l = ( xmlListPtr ) xmlMalloc ( sizeof ( xmlList ) ) ) ) {\n<7> memset ( l , 0 , sizeof ( xmlList ) ) ;\n<10> xmlFree ( l ) ;\n<13> l -> sentinel -> next = l -> sentinel ;\n<14> l -> sentinel -> prev = l -> sentinel ;\n<19> return l ;
<1> static ssize_t nic_receive(NetClientState *nc, const uint8_t * buf, size_t size)\n<73> } else if ((size > MAX_ETH_FRAME_SIZE + 4) && !(s->configuration[18] & BIT(3))) {\n<83> } else if (memcmp(buf, s->conf.macaddr.a, 6) == 0) {       /* !!! */\n<89> TRACE(RXTX, logout("%p received frame for me, len=%zu\n", s, size));\n<91> } else if (memcmp(buf, broadcast_macaddr, 6) == 0) {\n<95> TRACE(RXTX, logout("%p received broadcast, len=%zu\n", s, size));\n<97> rfd_status |= 0x0002;\n<99> } else if (buf[0] & 0x01) {\n<103> TRACE(RXTX, logout("%p received multicast, len=%zu,%s\n", s, size, nic_dump(buf, size)));\n<151> unsigned mcast_idx = compute_mcast_idx(buf);\n<171> nic_dump(buf, size)));\n<179> if (get_ru_state(s) != ru_ready) {\n<273> pci_dma_write(&s->dev, s->ru_base + s->ru_offset +
<1> static ssize_t test_block_write_func(QCryptoBlock *block,\n<5> size_t offset,\n<7> const uint8_t *buf,\n<9> size_t buflen,\n<15> Buffer *header = opaque;\n<23> memcpy(header->buffer + offset, buf, buflen);\n<25> header->offset = offset + buflen;\n<29> return buflen;
<1> static inline int msmpeg4_decode_block(MpegEncContext * s, DCTELEM * block,\n<31> level = msmpeg4_decode_dc(s, n, &dc_pred_dir);\n<49> if (level < 0){\n<51> fprintf(stderr, "dc overflow- block: %d qscale: %d//\n", n, s->qscale);\n<59> if (n < 4) {\n<63> if(level > 256*s->y_dc_scale){\n<65> fprintf(stderr, "dc overflow+ L qscale: %d//\n", s->qscale);\n<75> if(level > 256*s->c_dc_scale){\n<77> fprintf(stderr, "dc overflow+ C qscale: %d//\n", s->qscale);\n<209> if(s->qscale<8){\n<215> if(SHOW_UBITS(re, &s->gb, 1)) printf("cool a new vlc code ,contact the ffmpeg developers and upload the file\n");\n<455> if(((i+192 == 64 && level/qmul==-1) || s->error_resilience<=1) && left>=0){\n<457> fprintf(stderr, "ignoring overflow at %d %d\n", s->mb_x, s->mb_y);\n<463> fprintf(stderr, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);\n<493> mpeg4_pred_ac(s, block, n, dc_pred_dir);
<1> static inline void gen_intermediate_code_internal(SPARCCPU *cpu,\n<17> DisasContext dc1, *dc = &dc1;\n<31> memset(dc, 0, sizeof(DisasContext));\n<39> last_pc = dc->pc;\n<75> if (bp->pc == dc->pc) {\n<77> if (dc->pc != pc_start)\n<79> save_state(dc);\n<109> tcg_ctx.gen_opc_pc[lj] = dc->pc;\n<111> gen_opc_npc[lj] = dc->npc;\n<125> last_pc = dc->pc;\n<127> insn = cpu_ldl_code(env, dc->pc);\n<131> disas_sparc_insn(dc, insn);\n<181> if (!dc->is_br) {\n<183> if (dc->pc != DYNAMIC_PC &&\n<185> (dc->npc != DYNAMIC_PC && dc->npc != JUMP_PC)) {\n<189> gen_goto_tb(dc, 0, dc->pc, dc->npc);\n<193> if (dc->pc != DYNAMIC_PC) {\n<195> tcg_gen_movi_tl(cpu_pc, dc->pc);\n<199> save_npc(dc);
<1> QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)\n<5> char host[65], port[33], width[8], height[8];\n<19> if (local_err) {\n<29> if (strstart(filename, "mon:", &p)) {\n<31> filename = p;\n<35> if (strcmp(filename, "stdio") == 0) {\n<47> qemu_opt_set(opts, "signal", "off", &error_abort);\n<55> if (strcmp(filename, "null")    == 0 ||\n<57> strcmp(filename, "pty")     == 0 ||\n<59> strcmp(filename, "msmouse") == 0 ||\n<61> strcmp(filename, "braille") == 0 ||\n<63> strcmp(filename, "testdev") == 0 ||\n<65> strcmp(filename, "stdio")   == 0) {\n<67> qemu_opt_set(opts, "backend", filename, &error_abort);\n<69> return opts;\n<73> if (strstart(filename, "vc", &p)) {\n<77> if (*p == ':') {\n<79> if (sscanf(p+1, "%7[0-9]x%7[0-9]", width, height) == 2) {\n<83> qemu_opt_set(opts, "width", width, &error_abort);\n<85> qemu_opt_set(opts, "height", height, &error_abort);\n<87> } else if (sscanf(p+1, "%7[0-9]Cx%7[0-9]C", width, height) == 2) {\n<91> qemu_opt_set(opts, "cols", width, &error_abort);\n<93> qemu_opt_set(opts, "rows", height, &error_abort);\n<103> return opts;\n<107> if (strcmp(filename, "con:") == 0) {\n<109> qemu_opt_set(opts, "backend", "console", &error_abort);\n<111> return opts;\n<115> if (strstart(filename, "COM", NULL)) {\n<125> if (strstart(filename, "file:", &p)) {\n<135> if (strstart(filename, "pipe:", &p)) {\n<145> if (strstart(filename, "tcp:", &p) ||\n<147> strstart(filename, "telnet:", &p)) {\n<149> if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) {\n<151> host[0] = 0;\n<153> if (sscanf(p, ":%32[^,]%n", port, &pos) < 1)\n<159> qemu_opt_set(opts, "backend", "socket", &error_abort);\n<161> qemu_opt_set(opts, "host", host, &error_abort);\n<163> qemu_opt_set(opts, "port", port, &error_abort);\n<165> if (p[pos] == ',') {\n<167> if (qemu_opts_do_parse(opts, p+pos+1, NULL) != 0)\n<173> if (strstart(filename, "telnet:", &p))\n<181> if (strstart(filename, "udp:", &p)) {\n<185> if (sscanf(p, "%64[^:]:%32[^@,]%n", host, port, &pos) < 2) {\n<187> host[0] = 0;\n<189> if (sscanf(p, ":%32[^@,]%n", port, &pos) < 1) {\n<197> qemu_opt_set(opts, "host", host, &error_abort);\n<199> qemu_opt_set(opts, "port", port, &error_abort);\n<201> if (p[pos] == '@') {\n<203> p += pos + 1;\n<205> if (sscanf(p, "%64[^:]:%32[^,]%n", host, port, &pos) < 2) {\n<207> host[0] = 0;\n<209> if (sscanf(p, ":%32[^,]%n", port, &pos) < 1) {\n<217> qemu_opt_set(opts, "localaddr", host, &error_abort);\n<219> qemu_opt_set(opts, "localport", port, &error_abort);\n<223> return opts;\n<265> qemu_opts_del(opts);\n<267> return NULL;
<1> static void ppc_core99_init(MachineState *machine)\n<97> if (cpu == NULL) {\n<99> fprintf(stderr, "Unable to find PowerPC CPU definition\n");\n<291> if (ppc_boot_device == '\0') {\n<293> fprintf(stderr, "No valid boot device for Mac99 machine\n");
<1> void qmp_ringbuf_write(const char *device, const char *data,\n<41> if (has_format && (format == DATA_FORMAT_BASE64)) {\n<49> write_count = strlen(data);\n<55> ret = ringbuf_chr_write(chr, write_data, write_count);\n<59> if (write_data != (uint8_t *)data) {
<1> static int MP3lame_encode_frame(AVCodecContext *avctx,\n<3> unsigned char *frame, int buf_size, void *data)\n<7> Mp3AudioContext *s = avctx->priv_data;\n<95> len= mp3len(s->buffer, NULL, NULL);\n<99> if(len <= s->buffer_index){\n<101> memcpy(frame, s->buffer, len);\n<103> s->buffer_index -= len;\n<107> memmove(s->buffer, s->buffer+len, s->buffer_index);\n<117> return len;
<1> print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)\n<5> fprintf_ftype       fprintf = info->fprintf_func;\n<7> void *              stream = info->stream;\n<31> if (inst == 0) {\n<77> if (op->name == 0) {\n<79> fprintf (stream, ".short 0x%04lx", inst);\n<87> fprintf (stream, "%s", op->name);\n<91> switch (op->inst_type)\n<97> fprintf(stream, "\t%s, %s, %s", get_field_rd(inst), get_field_r1(inst), get_field_r2(inst));\n<103> fprintf(stream, "\t%s, %s, %s", get_field_rd(inst), get_field_r1(inst), get_field_imm(inst));\n<121> if (immval > 0 && info->symbol_at_address_func(immval, info)) {\n<123> fprintf (stream, "\t// ");\n<135> fprintf(stream, "\t%s, %s, %s", get_field_rd(inst), get_field_r1(inst), get_field_imm5(inst));\n<141> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_rfsl(inst));\n<147> fprintf(stream, "\t%s, %s", get_field_r1(inst), get_field_rfsl(inst));\n<153> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_special(inst, op));\n<159> fprintf(stream, "\t%s, %s", get_field_special(inst, op), get_field_r1(inst));\n<165> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_r1(inst));\n<171> fprintf(stream, "\t%s, %s", get_field_r1(inst), get_field_r2(inst));\n<177> fprintf(stream, "\t%s, %s", get_field_r1(inst), get_field_imm(inst));\n<201> if (immval > 0 && info->symbol_at_address_func(immval, info)) {\n<203> fprintf (stream, "\t// ");\n<209> fprintf (stream, "\t\t// ");\n<211> fprintf (stream, "%x", immval);\n<221> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_imm(inst));\n<243> if (info->symbol_at_address_func(immval, info)) {\n<245> fprintf (stream, "\t// ");\n<257> fprintf(stream, "\t%s", get_field_imm(inst));\n<279> if (immval > 0 && info->symbol_at_address_func(immval, info)) {\n<281> fprintf (stream, "\t// ");\n<285> } else if (op->inst_offset_type == INST_PC_OFFSET) {\n<287> fprintf (stream, "\t\t// ");\n<289> fprintf (stream, "%x", immval);\n<299> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_r2(inst));\n<305> fprintf(stream, "\t%s", get_field_r2(inst));\n<311> fprintf(stream, "\t%s", get_field_r1(inst));\n<317> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_r2(inst));\n<323> fprintf(stream, "\t%s, %s", get_field_rd(inst), get_field_imm15(inst));\n<331> fprintf(stream, "\t%s", get_field_rd(inst));\n<337> fprintf(stream, "\t%s", get_field_rfsl(inst));\n<345> fprintf (stream, "\tundecoded operands, inst is 0x%04lx", inst);
<1> static abi_ulong load_elf_interp(struct elfhdr * interp_elf_ex,\n<7> char bprm_buf[BPRM_BUF_SIZE])\n<23> bswap_ehdr(interp_elf_ex);\n<43> if (sizeof(struct elf_phdr) * interp_elf_ex->e_phnum > TARGET_PAGE_SIZE)\n<51> malloc(sizeof(struct elf_phdr) * interp_elf_ex->e_phnum);\n<55> if (!elf_phdata)\n<69> if (interp_elf_ex->e_phentsize != sizeof(struct elf_phdr)) {\n<71> free(elf_phdata);\n<79> i = interp_elf_ex->e_phnum * sizeof(struct elf_phdr);\n<81> if (interp_elf_ex->e_phoff + i <= BPRM_BUF_SIZE) {\n<83> memcpy(elf_phdata, bprm_buf + interp_elf_ex->e_phoff, i);\n<99> bswap_phdr(elf_phdata, interp_elf_ex->e_phnum);\n<169> for (i = 0; i < interp_elf_ex->e_phnum; i++) {\n<203> if (error == -1) {\n<209> free(elf_phdata);\n<247> free(elf_phdata);
<1> static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)\n<71> if (host_start < host_map_start) {\n<73> memset((void *)host_start, 0, host_map_start - host_start);
<1> static void check_itxfm(void)\n<59> ftx(coef, tx, txtp, sz, bit_depth);\n<63> for (sub = (txtp == 0) ? 1 : 2; sub <= sz; sub <<= 1) {\n<69> if (sub < sz) {\n<79> memcpy(subcoef0, coef, sz * sz * SIZEOF_COEF);\n<85> memcpy(dst0, dst, sz * sz * SIZEOF_PIXEL);\n<87> memcpy(dst1, dst, sz * sz * SIZEOF_PIXEL);\n<89> memcpy(subcoef1, subcoef0, sz * sz * SIZEOF_COEF);\n<91> call_ref(dst0, sz * SIZEOF_PIXEL, subcoef0, eob);\n<93> call_new(dst1, sz * SIZEOF_PIXEL, subcoef1, eob);\n<95> if (memcmp(dst0, dst1, sz * sz * SIZEOF_PIXEL) ||\n<97> !iszero(subcoef0, sz * sz * SIZEOF_COEF) ||\n<99> !iszero(subcoef1, sz * sz * SIZEOF_COEF))\n<101> fail();\n<105> bench_new(dst, sz * SIZEOF_PIXEL, coef, sz * sz);
<1> static void ptimer_reload(ptimer_state *s)\n<13> if (s->delta == 0 || s->period == 0) {\n<15> fprintf(stderr, "Timer with period zero, disabling\n");
<1> static inline void tcg_out_op(TCGContext *s, int opc, const TCGArg *args,\n<11> switch (opc) {\n<99> fprintf(stderr, "unimplemented jmp\n");\n<105> fprintf(stderr, "unimplemented br\n");\n<287> fprintf(stderr, "unimplemented brcond\n");\n<295> fprintf(stderr, "unimplemented qld\n");\n<301> fprintf(stderr, "unimplemented qld\n");\n<307> fprintf(stderr, "unimplemented qld\n");\n<313> fprintf(stderr, "unimplemented qld\n");\n<319> fprintf(stderr, "unimplemented qld\n");\n<325> fprintf(stderr, "unimplemented qld\n");\n<331> fprintf(stderr, "unimplemented qst\n");\n<337> fprintf(stderr, "unimplemented qst\n");\n<343> fprintf(stderr, "unimplemented qst\n");\n<453> fprintf(stderr, "unknown opcode 0x%x\n", opc);
<1> alloc_f(int argc, char **argv)\n<21> if (offset & 0x1ff) {\n<43> ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);\n<47> cvtstr(offset, s1, sizeof(s1));\n<51> retstr = ret ? "allocated" : "not allocated";\n<53> if (nb_sectors == 1)\n<55> printf("sector %s at offset %s\n", retstr, s1);
<1> avfilter_get_video_buffer_ref_from_arrays(uint8_t *data[4], int linesize[4], int perms,\n<9> AVFilterBufferRef *picref = av_mallocz(sizeof(AVFilterBufferRef));\n<13> if (!pic || !picref)\n<23> if (!(picref->video = av_mallocz(sizeof(AVFilterBufferRefVideoProps))))\n<49> memcpy(pic->data,        data,          sizeof(pic->data));\n<51> memcpy(pic->linesize,    linesize,      sizeof(pic->linesize));\n<53> memcpy(picref->data,     pic->data,     sizeof(picref->data));\n<55> memcpy(picref->linesize, pic->linesize, sizeof(picref->linesize));\n<59> return picref;
<1> static inline CopyRet copy_frame(AVCodecContext *avctx,\n<41> uint8_t *src = output->Ybuff;\n<231> bwidth = av_image_get_linesize(avctx->pix_fmt, width, 0);\n<261> dst     = priv->pic.data[0];\n<295> for (sY = 0; sY < height; dY++, sY++) {\n<297> memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth);
<1> static int pefromupx ( const char * src , uint32_t ssize , char * dst , uint32_t * dsize , uint32_t ep , uint32_t upx0 , uint32_t upx1 , uint32_t * magic , uint32_t dend ) {\n<6> if ( ( dst == NULL ) || ( src == NULL ) ) return 0 ;\n<23> realstuffsz = imports - dst ;\n<31> while ( CLI_ISCONTAINED ( dst , * dsize , pehdr , 2 ) && * pehdr ) {\n<39> if ( ! ( sections = checkpe ( dst , * dsize , pehdr , & valign , & sectcnt ) ) ) pehdr = NULL ;\n<49> if ( ! ( realstuffsz = pehdr - dst ) ) pehdr = NULL ;\n<51> if ( ! pehdr ) {\n<52> uint32_t rebsz = PESALIGN ( dend , 0x1000 ) ;\n<54> if ( ! ( newbuf = ( char * ) cli_calloc ( rebsz + 0x200 , sizeof ( char ) ) ) ) {\n<58> memcpy ( newbuf , HEADERS , 0xd0 ) ;\n<59> memcpy ( newbuf + 0xd0 , FAKEPE , 0x120 ) ;\n<60> memcpy ( newbuf + 0x200 , dst , dend ) ;\n<61> memcpy ( dst , newbuf , dend + 0x200 ) ;\n<62> free ( newbuf ) ;\n<63> cli_writeint32 ( dst + 0xd0 + 0x50 , rebsz + 0x1000 ) ;\n<64> cli_writeint32 ( dst + 0xd0 + 0x100 , rebsz ) ;\n<65> cli_writeint32 ( dst + 0xd0 + 0x108 , rebsz ) ;\n<93> if ( ! ( newbuf = ( char * ) cli_calloc ( foffset , sizeof ( char ) ) ) ) {\n<97> memcpy ( newbuf , HEADERS , 0xd0 ) ;\n<98> memcpy ( newbuf + 0xd0 , pehdr , 0xf8 + 0x28 * sectcnt ) ;\n<99> sections = pehdr + 0xf8 ;\n<105> offset2 = ( uint32_t ) cli_readint32 ( sections + 16 ) ;\n<106> if ( offset1 > foffset || offset2 > foffset || offset1 + offset2 > foffset ) {\n<107> free ( newbuf ) ;\n<111> if ( offset3 - upx0 > * dsize ) {\n<112> free ( newbuf ) ;\n<115> memcpy ( newbuf + offset1 , dst + offset3 - upx0 , offset2 ) ;\n<118> if ( foffset > * dsize + 8192 ) {\n<120> free ( newbuf ) ;\n<123> memcpy ( dst , newbuf , foffset ) ;\n<124> * dsize = foffset ;\n<125> free ( newbuf ) ;
<1> static int mjpeg_decode_init(AVCodecContext *avctx)\n<17> memset(&s2, 0, sizeof(MpegEncContext));\n<29> if (MPV_common_init(&s2) < 0)\n<33> s->scantable= s2.intra_scantable;\n<35> s->idct_put= s2.idct_put;\n<37> MPV_common_end(&s2);\n<73> if (avctx->flags & CODEC_FLAG_EXTERN_HUFF)\n<77> printf("mjpeg: using external huffman table\n");
<1> static int multiwrite_f(BlockBackend *blk, int argc, char **argv)\n<33> while ((c = getopt(argc, argv, "CqP:")) != EOF) {\n<81> for (i = optind; i < argc; i++) {\n<83> if (!strcmp(argv[i], ";")) {\n<85> nr_reqs++;\n<109> offset = cvtnum(argv[optind]);\n<111> if (offset < 0) {\n<113> printf("non-numeric offset argument -- %s\n", argv[optind]);\n<123> if (offset & 0x1ff) {\n<145> for (j = optind; j < argc; j++) {\n<147> if (!strcmp(argv[j], ";")) {\n<163> buf[i] = create_iovec(blk, &qiovs[i], &argv[optind], nr_iov, pattern);\n<205> if (cnt < 0) {\n<207> printf("aio_multiwrite failed: %s\n", strerror(-cnt));
<1> static void handle_raw_login ( char * packet , int len , struct query * q , int fd , int userid ) {\n<3> if ( len < 16 ) return ;\n<4> if ( userid < 0 || userid >= created_users ) return ;\n<6> if ( users [ userid ] . last_pkt + 60 < time ( NULL ) ) return ;\n<7> if ( debug >= 1 ) {\n<8> fprintf ( stderr , "IN login raw, len %d, from user %d\n" , len , userid ) ;\n<10> login_calculate ( myhash , 16 , password , users [ userid ] . seed + 1 ) ;\n<11> if ( memcmp ( packet , myhash , 16 ) == 0 ) {\n<13> users [ userid ] . last_pkt = time ( NULL ) ;\n<14> memcpy ( & ( users [ userid ] . q ) , q , sizeof ( struct query ) ) ;\n<15> tempin = ( struct sockaddr_in * ) & ( q -> from ) ;\n<16> memcpy ( & ( users [ userid ] . host ) , & ( tempin -> sin_addr ) , sizeof ( struct in_addr ) ) ;\n<17> user_set_conn_type ( userid , CONN_RAW_UDP ) ;\n<18> login_calculate ( myhash , 16 , password , users [ userid ] . seed - 1 ) ;\n<19> send_raw ( fd , myhash , 16 , userid , RAW_HDR_CMD_LOGIN , q ) ;
<1> static int oggvorbis_encode_frame(AVCodecContext *avctx, unsigned char *packets,\n<7> OggVorbisContext *s = avctx->priv_data;\n<71> while (vorbis_bitrate_flushpacket(&s->vd, &op)) {\n<77> if (op.bytes == 1 && op.e_o_s)\n<81> if (s->buffer_index + sizeof(ogg_packet) + op.bytes > BUFFER_SIZE) {\n<89> memcpy(s->buffer + s->buffer_index, &op, sizeof(ogg_packet));\n<91> s->buffer_index += sizeof(ogg_packet);\n<93> memcpy(s->buffer + s->buffer_index, op.packet, op.bytes);\n<95> s->buffer_index += op.bytes;\n<109> ogg_packet *op2 = (ogg_packet *)s->buffer;\n<111> op2->packet     = s->buffer + sizeof(ogg_packet);\n<123> if (pkt_size > buf_size) {\n<133> memcpy(packets, op2->packet, pkt_size);\n<135> s->buffer_index -= pkt_size + sizeof(ogg_packet);\n<137> memmove(s->buffer, s->buffer + pkt_size + sizeof(ogg_packet),\n<145> return pkt_size;
<1> static int display_end_segment(AVCodecContext *avctx, void *data,\n<7> AVSubtitle    *sub = data;\n<9> PGSSubContext *ctx = avctx->priv_data;\n<25> memset(sub, 0, sizeof(*sub));\n<69> if (ctx->picture.rle) {\n<77> if(decode_rle(avctx, sub, ctx->picture.rle, ctx->picture.rle_data_len) < 0)\n<87> sub->rects[0]->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n<91> memcpy(sub->rects[0]->pict.data[1], ctx->clut, sub->rects[0]->nb_colors * sizeof(uint32_t));
<1> static const char *ass_split_section(ASSSplitContext *ctx, const char *buf)\n<5> const ASSSection *section = &ass_sections[ctx->current_section];\n<29> } else if (section->format_header && !order) {\n<31> len = strlen(section->format_header);\n<33> if (strncmp(buf, section->format_header, len) || buf[len] != ':')\n<71> } else if (section->fields_header) {\n<73> len = strlen(section->fields_header);\n<75> if (!strncmp(buf, section->fields_header, len) && buf[len] == ':') {
<1> static void mainstone_common_init(ram_addr_t ram_size,\n<61> if (!dinfo) {\n<63> fprintf(stderr, "Two flash images must be given with the "\n<73> if (!pflash_cfi01_register(mainstone_flash_base[i],\n<87> fprintf(stderr, "qemu: Error registering flash memory.\n");\n<105> printf("map addr %p\n", &map);\n<107> pxa27x_register_keypad(cpu->kp, map, 0xe0);
<1> static int alloc_refcount_block(BlockDriverState *bs,\n<31> s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n<111> *refcount_block = NULL;\n<129> int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n<151> if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n<159> if (ret < 0) {\n<167> memset(*refcount_block, 0, s->cluster_size);\n<177> s->set_refcount(*refcount_block, block_index, 1);\n<185> ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n<215> if (ret < 0) {\n<223> memset(*refcount_block, 0, s->cluster_size);\n<233> qcow2_cache_entry_mark_dirty(bs, s->refcount_block_cache, *refcount_block);\n<357> uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n<367> size_to_clusters(s, table_size * sizeof(uint64_t));\n<419> if (new_table == NULL || new_blocks == NULL) {\n<433> s->refcount_table_size * sizeof(uint64_t));\n<451> uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n<487> cpu_to_be64s(&new_table[i]);\n<495> ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n<509> be64_to_cpus(&new_table[i]);\n<545> g_free(s->refcount_table);\n<547> s->refcount_table = new_table;\n<587> g_free(new_table);
<1> static void spapr_reallocate_hpt(sPAPRMachineState *spapr, int shift,\n<19> close_htab_fd(spapr);\n<69> spapr->htab = qemu_memalign(size, size);\n<71> if (!spapr->htab) {\n<83> memset(spapr->htab, 0, size);\n<91> for (i = 0; i < size / HASH_PTE_SIZE_64; i++) {\n<93> DIRTY_HPTE(HPTE(spapr->htab, i));
<1> static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb,\n<9> int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;\n<19> while (data_size) {\n<21> int duration = ass_get_duration(data);\n<25> end          = memchr(data, '\n', data_size);\n<27> size         = line_size = end ? end - data + 1 : data_size;\n<31> start        = data;\n<33> for (i = 0; i < 3; i++, start++)\n<35> if (!(start = memchr(start, ',', size - (start - data))))\n<37> return max_duration;\n<39> size -= start - data;\n<41> sscanf(data, "Dialogue: %d,", &layer);\n<49> memcpy(buffer + i, start, size - i);\n<85> data      += line_size;\n<87> data_size -= line_size;
<1> static int scsi_disk_emulate_mode_sense(SCSIDiskReq *r, uint8_t *outbuf)\n<25> DPRINTF("Mode Sense(%d) (page %d, xfer %zd, page_control %d)\n",\n<29> memset(outbuf, 0, r->req.cmd.xfer);\n<31> p = outbuf;\n<161> buflen = p - outbuf;
<1> static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n<5> BDRVSheepdogState *s = bs->opaque;\n<25> if (s->is_snapshot) {\n<39> dprintf("%s %s\n", sn_info->name, sn_info->id_str);\n<43> s->inode.vm_state_size = sn_info->vm_state_size;\n<45> s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n<53> strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n<75> ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n<89> ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n<93> if (ret < 0) {\n<95> error_report("failed to create inode for snapshot. %s",\n<97> strerror(errno));\n<105> inode = (SheepdogInode *)g_malloc(datalen);\n<109> ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n<115> if (ret < 0) {\n<117> error_report("failed to read new inode info. %s", strerror(errno));\n<125> memcpy(&s->inode, inode, datalen);
<5> ar = ( struct ar * ) ( a -> format -> data ) ;\n<12> if ( * p != '\n' ) goto bad_string_table ;\n<16> if ( p != ar -> strtab + size && * p != '\n' && * p != '`' ) goto bad_string_table ;\n<20> free ( ar -> strtab ) ;
<1> static int check_refcounts_l1(BlockDriverState *bs,\n<59> if (ret < 0) {\n<61> fprintf(stderr, "ERROR: I/O error in check_refcounts_l1\n");
<1> int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n<7> if (av_strstart(p, "pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,", &p)) {\n<15> int len = strlen(p) * 6 / 8;\n<17> char *buf = av_mallocz(len);\n<19> av_base64_decode(buf, p, len);
<1> int ff_mpeg_update_thread_context(AVCodecContext *dst,\n<9> MpegEncContext *s = dst->priv_data, *s1 = src->priv_data;\n<23> if (!s->context_initialized) {\n<25> memcpy(s, s1, sizeof(MpegEncContext));\n<31> s->bitstream_buffer      = NULL;\n<39> s->picture_range_start  += MAX_PICTURE_COUNT;\n<41> s->picture_range_end    += MAX_PICTURE_COUNT;\n<43> ff_MPV_common_init(s);\n<51> if (s->height != s1->height || s->width != s1->width || s->context_reinit) {\n<57> s->height = s1->height;\n<59> s->width  = s1->width;\n<61> if ((err = ff_MPV_common_frame_size_change(s)) < 0)\n<79> s->coded_picture_number = s1->coded_picture_number;\n<81> s->picture_number       = s1->picture_number;\n<83> s->input_picture_number = s1->input_picture_number;\n<87> memcpy(s->picture, s1->picture, s1->picture_count * sizeof(Picture));\n<91> (char *) &s1->last_picture_ptr - (char *) &s1->last_picture);\n<97> for (i = 0; i < s->picture_count; i++)\n<103> s->last_picture_ptr    = REBASE_PICTURE(s1->last_picture_ptr,    s, s1);\n<105> s->current_picture_ptr = REBASE_PICTURE(s1->current_picture_ptr, s, s1);\n<107> s->next_picture_ptr    = REBASE_PICTURE(s1->next_picture_ptr,    s, s1);\n<123> memcpy(&s->time_increment_bits, &s1->time_increment_bits,\n<125> (char *) &s1->shape - (char *) &s1->time_increment_bits);\n<145> if (s1->bitstream_buffer) {\n<157> s->bitstream_buffer_size = s1->bitstream_buffer_size;\n<159> memcpy(s->bitstream_buffer, s1->bitstream_buffer,\n<163> memset(s->bitstream_buffer + s->bitstream_buffer_size, 0,\n<173> memcpy(&s->progressive_sequence, &s1->progressive_sequence,\n<175> (char *) &s1->rtp_mode - (char *) &s1->progressive_sequence);
<1> static void v9fs_version(void *opaque)\n<17> trace_v9fs_version(pdu->tag, pdu->id, s->msize, version.data);\n<25> if (!strcmp(version.data, "9P2000.u")) {\n<27> s->proto_version = V9FS_PROTO_2000U;\n<29> } else if (!strcmp(version.data, "9P2000.L")) {\n<31> s->proto_version = V9FS_PROTO_2000L;\n<35> v9fs_string_sprintf(&version, "unknown");\n<41> offset += pdu_marshal(pdu, offset, "ds", s->msize, &version);\n<43> trace_v9fs_version_return(pdu->tag, pdu->id, s->msize, version.data);\n<51> v9fs_string_free(&version);
<1> static int grab_read_header(AVFormatContext *s1, AVFormatParameters *ap)\n<5> VideoData *s = s1->priv_data;\n<57> video_fd = open(s1->filename, O_RDWR);\n<59> if (video_fd < 0) {\n<61> av_log(s1, AV_LOG_ERROR, "%s: %s\n", s1->filename, strerror(errno));\n<69> if (ioctl(video_fd, VIDIOCGCAP, &s->video_cap) < 0) {\n<71> av_log(s1, AV_LOG_ERROR, "VIDIOCGCAP: %s\n", strerror(errno));\n<93> if (ioctl(video_fd, VIDIOCGWIN, &s->video_win, sizeof(s->video_win)) < 0) {\n<95> av_log(s1, AV_LOG_ERROR, "VIDIOCGWIN: %s\n", strerror(errno));\n<105> if(av_image_check_size(s->video_win.width, s->video_win.height, 0, s1) < 0)\n<145> audio.audio = 0;\n<147> ioctl(video_fd, VIDIOCGAUDIO, &audio);\n<149> memcpy(&s->audio_saved, &audio, sizeof(audio));\n<153> ioctl(video_fd, VIDIOCSAUDIO, &audio);\n<159> av_dlog(s1, "v4l: colour=%d hue=%d brightness=%d constrast=%d whiteness=%d\n",\n<183> if (j >= vformat_num)\n<209> if (ioctl(video_fd, VIDIOCSWIN, s->video_win) < 0) {\n<211> av_log(s1, AV_LOG_ERROR, "VIDIOCSWIN: %s\n", strerror(errno));\n<225> if (ioctl(video_fd, VIDIOCCAPTURE, &val) < 0) {\n<227> av_log(s1, AV_LOG_ERROR, "VIDIOCCAPTURE: %s\n", strerror(errno));\n<247> if ((unsigned char*)-1 == s->video_buf) {\n<249> av_log(s1, AV_LOG_ERROR, "mmap: %s\n", strerror(errno));\n<277> if (errno != EAGAIN) {\n<281> av_log(s1, AV_LOG_ERROR, "VIDIOCMCAPTURE: %s\n", strerror(errno));
<1> START_TEST(qdict_new_test)\n<17> fail_unless(qobject_type(QOBJECT(qdict)) == QTYPE_QDICT);\n<23> free(qdict);
<1> static void s390_init ( ram_addr_t ram_size , const char * boot_device , const char * kernel_filename , const char * kernel_cmdline , const char * initrd_filename , const char * cpu_model ) {\n<8> if ( ! kvm_enabled ( ) ) {\n<9> fprintf ( stderr , "The S390 target only works with KVM enabled\n" ) ;\n<35> if ( lduw_phys ( KERN_IMAGE_START ) != 0x0dd0 ) {\n<36> fprintf ( stderr , "Specified image is not an s390 boot image\n" ) ;\n<52> if ( kernel_cmdline ) {\n<53> cpu_physical_memory_rw ( KERN_PARM_AREA , ( uint8_t * ) kernel_cmdline , strlen ( kernel_cmdline ) , 1 ) ;\n<63> i < nb_nics ;\n<65> NICInfo * nd = & nd_table [ i ] ;\n<67> if ( ! nd -> model ) {\n<68> nd -> model = qemu_strdup ( "virtio" ) ;\n<70> if ( strcmp ( nd -> model , "virtio" ) ) {\n<71> fprintf ( stderr , "S390 only supports VirtIO nics\n" ) ;\n<72> exit ( 1 ) ;\n<75> qdev_set_nic_properties ( dev , nd ) ;
<1> AVBufferRef *av_buffer_alloc(int size)\n<11> data = av_malloc(size);\n<13> if (!data)\n<19> if(CONFIG_MEMORY_POISONING)\n<21> memset(data, 0x2a, size);\n<25> ret = av_buffer_create(data, size, av_buffer_default_free, NULL, 0);
<1> mips_mipssim_init (ram_addr_t ram_size, int vga_ram_size,\n<39> if (!env) {\n<41> fprintf(stderr, "Unable to find CPU definition\n");\n<67> bios_size = load_image(buf, phys_ram_base + bios_offset);\n<69> if ((bios_size < 0 || bios_size > BIOS_SIZE) && !kernel_filename) {\n<139> if (nd_table[0].model == NULL\n<141> || strcmp(nd_table[0].model, "mipsnet") == 0) {\n<145> mipsnet_init(0x4200, env->irq[2], &nd_table[0]);\n<147> } else if (strcmp(nd_table[0].model, "?") == 0) {\n<149> fprintf(stderr, "qemu: Supported NICs: mipsnet\n");\n<151> exit (1);\n<155> fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model);\n<157> exit (1);
<1> static void qcow2_invalidate_cache(BlockDriverState *bs, Error **errp)\n<5> BDRVQcow2State *s = bs->opaque;\n<31> s->cipher = NULL;\n<41> if (local_err) {\n<53> memset(s, 0, sizeof(BDRVQcow2State));
<271> *sd->data = h->sei.afd.active_format_description;\n<281> H264SEIA53Caption *a53 = &h->sei.a53_caption;\n<289> if (!sd)\n<295> memcpy(sd->data, a53->a53_caption, a53->a53_caption_size);\n<297> av_freep(&a53->a53_caption);
<1> envlist_free(envlist_t *envlist)\n<9> assert(envlist != NULL);\n<13> while (envlist->el_entries.lh_first != NULL) {\n<17> LIST_REMOVE(entry, ev_link);\n<21> free((char *)entry->ev_var);\n<23> free(entry);\n<27> free(envlist);
<1> static void usb_host_handle_control(USBDevice *udev, USBPacket *p,\n<9> USBHostDevice *s = USB_HOST_DEVICE(udev);\n<33> switch (request) {\n<67> if (value == 0) { /* clear halt */\n<85> r = usb_host_req_alloc(s, p, (request >> 8) & USB_DIR_IN, length + 8);\n<87> r->cbuf = data;\n<89> r->clen = length;\n<91> memcpy(r->buffer, udev->setup_buf, 8);\n<93> if (!r->in) {\n<95> memcpy(r->buffer + 8, r->cbuf, r->clen);\n<117> libusb_fill_control_transfer(r->xfer, s->dh, r->buffer,
<1> static int select_input_picture ( MpegEncContext * s ) {\n<16> if ( s -> picture_in_gop_number < s -> gop_size && skip_check ( s , s -> input_picture [ 0 ] , s -> next_picture_ptr ) ) {\n<28> ff_vbv_update ( s , 0 ) ;\n<54> s -> input_picture [ i ] -> b_frame_score = get_intra_count ( s , s -> input_picture [ i ] -> f . data [ 0 ] , s -> input_picture [ i - 1 ] -> f . data [ 0 ] , s -> linesize ) + 1 ;\n<70> b_frames = estimate_best_b_count ( s ) ;\n<108> no_output_pic : if ( s -> reordered_input_picture [ 0 ] ) {\n<141> memset ( & s -> new_picture , 0 , sizeof ( Picture ) ) ;
<1> int ff_rate_control_init(MpegEncContext *s)\n<139> p= s->avctx->stats_in;\n<141> for(i=-1; p; i++){\n<143> p= strchr(p+1, ';');\n<165> rce->pict_type= rce->new_pict_type=P_TYPE;\n<167> rce->qscale= rce->new_qscale=FF_QP2LAMBDA * 2;\n<169> rce->misc_bits= s->mb_num + 10;\n<171> rce->mb_var_sum= s->mb_num*100;\n<179> p= s->avctx->stats_in;\n<181> for(i=0; i<rcc->num_entries - s->max_b_frames; i++){\n<193> next= strchr(p, ';');\n<199> next++;\n<203> e= sscanf(p, " in:%d ", &picture_number);\n<207> assert(picture_number >= 0);\n<209> assert(picture_number < rcc->num_entries);\n<211> rce= &rcc->entry[picture_number];\n<215> e+=sscanf(p, " in:%*d out:%*d type:%d q:%f itex:%d ptex:%d mv:%d misc:%d fcode:%d bcode:%d mc-var:%d var:%d icount:%d skipcount:%d hbits:%d",\n<221> if(e!=14){\n<231> p= next;\n<309> rce.new_pict_type= rce.pict_type;\n<347> rcc->i_cplx_sum [rce.pict_type] += rce.i_tex_bits*rce.qscale;\n<349> rcc->p_cplx_sum [rce.pict_type] += rce.p_tex_bits*rce.qscale;\n<361> q= get_qscale(s, &rce, rcc->pass1_wanted_bits/rcc->pass1_rc_eq_output_sum, i);
<1> static int nprobe(AVFormatContext *s, uint8_t *enc_header, int size, const uint8_t *n_val)\n<13> if (!enc_header || !n_val)\n<21> if (!memcmp(&enc_header[pos], "EKB ", 4))\n<23> pos += 32;\n<27> if (AV_RB32(&enc_header[pos]) != oc->rid)\n<53> av_des_crypt(&av_des, oc->r_val, &enc_header[pos], 2, NULL, 1);\n<57> if (!rprobe(s, enc_header, oc->r_val))
<235> if (oldpic->data[1])\n<237> memcpy(newpic->data[1], oldpic->data[1], 256 * 4);
<1> static int vmdk_write_cid(BlockDriverState *bs, uint32_t cid)\n<13> memset(desc, 0, sizeof(desc));\n<15> if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {\n<23> tmp_str = strstr(desc,"parentCID");\n<25> pstrcpy(tmp_desc, sizeof(tmp_desc), tmp_str);\n<27> if ((p_name = strstr(desc,"CID")) != NULL) {\n<29> p_name += sizeof("CID");\n<31> snprintf(p_name, sizeof(desc) - (p_name - desc), "%x\n", cid);\n<33> pstrcat(desc, sizeof(desc), tmp_desc);\n<39> if (bdrv_pwrite_sync(bs->file, s->desc_offset, desc, DESC_SIZE) < 0) {
<1> static void monitor_handle_command(Monitor *mon, const char *cmdline)\n<65> if (*p == '\0')\n<75> len = p - pstart;\n<77> if (len > sizeof(cmdname) - 1)\n<79> len = sizeof(cmdname) - 1;\n<81> memcpy(cmdname, pstart, len);\n<91> if (compare_cmd(cmdname, cmd->name))\n<97> monitor_printf(mon, "unknown command: '%s'\n", cmdname);\n<163> ret = get_str(buf, sizeof(buf), &p);\n<165> if (ret < 0) {\n<197> str = qemu_malloc(strlen(buf) + 1);\n<199> pstrcpy(str, sizeof(buf), buf);
<1> static void omap2_inth_write(void *opaque, target_phys_addr_t addr,\n<83> if (value & 1)\n<85> fprintf(stderr, "%s: protection mode enable attempt\n",
<1> static int32_t scsi_send_command(SCSIDevice *d, uint32_t tag,\n<29> r = scsi_find_request(s, tag);\n<45> outbuf = (uint8_t *)r->iov.iov_base;\n<59> len = buf[4];\n<73> len = buf[8] | (buf[7] << 8);\n<89> len = buf[13] | (buf[12] << 8) | (buf[11] << 16) | (buf[10] << 24);\n<101> len = buf[9] | (buf[8] << 8) | (buf[7] << 16) | (buf[6] << 24);\n<145> switch (command) {\n<161> if (len < 4)\n<165> memset(outbuf, 0, 4);\n<169> if (s->sense == SENSE_NOT_READY && len >= 18) {\n<171> memset(outbuf, 0, 18);\n<225> switch (page_code) {\n<281> if (len < 4) {\n<293> DPRINTF("Inquiry EVPD[Serial number] buffer size %d\n", len);\n<295> l = MIN(len, strlen(s->drive_serial_str));\n<321> outbuf[r->iov.iov_len++] = l;\n<323> memcpy(&outbuf[r->iov.iov_len], s->drive_serial_str, l);\n<325> r->iov.iov_len += l;\n<341> int id_len = strlen(bdrv_get_device_name(s->dinfo->bdrv));\n<343> if (id_len > max_len)\n<345> id_len = max_len;\n<387> bdrv_get_device_name(s->dinfo->bdrv), id_len);\n<389> r->iov.iov_len += id_len;\n<429> if (len < 5) {\n<453> if(len > SCSI_MAX_INQUIRY_LEN)\n<455> len = SCSI_MAX_INQUIRY_LEN;\n<459> memset(outbuf, 0, len);\n<467> } else if (bdrv_get_type_hint(s->dinfo->bdrv) == BDRV_TYPE_CDROM) {\n<473> memcpy(&outbuf[16], "QEMU CD-ROM    ", 16);\n<479> memcpy(&outbuf[16], "QEMU HARDDISK  ", 16);\n<483> memcpy(&outbuf[8], "QEMU   ", 8);\n<485> memcpy(&outbuf[32], QEMU_VERSION, 4);\n<495> outbuf[4] = len - 5; /* Additional Length = (Len - 1) - 4 */\n<541> p = outbuf;\n<543> memset(p, 0, 4);\n<555> p += 4;\n<695> } else if ((page == 8 || page == 0x3f)) {\n<699> memset(p,0,20);\n<711> p += 20;\n<815> memset(outbuf, 0, 8);\n<933> switch(format) {\n<947> memset(outbuf, 0, 12);\n<993> memset(outbuf, 0, 8);\n<1029> if ((buf[1] & 31) == 0x10) {\n<1033> memset(outbuf, 0, len);\n<1075> r->iov.iov_len = len;\n<1097> if (len < 16)\n<1101> memset(outbuf, 0, 16);
<1> static void test_qemu_strtoull_negative(void)\n<9> const char *endptr = &f;\n<17> err = qemu_strtoull(str, &endptr, 0, &res);\n<25> g_assert(endptr == str + strlen(str));
<1> static void realview_init(ram_addr_t ram_size, int vga_ram_size,\n<33> if (!cpu_model)\n<35> cpu_model = "arm926";\n<39> if (strcmp(cpu_model, "arm11mpcore") == 0) {\n<41> ncpu = 4;\n<45> ncpu = 1;\n<53> env = cpu_init(cpu_model);\n<55> if (!env) {\n<57> fprintf(stderr, "Unable to find CPU definition\n");\n<147> if (index == -1) {\n<149> fprintf(stderr, "qemu: missing SecureDigital card\n");\n<171> if (drive_get_max_bus(IF_SCSI) > 0) {\n<173> fprintf(stderr, "qemu: too many SCSI bus\n");\n<193> for(n = 0; n < nb_nics; n++) {\n<195> nd = &nd_table[n];\n<197> if (!nd->model)\n<199> nd->model = done_smc ? "rtl8139" : "smc91c111";\n<201> if (strcmp(nd->model, "smc91c111") == 0) {\n<203> smc91c111_init(nd, 0x4e000000, pic[28]);\n<207> pci_nic_init(pci_bus, nd, -1);
<1> static void omap_mcbsp_writew(void *opaque, target_phys_addr_t addr,\n<19> if (s->tx_req > 3) {\n<49> printf("%s: Tx FIFO overrun\n", __FUNCTION__);
<1> static void seek_to_maindata(MPADecodeContext *s, long backstep)\n<17> ptr -= backstep;\n<25> init_get_bits(&s->gb, ptr, s->frame_size + backstep);
<1> static int gxf_probe(AVProbeData *p) {\n<7> if (p->buf_size < 16)\n<11> if (!memcmp(p->buf, startcode, sizeof(startcode)) &&\n<13> !memcmp(&p->buf[16 - sizeof(endcode)], endcode, sizeof(endcode)))\n<15> return AVPROBE_SCORE_MAX;\n<17> return 0;
<1> int ff_hevc_split_packet(HEVCContext *s, HEVCPacket *pkt, const uint8_t *buf, int length,\n<87> if (pkt->nals_allocated < pkt->nb_nals + 1) {\n<95> if (!tmp)\n<101> pkt->nals = tmp;\n<105> (new_size - pkt->nals_allocated) * sizeof(*pkt->nals));
<1> static void reset_contexts(SnowContext *s){\n<11> for(orientation=level ? 1:0; orientation<4; orientation++){\n<13> memset(s->plane[plane_index].band[level][orientation].state, 0, sizeof(s->plane[plane_index].band[level][orientation].state));\n<21> memset(s->mb_band.state, 0, sizeof(s->mb_band.state));\n<23> memset(s->mv_band[0].state, 0, sizeof(s->mv_band[0].state));\n<25> memset(s->mv_band[1].state, 0, sizeof(s->mv_band[1].state));\n<27> memset(s->header_state, 0, sizeof(s->header_state));
<1> static void glyph_position_destroy ( hb_glyph_position_t * g ) {\n<2> free ( g ) ;
<1> static int xan_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) {\n<4> XanContext * s = avctx -> priv_data ;\n<19> tmpptr = av_realloc ( s -> palettes , ( s -> palettes_count + 1 ) * AVPALETTE_SIZE ) ;\n<21> s -> palettes = tmpptr ;\n<53> if ( ( ret = ff_get_buffer ( avctx , & s -> current_frame ) ) ) {\n<59> memcpy ( s -> current_frame . data [ 1 ] , s -> palettes + s -> cur_palette * AVPALETTE_COUNT , AVPALETTE_SIZE ) ;
<1> static int decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) {\n<2> BMVDecContext * const c = avctx -> priv_data ;\n<31> i ++ ) c -> pal [ i ] = bytestream_get_be24 ( & c -> stream ) ;\n<48> if ( ( ret = ff_get_buffer ( avctx , & c -> pic ) ) < 0 ) {\n<52> if ( decode_bmv_frame ( c -> stream , pkt -> size - ( c -> stream - pkt -> data ) , c -> frame , scr_off ) ) {\n<56> memcpy ( c -> pic . data [ 1 ] , c -> pal , AVPALETTE_SIZE ) ;\n<58> outptr = c -> pic . data [ 0 ] ;\n<59> srcptr = c -> frame ;\n<61> i < avctx -> height ;\n<63> memcpy ( outptr , srcptr , avctx -> width ) ;\n<64> srcptr += avctx -> width ;\n<65> outptr += c -> pic . linesize [ 0 ] ;
<1> static int decode(AVCodecContext *avctx, void *data, int *got_sub, AVPacket *avpkt)\n<21> if (ctx->pktbuf->size < len) {\n<23> ret = av_buffer_realloc(&ctx->pktbuf, len);\n<29> len = ctx->pktbuf->size;\n<37> memcpy(ctx->pktbuf->data, avpkt->data, len);\n<39> bptr = ctx->pktbuf->data;\n<43> for (i  = 0; i < len; i += 3) {
<1> static void set_svc_parameters ( SvcContext * svc_ctx , vpx_codec_ctx_t * codec_ctx ) {\n<5> memset ( & svc_params , 0 , sizeof ( svc_params ) ) ;\n<22> vpx_codec_control ( codec_ctx , VP9E_SET_SVC_PARAMETERS , & svc_params ) ;
<1> static int qemu_rbd_open(BlockDriverState *bs, const char *filename, int flags)\n<17> if (qemu_rbd_parsename(filename, pool, sizeof(pool),\n<39> r = rados_create(&s->cluster, NULL);\n<41> if (r < 0) {\n<51> if (strstr(conf, "conf=") == NULL) {\n<53> r = rados_conf_read_file(s->cluster, NULL);\n<55> if (r < 0) {\n<69> if (conf[0] != '\0') {\n<71> r = qemu_rbd_set_conf(s->cluster, conf);\n<131> bs->read_only = (s->snap != NULL);
<1> int av_probe_input_buffer2(AVIOContext *pb, AVInputFormat **fmt,\n<9> AVProbeData pd = { filename ? filename : "" };\n<83> if ((ret = av_reallocp(&buf, probe_size + AVPROBE_PADDING_SIZE)) < 0)\n<107> if (buf_offset < offset)\n<111> pd.buf_size = buf_offset - offset;\n<113> pd.buf = &buf[offset];\n<117> memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n<123> *fmt = av_probe_input_format2(&pd, 1, &score);
<1> static ssize_t vnc_tls_pull(gnutls_transport_ptr_t transport,\n<3> void *data,\n<5> size_t len) {\n<7> struct VncState *vs = (struct VncState *)transport;\n<15> ret = recv(vs->csock, data, len, 0);\n<17> if (ret < 0) {\n<19> if (errno == EINTR)
<1> static void probe_codec(AVFormatContext *s, AVStream *st, const AVPacket *pkt)\n<5> if(st->codec->codec_id == CODEC_ID_PROBE){\n<7> AVProbeData *pd = &st->probe_data;\n<15> pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);\n<17> memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);\n<19> pd->buf_size += pkt->size;\n<21> memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n<25> if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){
<1> static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n<41> } else if (tap->has_helper) {\n<49> snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n<57> if (strcmp(downscript, "no") != 0) {\n<59> snprintf(s->down_script, sizeof(s->down_script), "%s", downscript);\n<61> snprintf(s->down_script_arg, sizeof(s->down_script_arg),
<1> void ide_init2(IDEBus *bus, DriveInfo *hd0, DriveInfo *hd1,\n<17> for(i = 0; i < 2; i++) {\n<19> s = bus->ifs + i;\n<67> bdrv_set_change_cb(s->bs, cdrom_change_cb, s);\n<75> strncpy(s->drive_serial_str, drive_get_serial(s->bs),\n<79> if (strlen(s->drive_serial_str) == 0)\n<81> snprintf(s->drive_serial_str, sizeof(s->drive_serial_str),\n<83> "QM%05d", s->drive_serial);\n<89> ide_reset(s);
<1> static AVStream *add_av_stream1(FFStream *stream, AVCodecContext *codec, int copy)\n<11> if (!fst)\n<15> if (copy) {\n<17> fst->codec= avcodec_alloc_context();\n<19> memcpy(fst->codec, codec, sizeof(AVCodecContext));\n<21> if (codec->extradata_size) {\n<23> fst->codec->extradata = av_malloc(codec->extradata_size);\n<25> memcpy(fst->codec->extradata, codec->extradata,\n<47> av_set_pts_info(fst, 33, 1, 90000);\n<51> stream->streams[stream->nb_streams++] = fst;\n<53> return fst;
<1> static uint64_t l2x0_priv_read(void *opaque, target_phys_addr_t offset,\n<13> if (offset >= 0x730 && offset < 0x800) {\n<19> switch (offset) {\n<73> fprintf(stderr, "l2x0_priv_read: Bad offset %x\n", (int)offset);
<1> static void sd_lock_command(SDState *sd)\n<13> set_pwd = sd->data[0] & 0x01;\n<29> if (!(sd->card_status & CARD_IS_LOCKED) || sd->blk_len > 1 ||\n<41> memset(sd->wp_groups, 0, sizeof(int) * (sd->size >>\n<53> fprintf(stderr, "SD: Card force-erased by CMD42\n");\n<63> pwd_len <= sd->pwd_len ||\n<75> if (sd->pwd_len && memcmp(sd->pwd, sd->data + 2, sd->pwd_len)) {\n<77> sd->card_status |= LOCK_UNLOCK_FAILED;\n<79> return;\n<85> pwd_len -= sd->pwd_len;\n<87> if ((pwd_len && !set_pwd) ||\n<91> (lock && !sd->pwd_len && !set_pwd) ||\n<107> if (set_pwd) {\n<109> memcpy(sd->pwd, sd->data + 2 + sd->pwd_len, pwd_len);\n<111> sd->pwd_len = pwd_len;
<1> int ff_pulse_audio_get_devices(AVDeviceInfoList *devices, const char *server, int output)\n<17> PulseAudioDeviceList dev_list = { 0 };\n<23> dev_list.output = output;\n<25> dev_list.devices = devices;\n<83> pa_op = pa_context_get_sink_info_list(pa_ctx, pulse_audio_sink_device_cb, &dev_list);\n<87> pa_op = pa_context_get_source_info_list(pa_ctx, pulse_audio_source_device_cb, &dev_list);\n<99> if (dev_list.error_code < 0)\n<125> for (i = 0; i < devices->nb_devices; i++) {\n<127> if (!strcmp(devices->devices[i]->device_name, dev_list.default_device)) {\n<129> devices->default_device = i;\n<141> av_free(dev_list.default_device);
<1> static ssize_t vc_sendv_compat(VLANClientState *vc, const struct iovec *iov,\n<15> for (i = 0; i < iovcnt; i++) {\n<21> len = MIN(sizeof(buffer) - offset, iov[i].iov_len);\n<23> memcpy(buffer + offset, iov[i].iov_base, len);\n<25> offset += len;
<1> static int posix_aio_init(void)\n<37> if (pipe(fds) == -1) {\n<39> fprintf(stderr, "failed to create pipe\n");\n<63> memset(&ai, 0, sizeof(ai));\n<69> qemu_paio_init(&ai);
<79> if ((i > 0) && !(frame_flags & 0x01)) {\n<81> memcpy (s->strips[i].v4_codebook, s->strips[i-1].v4_codebook,\n<85> memcpy (s->strips[i].v1_codebook, s->strips[i-1].v1_codebook,\n<93> result = cinepak_decode_strip (s, &s->strips[i], s->data, strip_size);
<29> for (i = 0; i < ARRAY_SIZE(valid_param_list); i++) {\n<33> strlen(valid_param_list[i])))
<1> do_socket_read(GIOChannel *source,\n<75> mhHeader.type = ntohl(mhHeader.type);\n<77> mhHeader.reader_id = ntohl(mhHeader.reader_id);\n<79> mhHeader.length = ntohl(mhHeader.length);\n<81> if (verbose) {\n<83> printf("Header: type=%d, reader_id=%u length=%d (0x%x)\n",\n<91> switch (mhHeader.type) {\n<103> to_read = mhHeader.length;\n<111> fprintf(stderr, "Unexpected message of type 0x%X\n", mhHeader.type);\n<127> if (verbose) {\n<129> printf(" recv APDU: ");\n<153> if (verbose) {\n<155> printf(" send response: ");\n<193> if (error_msg->code == VSC_SUCCESS) {\n<215> printf("warning: qemu refused to add reader\n");
<1> void x86_cpu_list (FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...),\n<3> const char *optarg)\n<7> unsigned char model = !strcmp("?model", optarg);\n<9> unsigned char dump = !strcmp("?dump", optarg);\n<11> unsigned char cpuid = !strcmp("?cpuid", optarg);\n<43> for (def = x86_defs; def; def = def->next) {\n<47> if (model || dump) {\n<49> (*cpu_fprintf)(f, "x86 %16s  %-48s\n", buf, def->model_id);\n<53> (*cpu_fprintf)(f, "x86 %16s\n", buf);\n<57> if (dump) {\n<59> memcpy(buf, &def->vendor1, sizeof (def->vendor1));\n<61> memcpy(buf + 4, &def->vendor2, sizeof (def->vendor2));\n<63> memcpy(buf + 8, &def->vendor3, sizeof (def->vendor3));\n<65> buf[12] = '\0';
<1> static int bdrv_prwv_co(BlockDriverState *bs, int64_t offset,\n<39> if (bs->io_limits_enabled) {\n<41> fprintf(stderr, "Disabling I/O throttling on '%s' due "\n<43> "to synchronous I/O.\n", bdrv_get_device_name(bs));
<1> static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) {\n<2> EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ;\n<34> case EVP_CTRL_AEAD_SET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE ) return 0 ;\n<35> if ( ptr != NULL ) {\n<36> memcpy ( actx -> tag , ptr , arg ) ;\n<37> actx -> tag_len = arg ;\n<40> case EVP_CTRL_AEAD_GET_TAG : if ( arg <= 0 || arg > POLY1305_BLOCK_SIZE || ! ctx -> encrypt ) return 0 ;\n<41> memcpy ( ptr , actx -> tag , arg ) ;\n<46> unsigned char * aad = ptr , temp [ POLY1305_BLOCK_SIZE ] ;\n<47> len = aad [ EVP_AEAD_TLS1_AAD_LEN - 2 ] << 8 | aad [ EVP_AEAD_TLS1_AAD_LEN - 1 ] ;\n<48> if ( ! ctx -> encrypt ) {\n<50> memcpy ( temp , aad , EVP_AEAD_TLS1_AAD_LEN - 2 ) ;\n<51> aad = temp ;
<1> timer_write(void *opaque, target_phys_addr_t addr,\n<9> uint32_t value = val64;\n<13> switch (addr)\n<25> D(printf ("RW_TMR0_CTRL=%x\n", value));\n<27> t->rw_tmr0_ctrl = value;\n<41> D(printf ("RW_TMR1_CTRL=%x\n", value));\n<43> t->rw_tmr1_ctrl = value;\n<51> D(printf ("RW_INTR_MASK=%x\n", value));\n<53> t->rw_intr_mask = value;
<1> static void icp_pic_write(void *opaque, target_phys_addr_t offset,\n<11> switch (offset >> 2) {\n<63> printf ("icp_pic_write: Bad register offset 0x%x\n", (int)offset);
<1> void qdev_prop_set_globals_for_type(DeviceState *dev, const char *typename,\n<11> QTAILQ_FOREACH(prop, &global_props, next) {\n<17> if (strcmp(typename, prop->driver) != 0) {
<1> static int stream_component_open(PlayerState *is, int stream_index)\n<87> is->sdl_sample_rate = avctx->sample_rate;\n<95> if (!avctx->channel_layout) {\n<97> fprintf(stderr, "unable to guess channel layout\n");\n<113> is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout);\n<131> if (SDL_OpenAudio(&wanted_spec, &spec) < 0) {\n<133> fprintf(stderr, "SDL_OpenAudio: %s\n", SDL_GetError());\n<157> switch (avctx->codec_type) {\n<185> memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));
<1> static int archive_read_format_cpio_read_header ( struct archive_read * a , struct archive_entry * entry ) {\n<20> if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n<31> if ( archive_entry_filetype ( entry ) == AE_IFLNK ) {\n<33> if ( h == NULL ) return ( ARCHIVE_FATAL ) ;\n<34> if ( archive_entry_copy_symlink_l ( entry , ( const char * ) h , ( size_t ) cpio -> entry_bytes_remaining , sconv ) != 0 ) {\n<35> if ( errno == ENOMEM ) {\n<45> if ( namelength == 11 && strcmp ( ( const char * ) h , "TRAILER!!!" ) == 0 ) {\n<46> archive_clear_error ( & a -> archive ) ;\n<47> return ( ARCHIVE_EOF ) ;\n<49> if ( record_hardlink ( a , cpio , entry ) != ARCHIVE_OK ) {
<1> static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)\n<13> r = nand_getio(s->nand);\n<21> DNAND(printf("%s addr=%x r=%x\n", __func__, addr, r));\n<23> return r;
<1> static int xvid_strip_vol_header(AVCodecContext *avctx,\n<3> AVPacket *pkt,\n<15> if( pkt->data[i] == 0x00 &&\n<17> pkt->data[i+1] == 0x00 &&\n<19> pkt->data[i+2] == 0x01 &&\n<21> pkt->data[i+3] == 0xB6 ) {\n<33> if( vo_len > 0 ) {\n<37> if( avctx->extradata == NULL ) {\n<39> avctx->extradata = av_malloc(vo_len);\n<41> memcpy(avctx->extradata, pkt->data, vo_len);\n<43> avctx->extradata_size = vo_len;\n<51> memmove(pkt->data, &pkt->data[vo_len], frame_len - vo_len);
<1> static int oggvorbis_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n<27> buffer = vorbis_analysis_buffer(&s->vd, samples);\n<29> for (c = 0; c < channels; c++) {\n<37> samples * sizeof(*buffer[c]));
<1> qemu_inject_x86_mce(CPUState *cenv, int bank, uint64_t status,\n<51> fprintf(stderr, "injects mce exception while previous "
<1> static void qemu_rdma_dump_id(const char *who, struct ibv_context *verbs)\n<9> if (ibv_query_port(verbs, 1, &port)) {\n<19> printf("%s RDMA Device opened: kernel name %s "\n<41> (port.link_layer == IBV_LINK_LAYER_INFINIBAND) ? "Infiniband" :\n<43> ((port.link_layer == IBV_LINK_LAYER_ETHERNET)
<1> static int nbd_send_rep_list(int csock, NBDExport *exp)\n<11> name_len = strlen(exp->name);\n<43> len = cpu_to_be32(name_len + sizeof(len));\n<53> len = cpu_to_be32(name_len);\n<63> if (write_sync(csock, exp->name, name_len) != name_len) {
<1> static int yuv4_write_packet(AVFormatContext *s, AVPacket *pkt)\n<7> AVIOContext *pb = s->pb;\n<33> if (yuv4_generate_header(s, buf2) < 0) {\n<43> avio_write(pb, buf2, strlen(buf2));\n<133> avio_write(pb, ptr, width);\n<165> avio_write(pb, ptr1, width);\n<173> avio_write(pb, ptr2, width);
<1> static int omap_dma_ch_reg_write(struct omap_dma_s *s,\n<3> int ch, int reg, uint16_t value) {\n<23> if (s->ch[ch].port[0] >= omap_dma_port_last)\n<25> printf("%s: invalid DMA port %i\n", __FUNCTION__,\n<29> if (s->ch[ch].port[1] >= omap_dma_port_last)\n<31> printf("%s: invalid DMA port %i\n", __FUNCTION__,\n<35> if ((value & 3) == 3)\n<37> printf("%s: bad data_type for DMA channel %i\n", __FUNCTION__, ch);
<1> void *kvmppc_create_spapr_tce(uint32_t liobn, uint32_t window_size, int *pfd)\n<7> .liobn = liobn,\n<39> if (fd < 0) {\n<41> fprintf(stderr, "KVM: Failed to create TCE table for liobn 0x%x\n",\n<59> if (table == MAP_FAILED) {\n<61> fprintf(stderr, "KVM: Failed to map TCE table for liobn 0x%x\n",
<1> int jbig2_decode_text_region ( Jbig2Ctx * ctx , Jbig2Segment * segment , const Jbig2TextRegionParams * params , const Jbig2SymbolDict * const * dicts , const int n_dicts , Jbig2Image * image , const byte * data , const size_t size , Jbig2ArithCx * GR_stats , Jbig2ArithState * as , Jbig2WordStream * ws ) {\n<252> if ( refimage == NULL ) {\n<260> rparams . GRTEMPLATE = params -> SBRTEMPLATE ;\n<261> rparams . reference = IBO ;\n<262> rparams . DX = ( RDW >> 1 ) + RDX ;\n<263> rparams . DY = ( RDH >> 1 ) + RDY ;\n<264> rparams . TPGRON = 0 ;\n<265> memcpy ( rparams . grat , params -> sbrat , 4 ) ;\n<266> code = jbig2_decode_refinement_region ( ctx , segment , & rparams , as , refimage , GR_stats ) ;
<1> static int spapr_vio_check_reg(VIOsPAPRDevice *sdev, VIOsPAPRDeviceInfo *info)\n<33> if (other_sdev != sdev && other_sdev->reg == sdev->reg) {\n<35> fprintf(stderr, "vio: %s and %s devices conflict at address %#x\n",
<1> static const mon_cmd_t *monitor_parse_command(Monitor *mon,\n<31> if (!p)\n<53> while (qemu_isspace(*p)) {\n<55> p++;\n<85> typestr = key_get_info(typestr, &key);\n<87> if (!typestr)\n<95> switch(c) {\n<109> while (qemu_isspace(*p))\n<111> p++;\n<117> if (*p == '\0') {\n<127> ret = get_str(buf, sizeof(buf), &p);\n<187> p++;\n<191> if (!*p)\n<195> if (get_str(buf, sizeof(buf), &p) < 0) {\n<227> p++;\n<229> if (*p == '/') {\n<233> p++;\n<245> p++;\n<271> format = *p++;\n<279> p++;\n<287> p++;\n<295> p++;\n<305> p++;\n<319> if (*p != '\0' && !qemu_isspace(*p)) {\n<387> while (qemu_isspace(*p))\n<389> p++;\n<395> if (*p == '\0') {\n<405> if (*p == '.') {\n<407> p++;\n<409> while (qemu_isspace(*p))\n<411> p++;\n<427> if (get_expr(mon, &val, &p))\n<471> while (qemu_isspace(*p)) {\n<473> p++;\n<481> if (*p == '\0') {\n<489> val = strtosz(p, &end);\n<501> p = end;\n<515> while (qemu_isspace(*p))\n<517> p++;\n<523> if (*p == '\0') {\n<531> if (get_double(mon, &val, &p) < 0) {\n<537> if (p[0] && p[1] == 's') {\n<543> val /= 1e3; p += 2; break;\n<547> val /= 1e6; p += 2; break;\n<551> val /= 1e9; p += 2; break;\n<557> if (*p && !qemu_isspace(*p)) {\n<583> p++;\n<587> beg = p;\n<589> while (qemu_isgraph(*p)) {\n<591> p++;\n<595> if (p - beg == 2 && !memcmp(beg, "on", p - beg)) {\n<597> val = true;\n<599> } else if (p - beg == 3 && !memcmp(beg, "off", p - beg)) {\n<601> val = false;\n<605> monitor_printf(mon, "Expected 'on' or 'off'\n");\n<611> qdict_put(qdict, key, qbool_from_bool(val));\n<621> const char *tmp = p;\n<637> p++;\n<639> if (*p == '-') {\n<641> p++;\n<643> if(c != *p) {\n<665> p = tmp;\n<671> p++;\n<693> while (qemu_isspace(*p)) {\n<695> p++;\n<699> if (*typestr == '?') {\n<703> if (*p == '\0') {\n<713> len = strlen(p);\n<715> if (len <= 0) {\n<725> qdict_put(qdict, key, qstring_from_str(p));\n<727> p += len;\n<743> g_free(key);\n<745> key = NULL;\n<753> p++;\n<773> g_free(key);\n<775> return NULL;
<1> static void ehci_advance_periodic_state(EHCIState *ehci)\n<17> switch(ehci_get_state(ehci, async)) {\n<87> fprintf(stderr, "ehci: Bad periodic state %d. "
<1> static void kvmclock_vm_state_change(void *opaque, int running,\n<43> if (ret < 0) {\n<45> fprintf(stderr, "KVM_SET_CLOCK failed: %s\n", strerror(ret));\n<65> if (ret != -EINVAL) {\n<67> fprintf(stderr, "%s: %s\n", __func__, strerror(-ret));\n<99> if (ret < 0) {\n<101> fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(ret));
<1> static int xen_host_pci_get_value(XenHostPCIDevice *d, const char *name,\n<25> if (fd == -1) {\n<27> XEN_HOST_PCI_LOG("Error: Can't open %s: %s\n", path, strerror(errno));\n<29> return -errno;
<1> static int send_response(GAState *s, QObject *payload)\n<13> g_assert(payload && s->channel);\n<19> if (!payload_qstr) {\n<29> buf = qstring_get_str(payload_qstr);\n<31> status = ga_channel_write_all(s->channel, buf, strlen(buf));
<1> static void test_rfc822_parse_quoted_string ( void ) {\n<30> i < N_ELEMENTS ( tests ) ;\n<32> rfc822_parser_init ( & parser , ( const void * ) tests [ i ] . input , strlen ( tests [ i ] . input ) , NULL ) ;\n<34> test_assert_idx ( tests [ i ] . ret < 0 || strcmp ( tests [ i ] . output , str_c ( str ) ) == 0 , i ) ;
<1> static void do_log(int argc, const char **argv)\n<9> if (argc != 2)\n<13> if (!strcmp(argv[1], "none")) {\n<15> mask = 0;\n<19> mask = cpu_str_to_log_mask(argv[1]);\n<21> if (!mask) {\n<33> cpu_set_log(mask);
<1> static void parse_numa_node(NumaNodeOptions *node, QemuOpts *opts, Error **errp)\n<95> if (node->has_mem) {\n<99> const char *mem_str = qemu_opt_get(opts, "mem");\n<103> if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n<105> mem_size <<= 20;
<1> static int check_host_key_knownhosts(BDRVSSHState *s,\n<41> if (!knh) {\n<53> home = getenv("HOME");\n<57> knh_file = g_strdup_printf("%s/.ssh/known_hosts", home);
<1> void xps_parse_path ( xps_document * doc , const fz_matrix * ctm , char * base_uri , xps_resource * dict , fz_xml * root ) {\n<16> fz_xml * fill_tag = NULL ;\n<17> fz_xml * stroke_tag = NULL ;\n<52> stroke_line_join_att = fz_xml_att ( root , "StrokeLineJoin" ) ;\n<57> node ;\n<59> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.RenderTransform" ) ) transform_tag = fz_xml_down ( node ) ;\n<60> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.OpacityMask" ) ) opacity_mask_tag = fz_xml_down ( node ) ;\n<61> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Clip" ) ) clip_tag = fz_xml_down ( node ) ;\n<62> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Fill" ) ) fill_tag = fz_xml_down ( node ) ;\n<63> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Stroke" ) ) stroke_tag = fz_xml_down ( node ) ;\n<64> if ( ! strcmp ( fz_xml_tag ( node ) , "Path.Data" ) ) data_tag = fz_xml_down ( node ) ;\n<72> xps_resolve_resource_reference ( doc , dict , & fill_att , & fill_tag , & fill_uri ) ;\n<73> xps_resolve_resource_reference ( doc , dict , & stroke_att , & stroke_tag , & stroke_uri ) ;\n<75> if ( ! data_att && ! data_tag ) return ;\n<76> if ( fill_tag && ! strcmp ( fz_xml_tag ( fill_tag ) , "SolidColorBrush" ) ) {\n<77> fill_opacity_att = fz_xml_att ( fill_tag , "Opacity" ) ;\n<78> fill_att = fz_xml_att ( fill_tag , "Color" ) ;\n<79> fill_tag = NULL ;\n<81> if ( stroke_tag && ! strcmp ( fz_xml_tag ( stroke_tag ) , "SolidColorBrush" ) ) {\n<82> stroke_opacity_att = fz_xml_att ( stroke_tag , "Opacity" ) ;\n<83> stroke_att = fz_xml_att ( stroke_tag , "Color" ) ;\n<84> stroke_tag = NULL ;\n<86> if ( stroke_att || stroke_tag ) {\n<100> if ( stroke_line_join_att ) {\n<101> if ( ! strcmp ( stroke_line_join_att , "Miter" ) ) stroke -> linejoin = FZ_LINEJOIN_MITER_XPS ;\n<102> if ( ! strcmp ( stroke_line_join_att , "Round" ) ) stroke -> linejoin = FZ_LINEJOIN_ROUND ;\n<103> if ( ! strcmp ( stroke_line_join_att , "Bevel" ) ) stroke -> linejoin = FZ_LINEJOIN_BEVEL ;\n<136> if ( stroke_path != path && ( fill_att || fill_tag ) ) {\n<153> xps_parse_brush ( doc , & local_ctm , & area , fill_uri , dict , fill_tag ) ;
<1> int uuid_is_null(const uuid_t uu)\n<5> uuid_t null_uuid = { 0 };\n<7> return memcmp(uu, null_uuid, sizeof(uuid_t)) == 0;
<1> static int load_uboot_image(const char *filename, hwaddr *ep, hwaddr *loadaddr,\n<45> bswap_uboot_header(hdr);\n<55> if (hdr->ih_type != image_type) {\n<57> fprintf(stderr, "Wrong image type %d, expected %d\n", hdr->ih_type,\n<69> switch (hdr->ih_type) {\n<89> switch (hdr->ih_comp) {\n<151> fprintf(stderr, "Unsupported u-boot image type %d\n", hdr->ih_type);\n<163> if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n<165> fprintf(stderr, "Error reading file\n");\n<195> if (bytes < 0) {\n<197> fprintf(stderr, "Unable to decompress gzipped image!\n");
<1> build_rsdp(GArray *rsdp_table, GArray *linker, unsigned rsdt)\n<5> AcpiRsdpDescriptor *rsdp = acpi_data_push(rsdp_table, sizeof *rsdp);\n<15> memcpy(&rsdp->signature, "RSD PTR ", sizeof(rsdp->signature));\n<17> memcpy(rsdp->oem_id, ACPI_BUILD_APPNAME6, sizeof(rsdp->oem_id));\n<43> bios_linker_loader_add_checksum(linker, ACPI_BUILD_RSDP_FILE,
<1> int ssl23_get_client_hello ( SSL * s ) {\n<3> char * buf = & ( buf_space [ 0 ] ) ;\n<14> if ( n != sizeof buf_space ) return ( n ) ;\n<15> p = s -> packet ;\n<16> memcpy ( buf , p , n ) ;\n<17> if ( ( p [ 0 ] & 0x80 ) && ( p [ 2 ] == SSL2_MT_CLIENT_HELLO ) ) {\n<18> if ( ( p [ 3 ] == 0x00 ) && ( p [ 4 ] == 0x02 ) ) {\n<19> v [ 0 ] = p [ 3 ] ;\n<20> v [ 1 ] = p [ 4 ] ;\n<23> else if ( p [ 3 ] == SSL3_VERSION_MAJOR ) {\n<24> v [ 0 ] = p [ 3 ] ;\n<25> v [ 1 ] = p [ 4 ] ;\n<26> if ( p [ 4 ] >= TLS1_VERSION_MINOR ) {\n<27> if ( p [ 4 ] >= TLS1_2_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_2 ) ) {\n<31> else if ( p [ 4 ] >= TLS1_1_VERSION_MINOR && ! ( s -> options & SSL_OP_NO_TLSv1_1 ) ) {\n<54> else if ( ( p [ 0 ] == SSL3_RT_HANDSHAKE ) && ( p [ 1 ] == SSL3_VERSION_MAJOR ) && ( p [ 5 ] == SSL3_MT_CLIENT_HELLO ) && ( ( p [ 3 ] == 0 && p [ 4 ] < 5 ) || ( p [ 9 ] >= p [ 1 ] ) ) ) {\n<55> v [ 0 ] = p [ 1 ] ;\n<56> if ( p [ 3 ] == 0 && p [ 4 ] < 6 ) {\n<60> if ( p [ 9 ] > SSL3_VERSION_MAJOR ) v [ 1 ] = 0xff ;\n<61> else v [ 1 ] = p [ 10 ] ;\n<91> else if ( ( strncmp ( "GET " , ( char * ) p , 4 ) == 0 ) || ( strncmp ( "POST " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "HEAD " , ( char * ) p , 5 ) == 0 ) || ( strncmp ( "PUT " , ( char * ) p , 4 ) == 0 ) ) {\n<95> else if ( strncmp ( "CONNECT" , ( char * ) p , 7 ) == 0 ) {\n<108> v [ 0 ] = p [ 3 ] ;\n<109> v [ 1 ] = p [ 4 ] ;\n<110> n = ( ( p [ 0 ] & 0x7f ) << 8 ) | p [ 1 ] ;\n<120> if ( j <= 0 ) return ( j ) ;\n<124> p += 5 ;\n<125> n2s ( p , csl ) ;\n<126> n2s ( p , sil ) ;\n<127> n2s ( p , cl ) ;\n<137> * ( d ++ ) = v [ 1 ] ;\n<138> i = ( cl > SSL3_RANDOM_SIZE ) ? SSL3_RANDOM_SIZE : cl ;\n<139> memset ( d , 0 , SSL3_RANDOM_SIZE ) ;\n<140> memcpy ( & ( d [ SSL3_RANDOM_SIZE - i ] ) , & ( p [ csl + sil ] ) , i ) ;\n<141> d += SSL3_RANDOM_SIZE ;\n<142> * ( d ++ ) = 0 ;\n<144> dd = d ;\n<145> d += 2 ;\n<150> * ( d ++ ) = p [ i + 1 ] ;\n<151> * ( d ++ ) = p [ i + 2 ] ;\n<155> * ( d ++ ) = 1 ;\n<156> * ( d ++ ) = 0 ;
<1> static int usb_host_init(void)\n<19> if (rc != 0) {\n<35> poll = libusb_get_pollfds(ctx);\n<39> for (i = 0; poll[i] != NULL; i++) {\n<47> free(poll);
<1> static int nbd_opt_go(QIOChannel *ioc, const char *wantname,\n<9> uint32_t len = strlen(wantname);\n<29> trace_nbd_opt_go_start(wantname);\n<31> buf = g_malloc(4 + len + 2 + 1);\n<33> stl_be_p(buf, len);\n<35> memcpy(buf + 4, wantname, len);\n<39> stw_be_p(buf + 4 + len, 0);\n<41> if (nbd_send_option_request(ioc, NBD_OPT_GO, len + 6, buf, errp) < 0) {
<1> dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,\n<15> const char *device_name = ctx->device_name[devtype];\n<77> buf = dup_wchar_to_utf8(var.bstrVal);\n<81> if (pfilter) {\n<83> if (strcmp(device_name, buf))\n<89> if (!skip--)\n<105> av_free(buf);
<1> static int decode_user_data(Mpeg4DecContext *ctx, GetBitContext *gb)\n<7> char buf[256];\n<13> int ver = 0, build = 0, ver2 = 0, ver3 = 0;\n<29> buf[i] = 0;\n<35> e = sscanf(buf, "DivX%dBuild%d%c", &ver, &build, &last);\n<37> if (e < 2)\n<39> e = sscanf(buf, "DivX%db%d%c", &ver, &build, &last);\n<41> if (e >= 2) {\n<43> ctx->divx_version = ver;\n<45> ctx->divx_build   = build;\n<47> s->divx_packed  = e == 3 && last == 'p';\n<55> e = sscanf(buf, "FFmpe%*[^b]b%d", &build) + 3;\n<57> if (e != 4)\n<59> e = sscanf(buf, "FFmpeg v%d.%d.%d / libavcodec build: %d", &ver, &ver2, &ver3, &build);\n<61> if (e != 4) {\n<63> e = sscanf(buf, "Lavc%d.%d.%d", &ver, &ver2, &ver3) + 1;\n<65> if (e > 1) {\n<67> if (ver > 0xFF || ver2 > 0xFF || ver3 > 0xFF) {\n<79> build = ((ver & 0xFF) << 16) + ((ver2 & 0xFF) << 8) + (ver3 & 0xFF);\n<85> if (e != 4) {\n<87> if (strcmp(buf, "ffmpeg") == 0)\n<89> ctx->lavc_build = 4600;\n<95> ctx->lavc_build = build;\n<101> e = sscanf(buf, "XviD%d", &build);\n<103> if (e == 1)\n<105> ctx->xvid_build = build;
<3> VariantStream *vs, HLSSegment *en,\n<9> if ((hls->flags & (HLS_SECOND_LEVEL_SEGMENT_SIZE | HLS_SECOND_LEVEL_SEGMENT_DURATION)) &&\n<11> strlen(vs->current_segment_final_filename_fmt)) {\n<13> av_strlcpy(vs->avf->filename, vs->current_segment_final_filename_fmt, sizeof(vs->avf->filename));
<1> static void smbios_build_type_1_fields(const char *t)\n<35> if (qemu_uuid_parse(buf, qemu_uuid) != 0) {\n<37> fprintf(stderr, "Invalid SMBIOS UUID string\n");
<1> void qmp_block_commit(const char *device,\n<67> if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_COMMIT, errp)) {\n<81> if (has_top && top) {\n<83> if (strcmp(bs->filename, top) != 0) {\n<85> top_bs = bdrv_find_backing_image(bs, top);\n<95> error_setg(errp, "Top image file %s not found", top ? top : "NULL");\n<137> if (top_bs == bs) {\n<149> commit_active_start(bs, base_bs, speed, on_error, block_job_cb,\n<155> commit_start(bs, base_bs, top_bs, speed, on_error, block_job_cb, bs,
<1> static int sbr_mapping ( AACContext * ac , SpectralBandReplication * sbr , SBRData * ch_data , int e_a [ 2 ] ) {\n<3> memset ( ch_data -> s_indexmapped [ 1 ] , 0 , 7 * sizeof ( ch_data -> s_indexmapped [ 1 ] ) ) ;\n<37> i < ilim ;\n<39> int additional_sinusoid_present = 0 ;\n<44> additional_sinusoid_present = 1 ;\n<48> memset ( & sbr -> s_mapped [ e ] [ table [ i ] - sbr -> kx [ 1 ] ] , additional_sinusoid_present , ( table [ i + 1 ] - table [ i ] ) * sizeof ( sbr -> s_mapped [ e ] [ 0 ] ) ) ;
<1> static int ffm_read_data(AVFormatContext *s,\n<3> uint8_t *buf, int size, int header)\n<7> FFMContext *ffm = s->priv_data;\n<23> len = ffm->packet_end - ffm->packet_ptr;\n<33> if (len == 0) {\n<127> memcpy(buf, ffm->packet_ptr, len);\n<129> buf += len;\n<131> ffm->packet_ptr += len;\n<133> size -= len;
<1> static int bink_decode_plane ( BinkContext * c , GetBitContext * gb , int plane_idx , int is_chroma ) {\n<38> dst = c -> pic -> data [ plane_idx ] + 8 * by * stride ;\n<42> bx ++ , dst += 8 , prev += 8 ) {\n<50> switch ( blk ) {\n<54> switch ( blk ) {\n<79> case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<80> dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n<81> read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n<82> c -> bdsp . idct_put ( ublock , 8 , dctblock ) ;\n<135> j ++ ) dst [ coordmap [ * scan ++ ] ] = v ;\n<140> j ++ ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n<144> if ( i == 63 ) dst [ coordmap [ * scan ++ ] ] = get_value ( c , BINK_SRC_COLORS ) ;\n<159> case INTRA_BLOCK : memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<160> dctblock [ 0 ] = get_value ( c , BINK_SRC_INTRA_DC ) ;\n<161> read_dct_coeffs ( gb , dctblock , bink_scan , bink_intra_quant , - 1 ) ;\n<162> c -> bdsp . idct_put ( dst , stride , dctblock ) ;\n<171> memset ( dctblock , 0 , sizeof ( * dctblock ) * 64 ) ;\n<172> dctblock [ 0 ] = get_value ( c , BINK_SRC_INTER_DC ) ;\n<173> read_dct_coeffs ( gb , dctblock , bink_scan , bink_inter_quant , - 1 ) ;\n<174> c -> bdsp . idct_add ( dst , stride , dctblock ) ;\n<185> j ++ , v >>= 1 ) dst [ i * stride + j ] = col [ v & 1 ] ;\n<189> i < 8 ;\n<190> i ++ ) memcpy ( dst + i * stride , c -> bundle [ BINK_SRC_COLORS ] . cur_ptr + i * 8 , 8 ) ;
<1> static void fill_elf_header(struct elfhdr *elf, int segs, uint16_t machine,\n<7> (void) memset(elf, 0, sizeof(*elf));\n<11> (void) memcpy(elf->e_ident, ELFMAG, SELFMAG);
<1> static void kvm_pit_put(PITCommonState *pit)\n<71> if (ret < 0) {\n<77> strerror(ret));
<11> if (st->codecpar->extradata_size < source_st->codecpar->extradata_size) {\n<15> av_freep(&st->codecpar->extradata);\n<25> if (ret < 0)\n<31> memcpy(st->codecpar->extradata, source_st->codecpar->extradata,
<1> static int slirp_hostfwd(SlirpState *s, const char *redir_str,\n<15> char buf[256];\n<25> if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n<31> if (!strcmp(buf, "tcp") || buf[0] == '\0') {\n<33> is_udp = 0;\n<35> } else if (!strcmp(buf, "udp")) {\n<37> is_udp = 1;\n<47> if (!legacy_format) {\n<123> error_report("invalid host forwarding rule '%s'", redir_str);\n<125> return -1;
<1> static void pxa2xx_pwrmode_write(CPUARMState *env, const ARMCPRegInfo *ri,\n<19> if (value & 8) {\n<21> printf("%s: CPU voltage change attempt\n", __func__);\n<25> switch (value & 7) {\n<39> if (!(s->cm_regs[CCCR >> 2] & (1U << 31))) { /* CPDIS */\n<95> memset(s->cpu->env.regs, 0, 4 * 15);\n<129> printf("%s: machine entered %s mode\n", __func__,
<1> static int http_read(URLContext *h, uint8_t *buf, int size)\n<5> HTTPContext *s = h->priv_data;\n<17> len = s->buf_end - s->buf_ptr;\n<19> if (len > 0) {\n<21> if (len > size)\n<23> len = size;\n<25> memcpy(buf, s->buf_ptr, len);\n<27> s->buf_ptr += len;\n<45> size -= len;\n<47> buf += len;
<1> void disas(FILE *out, void *code, unsigned long size)\n<15> INIT_DISASSEMBLE_INFO(disasm_info, out, fprintf);\n<97> fprintf(out, "0x%lx: Asm output not supported on this arch\n",\n<105> for (pc = (unsigned long)code; size > 0; pc += count, size -= count) {\n<107> fprintf(out, "0x%08lx:  ", pc);\n<121> fprintf(out, "\n");
<1> static int parse_read_intervals(const char *intervals_spec)\n<19> if (*p == ',')\n<43> p = spec;\n<45> for (i = 0; i < n; i++) {\n<47> char *next = strchr(p, ',');\n<51> *next++ = 0;\n<57> ret = parse_read_interval(p, &read_intervals[i]);\n<73> p = next;